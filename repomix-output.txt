This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-13T23:32:03.623Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.claude/
  mcp.json
stash/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Extensions/
    AppModelExtensions.swift
    LoggerExtensions.swift
    UserDefaultsExtensions.swift
  Models/
    AppImports.swift
    AppModel.swift
    FilterOptions.swift
    FilterPreset.swift
    SceneFilterType.swift
    StashModels.swift
  Networking/
    StashAPI.swift
    StashAPI.swift.bak2
    StashAPIError.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  Utilities/
    AnimationModifiers.swift
    VideoPlayerUtility.swift
  ViewModels/
    MarkerViewModel.swift
    VideoPlayerViewModel.swift
  Views/
    Connection/
      ConnectionView.swift
      EnhancedConnectionView.swift
    Filters/
      FilterMenuSheet.swift
      FilterMenuView.swift
      FilterOptionsView.swift
      PerformerSelectionListView.swift
      TagSelectionListView.swift
    Markers/
      CreateMarkerView.swift
      MarkerRow.swift
      MarkerView.swift
      PerformerSelectionView.swift
      SceneSelectionView.swift
    Performers/
      PerformerDetailView.swift
      PerformerHeaderView.swift
      PerformerMarkerDetailView.swift
      PerformerMarkerRow.swift
      PerformerMarkersView.swift
      PerformerRow.swift
      PerformerTabView.swift
      PerformerTabView.swift-e
    Player/
      CustomVideoPlayer.swift
    Scenes/
      SceneFilterView.swift
      SceneRow.swift
      ScenesGrid.swift
    Settings/
      SettingsView.swift
    Tags/
      TagEditorView.swift
      TagSelectionView.swift
    MarkersView.swift
    MediaLibraryView.swift
    PerformersView.swift
    SplashScreen.swift
    TaggedScenesView.swift
    VideoPlayerView.swift
  AppDelegate.swift
  ContentView.swift
  Models.swift
  stashApp.swift
  StashImports.swift
  ViewModels.swift
  Views.swift
stash.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      stash.xcscheme
  xcuserdata/
    charleskrivan.xcuserdatad/
      xcschemes/
        xcschememanagement.plist
  project.pbxproj
temp_icons/
  AppIcon.appiconset/
    Contents.json
  new_icon.svg
.gitignore
build_error_log.txt
claude.md
fetchMarkers.txt
new_contents.txt
original_fetchMarkers.txt
prompt.md

================================================================
Files
================================================================

================
File: .claude/mcp.json
================
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp@latest"]
    }
  }
}

================
File: stash/Assets.xcassets/AccentColor.colorset/Contents.json
================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: stash/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "filename" : "AppIcon-1024.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "filename" : "AppIcon-1024-dark.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "filename" : "AppIcon-1024-tinted.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: stash/Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: stash/Extensions/AppModelExtensions.swift
================
import Foundation
import SwiftUI
import Combine
import AVKit
import UIKit

// This file extends AppModel with references to the necessary model types
// to fix compiler errors related to missing type references

extension AppModel {
    // StashScene and SceneMarker references to help with compilation
    typealias Scene = StashScene
    typealias Marker = SceneMarker
    
    // Import required models for our navigations
    func importModels() {
        // This is a no-op function that's just here to ensure
        // the compiler can link these types properly
        _ = StashScene.self
        _ = SceneMarker.self
        _ = StashAPI.self
    }
}

================
File: stash/Extensions/LoggerExtensions.swift
================
import os.log
import Foundation

extension Logger {
    private static var subsystem = Bundle.main.bundleIdentifier!
    
    static let networking = Logger(subsystem: subsystem, category: "networking")
    static let ui = Logger(subsystem: subsystem, category: "ui")
    static let player = Logger(subsystem: subsystem, category: "player")
    static let connection = Logger(subsystem: subsystem, category: "connection")
    
    func logRequest(_ request: URLRequest) {
        let method = request.httpMethod ?? "Unknown"
        let url = request.url?.absoluteString ?? "Unknown"
        let headers = request.allHTTPHeaders?.description ?? "None"
        let body = request.httpBody.flatMap { String(data: $0, encoding: .utf8) } ?? "None"
        
        self.debug("""
        üåê HTTP Request:
        Method: \(method)
        URL: \(url)
        Headers: \(headers)
        Body: \(body)
        """)
    }
    
    func logResponse(_ response: HTTPURLResponse, data: Data?) {
        let status = response.statusCode
        let headers = response.allHeaderFields.description
        let body = data.flatMap { String(data: $0, encoding: .utf8) } ?? "None"
        
        self.debug("""
        üì• HTTP Response:
        Status: \(status)
        Headers: \(headers)
        Body: \(body)
        """)
    }
}

extension URLRequest {
    var allHTTPHeaders: [String: String]? {
        return self.allHTTPHeaderFields
    }
}

================
File: stash/Extensions/UserDefaultsExtensions.swift
================
import Foundation

extension UserDefaults {
    func setVideoProgress(_ progress: Double, for sceneId: String) {
        set(progress, forKey: "video_progress_\(sceneId)")
    }
    
    func getVideoProgress(for sceneId: String) -> Double {
        return double(forKey: "video_progress_\(sceneId)")
    }
}

================
File: stash/Models/AppImports.swift
================
import Foundation
import SwiftUI
import Combine
import AVKit
import UIKit

/// This file provides an easy way to import all common models and types
/// used throughout the app to avoid missing imports in individual files.

// Re-export key types for easy import
@_exported import struct Foundation.URL
@_exported import class AVKit.AVPlayerViewController
@_exported import class AVKit.AVPlayer

================
File: stash/Models/AppModel.swift
================
import Foundation
import SwiftUI
import Combine
import AVKit
import UIKit

// Import local model types
@_exported import struct Foundation.URL

class AppModel: ObservableObject {
    // MARK: - Connection State
    @Published var isConnected: Bool = false
    @Published var serverAddress: String = UserDefaults.standard.string(forKey: "serverAddress") ?? ""
    @Published var apiKey: String = UserDefaults.standard.string(forKey: "apiKey") ?? "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJjayIsInN1YiI6IkFQSUtleSIsImlhdCI6MTczMTgwOTM2Mn0.7AOyZqTzyDsSnuDx__RBhuIIkoPg2btebToAlpK1zXo"
    @Published var isAttemptingConnection: Bool = false
    @Published var connectionError: String?
    
    // MARK: - Content State
    @Published var currentScene: StashScene?
    @Published var currentPerformer: StashScene.Performer?
    @Published var currentMarker: SceneMarker?
    @Published var performerScenes: [StashScene] = [] // Separate array for performer scenes
    
    // MARK: - UI State
    @Published var activeTab: Tab = .scenes
    @Published var searchQuery: String = ""
    @Published var isSearching: Bool = false
    @Published var showingFilterOptions: Bool = false
    
    // MARK: - Navigation
    @Published var navigationPath = NavigationPath()
    
    // MARK: - API
    @Published private(set) var api: StashAPI
    private var cancellables = Set<AnyCancellable>()
    
    // Map to track API instances
    private static var sharedAPIs: [String: StashAPI] = [:]
    
    // MARK: - API Connection Status
    var isConnectionOK: Bool {
        api.connectionStatus == .connected
    }
    
    // MARK: - Lifecycle
    init() {
        // Default API key
        let savedAPIKey = UserDefaults.standard.string(forKey: "apiKey") ?? "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJjayIsInN1YiI6IkFQSUtleSIsImlhdCI6MTczMTgwOTM2Mn0.7AOyZqTzyDsSnuDx__RBhuIIkoPg2btebToAlpK1zXo"
        
        // Default server address
        let savedAddress = UserDefaults.standard.string(forKey: "serverAddress") ?? "http://192.168.86.100:9999"
        
        // Create or get shared API instance
        let cacheKey = "\(savedAddress)_\(savedAPIKey)"
        if let existingAPI = AppModel.sharedAPIs[cacheKey] {
            print("‚ôªÔ∏è Reusing existing StashAPI instance")
            self.api = existingAPI
        } else {
            print("üÜï Creating new StashAPI instance")
            let newAPI = StashAPI(serverAddress: savedAddress, apiKey: savedAPIKey)
            AppModel.sharedAPIs[cacheKey] = newAPI
            self.api = newAPI
        }
        
        setupBindings()
        checkForSavedConnection()
    }
    
    private func setupBindings() {
        $serverAddress
            .dropFirst()
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .sink { [weak self] newAddress in
                guard let self = self else { return }
                if !newAddress.isEmpty {
                    // Create or get shared API instance
                    let cacheKey = "\(newAddress)_\(self.apiKey)"
                    if let existingAPI = AppModel.sharedAPIs[cacheKey] {
                        print("‚ôªÔ∏è Reusing existing StashAPI instance for: \(newAddress)")
                        self.api = existingAPI
                    } else {
                        print("üÜï Creating new StashAPI instance for: \(newAddress)")
                        let newAPI = StashAPI(serverAddress: newAddress, apiKey: self.apiKey)
                        AppModel.sharedAPIs[cacheKey] = newAPI
                        self.api = newAPI
                    }
                }
            }
            .store(in: &cancellables)
    }
    
    private func checkForSavedConnection() {
        // Load saved server address
        if let savedAddress = UserDefaults.standard.string(forKey: "serverAddress"), !savedAddress.isEmpty {
            serverAddress = savedAddress
            isConnected = true
            
            // Load saved API key
            let savedAPIKey = UserDefaults.standard.string(forKey: "apiKey") ?? "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJjayIsInN1YiI6IkFQSUtleSIsImlhdCI6MTczMTgwOTM2Mn0.7AOyZqTzyDsSnuDx__RBhuIIkoPg2btebToAlpK1zXo"
            apiKey = savedAPIKey
            
            // Initialize API with saved settings - already done in init
        }
    }
    
    // MARK: - Connection Management
    func attemptConnection() {
        guard !serverAddress.isEmpty else { return }
        
        var address = serverAddress
        if !address.hasPrefix("http://") && !address.hasPrefix("https://") {
            address = "http://" + address
        }
        if !address.contains(":9999") && !address.contains(":443") {
            if address.hasSuffix("/") {
                address.removeLast()
            }
            address += ":9999"
        }
        
        isAttemptingConnection = true
        connectionError = nil
        
        // Update server address
        UserDefaults.standard.set(address, forKey: "serverAddress")
        self.serverAddress = address
        
        // Save API key
        UserDefaults.standard.set(apiKey, forKey: "apiKey")
        
        // Create or get shared API instance
        let cacheKey = "\(address)_\(apiKey)"
        if let existingAPI = AppModel.sharedAPIs[cacheKey] {
            print("‚ôªÔ∏è Reusing existing StashAPI instance for connection")
            self.api = existingAPI
        } else {
            print("üÜï Creating new StashAPI instance for connection")
            let newAPI = StashAPI(serverAddress: address, apiKey: apiKey)
            AppModel.sharedAPIs[cacheKey] = newAPI
            self.api = newAPI
        }
        
        // Check connection using the new API
        Task {
            // Check connection
            do {
                try await api.checkServerConnection()
            } catch {
                print("Connection check failed: \(error)")
            }
            
            // Update UI based on connection status
            await MainActor.run {
                switch api.connectionStatus {
                case .connected:
                    self.isConnected = true
                    self.connectionError = nil
                    print("‚úÖ Connection successful")
                    
                case .authenticationFailed:
                    self.isConnected = false
                    self.connectionError = "Authentication failed - check API key"
                    
                case .disconnected:
                    self.isConnected = false
                    self.connectionError = "Could not connect to server"
                    
                case .failed(let error):
                    self.isConnected = false
                    self.connectionError = error.localizedDescription
                    
                case .unknown:
                    self.isConnected = false
                    self.connectionError = "Unknown connection status"
                }
                
                self.isAttemptingConnection = false
            }
        }
    }
    
    func disconnect() {
        isConnected = false
    }
    
    // MARK: - Navigation
    func navigateToScene(_ scene: StashScene, startSeconds: Double? = nil) {
        print("üöÄ NAVIGATION - Navigating to scene: \(scene.title ?? "Untitled") with startSeconds: \(String(describing: startSeconds))")
        
        // Store both scene and timestamp in properties
        currentScene = scene
        
        // Store startSeconds directly in the model for VideoPlayerView to access
        if let startSeconds = startSeconds {
            print("‚è± Setting current timestamp to: \(startSeconds) seconds")
            UserDefaults.standard.set(startSeconds, forKey: "scene_\(scene.id)_startTime")
        }
        
        // Just append the scene to navigation path
        print("‚è± Adding scene to navigation path")
        navigationPath.append(scene)
    }
    
    func navigateToPerformer(_ performer: StashScene.Performer) {
        print("üöÄ NAVIGATION - Navigating to performer: \(performer.name) (ID: \(performer.id))")
        print("üîç NAVIGATION - Current stack: \(navigationPath)")

        // Set current performer
        currentPerformer = performer

        // Clear existing scenes first to avoid showing incorrect data temporarily
        api.scenes = []
        print("üßπ NAVIGATION - Cleared existing scenes")

        // Then navigate FIRST before loading data
        // This prevents issues with view updates when loading data
        navigationPath.append(performer)
        print("üèÅ NAVIGATION - Navigation completed to performer: \(performer.name)")

        // Let the PerformerDetailView handle loading scenes through its onAppear method
        // This is more reliable than pre-fetching, as the view has local state to display scenes
    }
    
    func navigateToMarker(_ marker: SceneMarker) {
        print("üöÄ NAVIGATION - Navigating to marker: \(marker.title) at \(marker.seconds) seconds in scene \(marker.scene.id)")
        
        currentMarker = marker
        
        // For direct marker playback, we actually want to navigate to the scene
        // with the marker's timestamp as the start position
        Task {
            // Use marker's scene info to fetch the full scene
            if let fullScene = try? await api.fetchScene(byID: marker.scene.id) {
                print("‚úÖ Found full scene for marker: \(marker.title)")
                // Important: Convert float seconds to Double for startSeconds parameter
                let startSeconds = Double(marker.seconds)
                print("‚ÑπÔ∏è Setting startSeconds parameter to \(startSeconds) for scene \(fullScene.id)")
                
                // Navigate to the scene with the marker timestamp directly as a parameter
                // This passes startTime directly to VideoPlayerView's initializer
                navigateToScene(fullScene, startSeconds: startSeconds)
            } else {
                // If we can't fetch the scene, fall back to direct marker navigation
                print("‚ö†Ô∏è Could not find full scene for marker, using fallback navigation")
                navigationPath.append(marker)
            }
        }
    }

    func navigateToTag(_ tag: StashScene.Tag) {
        print("üöÄ NAVIGATION - Navigating to tag: \(tag.name) (ID: \(tag.id))")

        // Clear existing scenes first to avoid showing incorrect data temporarily
        api.scenes = []
        print("üßπ NAVIGATION - Cleared existing scenes for tag view")

        // Navigate to the tag
        navigationPath.append(tag)
        print("üèÅ NAVIGATION - Navigation completed to tag: \(tag.name)")

        // Let the TaggedScenesView handle loading scenes through its onAppear method
    }
    
    // MARK: - Model References
    // These are included to help with type resolution during compilation
    func modelReferences() {
        // This function is never called - it just helps link the types
        let _ = StashScene(
            id: "",
            title: nil,
            details: nil,
            paths: StashScene.ScenePaths(screenshot: "", preview: nil, stream: ""),
            files: [],
            performers: [],
            tags: [],
            rating100: nil,
            o_counter: nil
        )
        
        let _ = SceneMarker(
            id: "",
            title: "",
            seconds: 0,
            end_seconds: nil,
            stream: "",
            preview: "",
            screenshot: "",
            scene: SceneMarker.MarkerScene(id: ""),
            primary_tag: SceneMarker.Tag(id: "", name: ""),
            tags: []
        )
    }
    
    func popNavigation() {
        if !navigationPath.isEmpty {
            navigationPath.removeLast()
        }
    }
    
    func clearNavigation() {
        navigationPath = NavigationPath()
    }
    
    // MARK: - Tab Management
    func selectTab(_ tab: Tab) {
        activeTab = tab
        clearNavigation()
    }
}

// MARK: - Types
extension AppModel {
    enum Tab: String, CaseIterable {
        case scenes = "Scenes"
        case performers = "Performers"
        case markers = "Markers"
        
        var icon: String {
            switch self {
            case .scenes: return "film"
            case .performers: return "person.2"
            case .markers: return "bookmark.fill"
            }
        }
    }
}

================
File: stash/Models/FilterOptions.swift
================
import Foundation
import SwiftUI

class FilterOptions: ObservableObject {
    @Published var minimumRating: Int? = nil
    @Published var selectedResolution: String? = nil
    @Published var isFavoritesOnly: Bool = false
    @Published var minimumDuration: Int? = nil
    @Published var maximumDuration: Int? = nil
    @Published var selectedTagIds: [String] = []
    @Published var selectedPerformerIds: [String] = []
    @Published var sortField: String = "date"
    @Published var sortDirection: String = "DESC"
    
    // Generate filter for GraphQL query
    func generateSceneFilter() -> [String: Any] {
        var sceneFilter: [String: Any] = [:]
        
        // Rating filter
        if let rating = minimumRating {
            sceneFilter["rating100"] = [
                "value": rating,
                "modifier": "GREATER_THAN"
            ]
        }
        
        // Resolution filter
        if let resolution = selectedResolution {
            sceneFilter["resolution"] = [
                "value": resolution,
                "modifier": "EQUALS"
            ]
        }
        
        // Favorites filter
        if isFavoritesOnly {
            sceneFilter["favorite"] = [
                "value": true
            ]
        }
        
        // Duration filter
        if let minDuration = minimumDuration {
            sceneFilter["duration"] = [
                "value": minDuration,
                "modifier": "GREATER_THAN"
            ]
        }
        
        if let maxDuration = maximumDuration {
            sceneFilter["duration"] = [
                "value": maxDuration,
                "modifier": "LESS_THAN"
            ]
        }
        
        // Tags filter
        if !selectedTagIds.isEmpty {
            sceneFilter["tags"] = [
                "value": selectedTagIds,
                "modifier": "INCLUDES"
            ]
        }
        
        // Performers filter
        if !selectedPerformerIds.isEmpty {
            sceneFilter["performers"] = [
                "value": selectedPerformerIds,
                "modifier": "INCLUDES"
            ]
        }
        
        return sceneFilter
    }
    
    // Reset all filters
    func reset() {
        minimumRating = nil
        selectedResolution = nil
        isFavoritesOnly = false
        minimumDuration = nil
        maximumDuration = nil
        selectedTagIds = []
        selectedPerformerIds = []
        sortField = "date"
        sortDirection = "DESC"
    }
}

================
File: stash/Models/FilterPreset.swift
================
import Foundation

/// Predefined filter presets for common filtering scenarios
enum FilterPreset: String, CaseIterable, Identifiable {
    case all = "All"
    case recent = "Recent"
    case untagged = "Untagged"
    case unwatched = "Unwatched"
    case favorites = "Favorites"
    case popular = "Popular"
    case highest_rated = "Highest Rated"
    case longest = "Longest"
    case shortest = "Shortest"
    
    var id: String { rawValue }
    
    /// Returns a FilterOptions object configured for this preset
    func getFilterOptions() -> FilterOptions {
        let options = FilterOptions()
        
        switch self {
        case .all:
            // Default options - no filters
            options.sortField = "date"
            options.sortDirection = "DESC"
        
        case .recent:
            options.sortField = "date"
            options.sortDirection = "DESC"
            
        case .untagged:
            // No tags filter - handled separately in query
            options.sortField = "date"
            options.sortDirection = "DESC"
            
        case .unwatched:
            // O-counter is 0 - handled separately in query
            options.sortField = "date"
            options.sortDirection = "DESC"
            
        case .favorites:
            options.isFavoritesOnly = true
            options.sortField = "date"
            options.sortDirection = "DESC"
            
        case .popular:
            options.sortField = "o_counter"
            options.sortDirection = "DESC"
            
        case .highest_rated:
            options.sortField = "rating100"
            options.sortDirection = "DESC"
            
        case .longest:
            options.sortField = "duration"
            options.sortDirection = "DESC"
            
        case .shortest:
            options.sortField = "duration"
            options.sortDirection = "ASC"
        }
        
        return options
    }
    
    /// Returns a GraphQL query string for this preset
    func getGraphQLQuery(page: Int = 1, perPage: Int = 40) -> String {
        let randomSeed = Int.random(in: 0...999999)
        
        switch self {
        case .untagged:
            // Custom query for scenes with no tags
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "date",
                        "direction": "DESC"
                    },
                    "scene_filter": {
                        "tags": {
                            "modifier": "EQUALS",
                            "value": []
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
            
        case .unwatched:
            // Custom query for scenes that haven't been watched (o_counter = 0)
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "date",
                        "direction": "DESC"
                    },
                    "scene_filter": {
                        "o_counter": {
                            "modifier": "EQUALS",
                            "value": 0
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
            
        case .popular:
            // Custom query for popular scenes (highest o_counter)
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "o_counter",
                        "direction": "DESC"
                    }
                },
                "query": "query FindScenes($filter: FindFilterType) { findScenes(filter: $filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
            
        case .highest_rated:
            // Custom query for highest rated scenes
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "rating100",
                        "direction": "DESC"
                    },
                    "scene_filter": {
                        "rating100": {
                            "modifier": "GREATER_THAN",
                            "value": 0
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
            
        case .longest, .shortest:
            // Custom query for duration sorting
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "duration",
                        "direction": "\(self == .longest ? "DESC" : "ASC")"
                    }
                },
                "query": "query FindScenes($filter: FindFilterType) { findScenes(filter: $filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
            
        case .favorites:
            // Custom query for favorite scenes
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "date",
                        "direction": "DESC"
                    },
                    "scene_filter": {
                        "favorite": {
                            "value": true
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
            
        default:
            // Default query for all scenes
            return """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": \(page),
                        "per_page": \(perPage),
                        "sort": "\(self == .all ? "date" : "random_\(randomSeed)")",
                        "direction": "DESC"
                    }
                },
                "query": "query FindScenes($filter: FindFilterType) { findScenes(filter: $filter) { count scenes { id title details url date rating100 organized o_counter paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender } tags { id name } studio { id name } stash_ids { endpoint stash_id } created_at updated_at } } }"
            }
            """
        }
    }
}

================
File: stash/Models/SceneFilterType.swift
================
import Foundation

/// Scene filter type for Stash API requests
struct SceneFilterType {
    /// Tag IDs to filter by
    var tags: [String]?
    /// Tag IDs to exclude
    var excludedTags: [String]?
    /// Performer IDs to filter by
    var performers: [String]?
    /// Studio IDs to filter by
    var studios: [String]?
    /// Search term for filtering scenes
    var searchTerm: String?
    /// Minimum duration in seconds
    var minDuration: Int?
    /// Maximum duration in seconds
    var maxDuration: Int?
    /// Minimum rating (0-100)
    var minRating: Int?
    /// Whether to only include favorites
    var favoritesOnly: Bool?

    init(tags: [String]? = nil,
         excludedTags: [String]? = ["vr"], // Default to excluding VR tag
         performers: [String]? = nil,
         studios: [String]? = nil,
         searchTerm: String? = nil,
         minDuration: Int? = nil,
         maxDuration: Int? = nil,
         minRating: Int? = nil,
         favoritesOnly: Bool? = nil) {
        self.tags = tags
        self.excludedTags = excludedTags
        self.performers = performers
        self.studios = studios
        self.searchTerm = searchTerm
        self.minDuration = minDuration
        self.maxDuration = maxDuration
        self.minRating = minRating
        self.favoritesOnly = favoritesOnly
    }
    
    /// Converts FilterOptions to SceneFilterType
    static func fromFilterOptions(_ options: FilterOptions) -> SceneFilterType {
        return SceneFilterType(
            tags: options.selectedTagIds.isEmpty ? nil : options.selectedTagIds,
            excludedTags: ["vr"], // Always exclude VR content
            performers: options.selectedPerformerIds.isEmpty ? nil : options.selectedPerformerIds,
            minDuration: options.minimumDuration,
            maxDuration: options.maximumDuration,
            minRating: options.minimumRating,
            favoritesOnly: options.isFavoritesOnly ? true : nil
        )
    }

    /// Helper method to create a filter that excludes VR content
    static func withoutVR() -> SceneFilterType {
        return SceneFilterType(excludedTags: ["vr"])
    }
}

================
File: stash/Models/StashModels.swift
================
import Foundation

// MARK: - Models
struct StashScene: Identifiable, Decodable, Equatable, Hashable {
    let id: String
    let title: String?
    let details: String?
    let paths: ScenePaths
    let files: [SceneFile]
    let performers: [Performer]
    let tags: [Tag]
    let rating100: Int?
    let o_counter: Int?

    static func == (lhs: StashScene, rhs: StashScene) -> Bool {
        return lhs.id == rhs.id
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    struct ScenePaths: Decodable, Equatable {
        let screenshot: String
        let preview: String?
        let stream: String
    }
    
    struct SceneFile: Decodable, Equatable {
        let size: Int
        let duration: Float
        let video_codec: String?
        let width: Int?
        let height: Int?
        
        var formattedSize: String {
            let bytes = Double(size)
            let units = ["B", "KB", "MB", "GB"]
            var level = 0
            var value = bytes
            
            while value > 1024 && level < units.count - 1 {
                value /= 1024
                level += 1
            }
            
            return String(format: "%.1f %@", value, units[level])
        }
    }
    
    struct Performer: Identifiable, Decodable, Equatable, Hashable {
        let id: String
        let name: String
        let gender: String?
        let image_path: String?
        let scene_count: Int?
        let favorite: Bool?
        let rating100: Int?
        
        func hash(into hasher: inout Hasher) {
            hasher.combine(id)
        }
        
        static func == (lhs: Performer, rhs: Performer) -> Bool {
            return lhs.id == rhs.id
        }
    }
    
    struct Tag: Identifiable, Decodable, Equatable, Hashable {
        let id: String
        let name: String

        func hash(into hasher: inout Hasher) {
            hasher.combine(id)
        }
    }
}

// Removed duplicate GraphQL response types

struct SceneMarker: Identifiable, Decodable, Equatable, Hashable {
    let id: String
    let title: String
    let seconds: Float
    let end_seconds: Float?
    let stream: String
    let preview: String
    let screenshot: String
    let scene: MarkerScene
    let primary_tag: Tag
    let tags: [Tag]

    // Computed property to format the time
    var formattedTime: String {
        let totalSeconds = Int(seconds)
        let hours = totalSeconds / 3600
        let minutes = (totalSeconds % 3600) / 60
        let seconds = totalSeconds % 60

        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, seconds)
        } else {
            return String(format: "%02d:%02d", minutes, seconds)
        }
    }
    
    struct MarkerScene: Identifiable, Decodable, Equatable, Hashable {
        let id: String
        let title: String?
        let paths: ScenePaths?
        let performers: [StashScene.Performer]?
        let files: [VideoFile]?

        // For backward compatibility
        enum CodingKeys: String, CodingKey {
            case id
            case title
            case paths
            case performers
            case files
        }

        // Default initializer that only requires id
        init(id: String) {
            self.id = id
            self.title = nil
            self.paths = nil
            self.performers = nil
            self.files = nil
        }

        // Full initializer for when we have all data
        init(id: String, title: String?, paths: ScenePaths?, performers: [StashScene.Performer]?, files: [VideoFile]? = nil) {
            self.id = id
            self.title = title
            self.paths = paths
            self.performers = performers
            self.files = files
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            id = try container.decode(String.self, forKey: .id)
            title = try container.decodeIfPresent(String.self, forKey: .title)
            paths = try container.decodeIfPresent(ScenePaths.self, forKey: .paths)
            performers = try container.decodeIfPresent([StashScene.Performer].self, forKey: .performers)
            files = try container.decodeIfPresent([VideoFile].self, forKey: .files)
        }

        func hash(into hasher: inout Hasher) {
            hasher.combine(id)
        }

        struct ScenePaths: Decodable, Equatable {
            let screenshot: String?
            let preview: String?
            let stream: String?
        }
        
        struct VideoFile: Decodable, Equatable, Hashable {
            let width: Int?
            let height: Int?
            let path: String?
        }
    }
    
    struct Tag: Identifiable, Decodable, Equatable, Hashable {
        let id: String
        let name: String
        
        func hash(into hasher: inout Hasher) {
            hasher.combine(id)
        }
    }
    
    static func == (lhs: SceneMarker, rhs: SceneMarker) -> Bool {
        return lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

struct SceneMarkersResponse: Decodable {
    let findSceneMarkers: FindSceneMarkersResult
    
    struct FindSceneMarkersResult: Decodable {
        let scene_markers: [SceneMarker]
        let count: Int
    }
}

struct SceneMarkerTagsResponse: Decodable {
    let sceneMarkerTags: [SceneMarkerTag]
    
    struct SceneMarkerTag: Decodable {
        let tag: Tag
        let scene_markers: [SceneMarker]
        
        struct Tag: Decodable {
            let id: String
            let name: String
        }
    }
}

struct TagCreateResponse: Decodable {
    let tagCreate: StashScene.Tag?
}

struct SceneUpdateResponse: Decodable {
    let sceneUpdate: StashScene?
}

================
File: stash/Networking/StashAPI.swift
================
// BEGIN NEW FETCHMARKERS
import Foundation
import SwiftUI
import Combine

enum PerformerFilter {
    case all
    case lessThanTwo
    case twoOrMore
    case tenOrMore
}

struct ScenesResponseData: Decodable {
    let findScenes: FindScenesResult

    struct FindScenesResult: Decodable {
        let scenes: [StashScene]
        let count: Int
    }
}

struct GraphQLResponse<T: Decodable>: Decodable {
    let data: T
    let errors: [GraphQLError]?
}

struct GraphQLError: Decodable, Identifiable, CustomStringConvertible {
    let message: String
    let path: [String]?
    let extensions: [String: String]?

    // For Identifiable conformance
    var id: String { message }

    // For easier debugging
    var description: String {
        if let path = path {
            return "GraphQL Error: \(message) (path: \(path.joined(separator: ".")))"
        }
        return "GraphQL Error: \(message)"
    }

    // Custom coding keys for flexible decoding
    enum CodingKeys: String, CodingKey {
        case message
        case path
        case extensions
    }

    // Custom init to handle optional fields
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        message = try container.decode(String.self, forKey: .message)
        path = try container.decodeIfPresent([String].self, forKey: .path)
        extensions = try container.decodeIfPresent([String: String].self, forKey: .extensions)
    }
}

struct PerformersResponse: Decodable {
    let findPerformers: FindPerformersResult

    struct FindPerformersResult: Decodable {
        let count: Int
        let performers: [StashScene.Performer]
    }
}

struct ScenesResponse: Decodable {
    let data: ScenesData

    struct ScenesData: Decodable {
        let findScenes: FindScenesResult

        struct FindScenesResult: Decodable {
            let count: Int
            let scenes: [StashScene]
        }
    }
}

struct SceneResponse: Decodable {
    let findScene: StashScene
}

struct SystemStatus: Decodable {
    let databaseSchema: Int?
    let databasePath: String?
    let configPath: String?
    let appSchema: Int?
    let status: String?
    let appName: String?
    let appVersion: String?
    let logFile: String?
    let maxSessionAge: Int?
}

struct TagSearchResponse: Decodable {
    let data: TagData

    struct TagData: Decodable {
        let findTags: TagResults

        struct TagResults: Decodable {
            let count: Int
            let tags: [StashScene.Tag]
        }
    }
}

/// Stats data response from the Stash API
struct StatsDataResponse: Decodable {
    let stats: StashStats
}

class StashAPI: ObservableObject {
    // MARK: - Published Properties
    @Published var scenes: [StashScene] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var performers: [StashScene.Performer] = []
    @Published var markers: [SceneMarker] = []
    @Published var totalSceneCount: Int = 0
    @Published var totalPerformerCount: Int = 0
    @Published var connectionStatus: ConnectionStatus = .unknown
    @Published var sceneID: String?
    @Published var isAuthenticated = false
    @Published var isConnected = false
    @Published var systemStatus: SystemStatus?
    @Published var serverAddressPublic = ""
    @Published var preview: Bool = false
    
    // Add the StashAPI singleton reference
    static var shared: StashAPI? {
        get {
            return StashAPIManager.shared.api
        }
    }

    // MARK: - Properties
    let serverAddress: String
    private var currentTask: Task<Void, Never>?
    private var cancellables = Set<AnyCancellable>()

    // API Authentication
    private let apiKey: String
    
    // Public getter for apiKey to be used by VideoPlayerUtility
    var apiKeyForURLs: String {
        return apiKey
    }

    let decoder = JSONDecoder()
    let encoder = JSONEncoder()

    // MARK: - Connection Status
    enum ConnectionStatus: Equatable {
        case connected
        case disconnected
        case authenticationFailed
        case unknown
        case failed(Error)

        static func == (lhs: ConnectionStatus, rhs: ConnectionStatus) -> Bool {
            switch (lhs, rhs) {
            case (.connected, .connected),
                 (.disconnected, .disconnected),
                 (.authenticationFailed, .authenticationFailed),
                 (.unknown, .unknown):
                return true
            case (.failed(let lhsError), .failed(let rhsError)):
                return lhsError.localizedDescription == rhsError.localizedDescription
            default:
                return false
            }
        }
    }

    // MARK: - Initialization
    init(serverAddress: String, apiKey: String) {
        self.serverAddress = serverAddress
        self.apiKey = apiKey
        print("üîÑ StashAPI initializing with server: \(serverAddress)")
        print("üîë Using API key: \(apiKey.prefix(10))...")

        self.decoder.keyDecodingStrategy = .convertFromSnakeCase

        // Check if we have an API key
        if !apiKey.isEmpty {
            self.isAuthenticated = true
        }

        // Configure session
        URLSession.shared.configuration.timeoutIntervalForRequest = 30.0
        URLSession.shared.configuration.timeoutIntervalForResource = 60.0

        // Trigger a connection check asynchronously
        Task {
            try? await checkAndUpdateConnectionStatus()
        }
    }

    // Check server connection and update the connectionStatus property
    private func checkAndUpdateConnectionStatus() async {
        print("üîÑ Checking connection status...")
        do {
            // Try to connect to the server
            try await checkServerConnection()
            await MainActor.run {
                self.connectionStatus = .connected
                self.isConnected = true
                self.error = nil
                print("‚úÖ Connection successful")
            }
        } catch let error as StashAPIError {
            await MainActor.run {
                switch error {
                case .authenticationFailed:
                    print("üîí Authentication failed - check API key")
                    self.connectionStatus = .authenticationFailed
                case .connectionFailed(let reason):
                    print("‚ùå Connection failed: \(reason)")
                    self.connectionStatus = .disconnected
                case .invalidURL:
                    print("‚ùå Invalid server URL configured")
                    self.connectionStatus = .failed(error)
                default:
                    print("‚ùå Connection error: \(error.localizedDescription)")
                    self.connectionStatus = .failed(error)
                }
                self.error = error
                self.isConnected = false
            }

            // Try to determine if server is reachable without authentication
            do {
                guard let url = URL(string: serverAddress) else {
                    return
                }

                var request = URLRequest(url: url)
                request.timeoutInterval = 5

                let (_, response) = try await URLSession.shared.data(for: request)

                if let httpResponse = response as? HTTPURLResponse {
                    print("üì° Basic server check response: \(httpResponse.statusCode)")

                    await MainActor.run {
                        if (200...299).contains(httpResponse.statusCode) {
                            // Server is reachable but we had auth issues
                            if self.connectionStatus != .authenticationFailed {
                                self.connectionStatus = .authenticationFailed
                            }
                        } else if (500...599).contains(httpResponse.statusCode) {
                            self.connectionStatus = .failed(StashAPIError.serverError(httpResponse.statusCode))
                        }
                    }
                }
            } catch {
                print("‚ùå Server completely unreachable: \(error.localizedDescription)")
                await MainActor.run {
                    self.connectionStatus = .disconnected
                }
            }
        } catch {
            print("‚ùå Unexpected error during connection check: \(error.localizedDescription)")
            await MainActor.run {
                self.connectionStatus = .failed(error)
                self.error = error
                self.isConnected = false
            }
        }
    }

    // Helper method to retry connection
    func retryConnection() async {
        print("üîÑ Retrying connection...")
        await checkAndUpdateConnectionStatus()
    }

    // Helper to get a user-friendly connection status message
    var connectionStatusMessage: String {
        switch connectionStatus {
        case .connected:
            return "Connected to server"
        case .disconnected:
            return "Unable to connect to server"
        case .authenticationFailed:
            return "Authentication failed - check API key"
        case .unknown:
            return "Checking connection..."
        case .failed(let error):
            if let stashError = error as? StashAPIError {
                return stashError.localizedDescription
            } else {
                return "Connection failed: \(error.localizedDescription)"
            }
        }
    }
    
    // MARK: - Authentication Methods
    private func configureRequestWithAuth(_ request: inout URLRequest, referer: String? = nil) {
        // Updated to use BOTH authentication methods
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        // IMPORTANT: Using BOTH auth methods for maximum compatibility
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        if let referer = referer {
            request.setValue(referer, forHTTPHeaderField: "Referer")
        }
        request.timeoutInterval = 30.0
    }

    // MARK: - Modern Async/Await GraphQL Methods

    /// Public method to execute GraphQL queries directly with async/await
    func executeGraphQLQueryAsync(_ query: String) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = query.data(using: .utf8)

        let (data, response) = try await URLSession.shared.data(for: request)

        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
            throw StashAPIError.serverError(httpResponse.statusCode)
        }

        return data
    }

    /// Performs a GraphQL request using async/await
    private func performGraphQLRequest<T: Decodable>(query: String, variables: [String: Any]? = nil) async throws -> T {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        // Create the request body
        var requestBody: [String: Any] = [
            "query": query
        ]
        if let variables = variables {
            requestBody["variables"] = variables
        }

        // Convert request body to JSON data
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        // Create and configure the request with both authentication methods
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = jsonData

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                print("üì° GraphQL Response Status: \(httpResponse.statusCode)")

                // Show response preview for debugging
                if let responseStr = String(data: data, encoding: .utf8)?.prefix(100) {
                    print("üì• Response preview: \(responseStr)...")
                }

                if httpResponse.statusCode == 401 {
                    throw StashAPIError.authenticationFailed
                }

                if !(200...299).contains(httpResponse.statusCode) {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            print("‚ùå GraphQL Error: \(error)")
            throw error
        }
    }

    // Add a version of performGraphQLRequest that returns raw Data
    private func performGraphQLRequest(query: String, variables: [String: Any]? = nil) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        // Create the request body
        var requestBody: [String: Any] = [
            "query": query
        ]
        if let variables = variables {
            requestBody["variables"] = variables
        }

        // Convert request body to JSON data
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        // Create and configure the request with both auth methods
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = jsonData

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                print("üì° GraphQL Response Status: \(httpResponse.statusCode)")

                // Show response preview for debugging
                if let responseStr = String(data: data, encoding: .utf8)?.prefix(100) {
                    print("üì• Response preview: \(responseStr)...")
                }

                if httpResponse.statusCode == 401 {
                    throw StashAPIError.authenticationFailed
                }

                if !(200...299).contains(httpResponse.statusCode) {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            return data
        } catch {
            print("‚ùå GraphQL Error: \(error)")
            throw error
        }
    }

    // Public method to execute GraphQL queries directly
    public func executeGraphQLQuery(_ query: String) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.graphQLError("Invalid URL")
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        // IMPORTANT: Using BOTH authentication methods
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = query.data(using: .utf8)

        print("üì§ Executing GraphQL query with BOTH ApiKey and Bearer auth headers")
        let (data, response) = try await URLSession.shared.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("üì• HTTP response: \(httpResponse.statusCode)")

            // Show response preview for debugging
            if let responseStr = String(data: data, encoding: .utf8)?.prefix(100) {
                print("üì• Response preview: \(responseStr)...")
            }

            if !(200...299).contains(httpResponse.statusCode) {
                print("‚ùå Error status: \(httpResponse.statusCode)")
                throw StashAPIError.serverError(httpResponse.statusCode)
            }
        }

        return data
    }
    
    // MARK: - Scenes Methods
    
    /// Fetch a specific scene by its ID
    /// - Parameter id: The scene ID to fetch
    /// - Returns: The scene if found, nil otherwise
    func fetchScene(byID id: String) async throws -> StashScene? {
        let query = """
        query FindScene($id: ID!) {
            findScene(id: $id) {
                id
                title
                details
                url
                date
                rating100
                organized
                o_counter
                paths {
                    screenshot
                    preview
                    stream
                    webp
                    vtt
                    sprite
                    funscript
                    interactive_heatmap
                }
                files {
                    size
                    duration
                    video_codec
                    width
                    height
                }
                performers {
                    id
                    name
                    gender
                    image_path
                }
                tags {
                    id
                    name
                }
                studio {
                    id
                    name
                }
                stash_ids {
                    endpoint
                    stash_id
                }
                created_at
                updated_at
            }
        }
        """
        
        let variables = ["id": id]
        
        do {
            let response: GraphQLResponse<SceneResponse> = try await performGraphQLRequest(query: query, variables: variables)
            if let errors = response.errors, !errors.isEmpty {
                print("‚ùå GraphQL Errors: \(errors)")
                throw StashAPIError.graphQLError(errors.map { $0.message }.joined(separator: ", "))
            }
            return response.data.findScene
        } catch {
            print("‚ùå Error fetching scene: \(error)")
            throw error
        }
    }
    
    /// Get available sprite image URL (for thumbnails in the video scrubber)
    func getSpriteURLForScene(sceneID: String) -> URL? {
        // Use the static helper method to avoid duplicate code
        return VideoPlayerUtility.getSpriteURL(forSceneID: sceneID)
    }
    
    /// Get VTT file URL for a scene (for video chapters/thumbnails)
    func getVTTURLForScene(sceneID: String) -> URL? {
        // Use the static helper method to avoid duplicate code
        return VideoPlayerUtility.getVTTURL(forSceneID: sceneID)
    }
    func fetchScenes(page: Int = 1, sort: String = "file_mod_time", direction: String = "DESC", appendResults: Bool = false, filterOptions: FilterOptions? = nil) async {
        do {
            // Generate random seed for random sorting
            let randomSeed = Int.random(in: 0...999999)
            let sortField = sort == "random" ? "random_\(randomSeed)" : sort
            
            // Prepare variables
            var queryVars: [String: Any] = [
                "filter": [
                    "page": page,
                    "per_page": 100,
                    "sort": sortField,
                    "direction": direction
                ]
            ]
            
            // Create scene filter
            var sceneFilter: [String: Any] = [:]

            // Refine the approach to tag exclusion - the error suggests there's an issue with the tag filtering
            // Instead of doing tag filtering here, we'll do it in memory after fetching the scenes
            // This is a workaround for the SQL error we're seeing with the EXCLUDES modifier

            // Add additional filters if provided
            if let filterOptions = filterOptions {
                let additionalFilters = filterOptions.generateSceneFilter()
                for (key, value) in additionalFilters {
                    // Don't overwrite the tags filter with INCLUDES modifier
                    if key != "tags" {
                        sceneFilter[key] = value
                    } else if let tagsFilter = value as? [String: Any],
                              let modifier = tagsFilter["modifier"] as? String,
                              modifier == "EXCLUDES" {
                        // If it's also an EXCLUDES filter, merge the values
                        if var existingTagsFilter = sceneFilter["tags"] as? [String: Any],
                           let existingValues = existingTagsFilter["value"] as? [String],
                           let newValues = tagsFilter["value"] as? [String] {
                            var combinedValues = existingValues
                            for newValue in newValues {
                                if !combinedValues.contains(newValue) {
                                    combinedValues.append(newValue)
                                }
                            }
                            existingTagsFilter["value"] = combinedValues
                            sceneFilter["tags"] = existingTagsFilter
                        }
                    }
                }
            }

            // Add scene filter to query variables
            if !sceneFilter.isEmpty {
                queryVars["scene_filter"] = sceneFilter
            }
            
            // Prepare GraphQL query
            let graphQLRequest: [String: Any] = [
                "operationName": "FindScenes",
                "variables": queryVars,
                "query": """
                query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) {
                    findScenes(filter: $filter, scene_filter: $scene_filter) {
                        count
                        scenes {
                            id
                            title
                            details
                            url
                            date
                            rating100
                            organized
                            o_counter
                            paths {
                                screenshot
                                preview
                                stream
                                webp
                                vtt
                                sprite
                                funscript
                                interactive_heatmap
                            }
                            files {
                                size
                                duration
                                video_codec
                                width
                                height
                            }
                            performers {
                                id
                                name
                                gender
                                image_path
                                scene_count
                            }
                            tags {
                                id
                                name
                            }
                            studio {
                                id
                                name
                            }
                            stash_ids {
                                endpoint
                                stash_id
                            }
                            created_at
                            updated_at
                        }
                    }
                }
                """
            ]
            
            // Convert to JSON data
            let jsonData = try JSONSerialization.data(withJSONObject: graphQLRequest)
            
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            configureRequestWithAuth(&request)
            request.httpBody = jsonData

            print("üì§ Fetching scenes page \(page) (sort: \(sort), direction: \(direction))")
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            // Check for task cancellation
            if Task.isCancelled {
                print("‚ö†Ô∏è Scene fetch task was cancelled")
                throw StashAPIError.taskCancelled
            }
            
            // Log HTTP response code for debugging
            if let httpResponse = response as? HTTPURLResponse {
                print("üì• HTTP response: \(httpResponse.statusCode)")
                
                // Check for server errors
                if httpResponse.statusCode >= 400 {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }
            
            // Debug output for investigating the issue
            print("üì• Response data length: \(data.count) bytes")
            if let jsonStr = String(data: data, encoding: .utf8) {
                print("üì• First 500 characters of response: \(jsonStr.prefix(500))")
            }

            // Try to decode first as ScenesResponse (direct wrapper)
            do {
                let decoder = JSONDecoder()
                let scenesResponse = try decoder.decode(ScenesResponse.self, from: data)

                // Update our data on the main thread
                await MainActor.run {
                    // Update total count
                    self.totalSceneCount = scenesResponse.data.findScenes.count

                    // Update scenes array
                    if appendResults {
                        // Filter out duplicates before appending
                        let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                            !self.scenes.contains { $0.id == newScene.id }
                        }
                        self.scenes.append(contentsOf: newScenes)
                        print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                    } else {
                        // Filter out VR scenes in memory
                        let allScenes = scenesResponse.data.findScenes.scenes
                        self.scenes = allScenes.filter { scene in
                            // Filter out scenes with VR tag
                            !scene.tags.contains { tag in
                                tag.name.lowercased() == "vr"
                            }
                        }
                        print("‚úÖ Loaded \(self.scenes.count) scenes (filtered from \(allScenes.count) total)")
                    }

                    // Update loading state
                    self.isLoading = false
                    self.error = nil
                }
            } catch let error as DecodingError {
                // If ScenesResponse direct decoding fails, try with GraphQLResponse wrapper
                print("üì¶ Direct decoding failed, trying with GraphQLResponse wrapper: \(error.localizedDescription)")

                // Try to decode with GraphQLResponse wrapper
                let scenesResponse = try JSONDecoder().decode(GraphQLResponse<ScenesResponseData>.self, from: data)

                // Check for GraphQL errors
                if let errors = scenesResponse.errors, !errors.isEmpty {
                    let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                    throw StashAPIError.graphQLError(errorMessages)
                }

                // Update our data on the main thread
                await MainActor.run {
                    // Update total count
                    self.totalSceneCount = scenesResponse.data.findScenes.count

                    // Update scenes array
                    if appendResults {
                        // Filter out duplicates before appending
                        let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                            !self.scenes.contains { $0.id == newScene.id }
                        }
                        self.scenes.append(contentsOf: newScenes)
                        print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                    } else {
                        // Filter out VR scenes in memory
                        let allScenes = scenesResponse.data.findScenes.scenes
                        self.scenes = allScenes.filter { scene in
                            // Filter out scenes with VR tag
                            !scene.tags.contains { tag in
                                tag.name.lowercased() == "vr"
                            }
                        }
                        print("‚úÖ Loaded \(self.scenes.count) scenes (filtered from \(allScenes.count) total)")
                    }
                    // Update loading state and error
                    self.isLoading = false
                    self.error = nil
                }
            }
        } catch {
            // Only update UI state if task wasn't cancelled
            if !Task.isCancelled {
                // Detailed error logging to help diagnose issues
                print("‚ùå Error fetching scenes: \(error.localizedDescription)")

                if let decodingError = error as? DecodingError {
                    switch decodingError {
                    case .keyNotFound(let key, let context):
                        print("‚ùå JSON key not found: \(key.stringValue), context: \(context.debugDescription)")
                    case .typeMismatch(let type, let context):
                        print("‚ùå JSON type mismatch: expected \(type), context: \(context.debugDescription)")
                    case .valueNotFound(let type, let context):
                        print("‚ùå JSON value not found: \(type), context: \(context.debugDescription)")
                    case .dataCorrupted(let context):
                        print("‚ùå JSON data corrupted: \(context.debugDescription)")
                    @unknown default:
                        print("‚ùå Unknown JSON decoding error")
                    }
                }

                await MainActor.run {
                    self.error = error
                    self.isLoading = false

                    // Try to recover by loading with a fallback method
                    Task {
                        // Try a direct GraphQL query without the complex response structure
                        print("üîÑ Attempting fallback scene loading...")
                        await tryFallbackSceneLoading(page: page, sort: sort, direction: direction)
                    }
                }
            }
        }
    }

    // MARK: - Fallback Scene Loading

    /// Fallback method for loading scenes when the standard fetching fails
    private func tryFallbackSceneLoading(page: Int, sort: String, direction: String) async {
        do {
            // Simpler query structure using GraphQL query
            let randomSeed = Int.random(in: 0...999999)
            let sortField = sort == "random" ? "random_\(randomSeed)" : sort

            // Create a simpler query with minimal fields to test the API
            // Also include tags for VR filtering
            let query = """
            {
                "query": "{ findScenes(filter: {page: \(page), per_page: 40, sort: \\"date\\", direction: \\"DESC\\"}) { count scenes { id title paths { screenshot stream } tags { id name } } } }"
            }
            """

            let data = try await performGraphQLRequest(query: query)

            struct SimpleScenesResponse: Decodable {
                struct Data: Decodable {
                    struct FindScenes: Decodable {
                        let count: Int
                        let scenes: [SimpleScene]

                        struct SimpleScene: Decodable {
                            let id: String
                            let title: String?
                            let paths: ScenePaths
                            let tags: [SimpleTag]

                            struct SimpleTag: Decodable {
                                let id: String
                                let name: String
                            }

                            struct ScenePaths: Decodable {
                                let screenshot: String
                                let stream: String
                            }
                        }
                    }
                    let findScenes: FindScenes
                }
                let data: Data
            }

            // Try to decode the simpler response
            if let jsonStr = String(data: data, encoding: .utf8) {
                print("üîç Fallback response: \(jsonStr.prefix(200))...")
            }

            let simpleResponse = try JSONDecoder().decode(SimpleScenesResponse.self, from: data)

            // If successful, convert simple scenes to full scenes with minimal data
            // Also filter out VR content
            let allSimpleScenes = simpleResponse.data.findScenes.scenes

            let filteredSimpleScenes = allSimpleScenes.filter { scene in
                // Filter out scenes with VR tag
                !scene.tags.contains { tag in
                    tag.name.lowercased() == "vr"
                }
            }

            print("üîç Fallback filtered out \(allSimpleScenes.count - filteredSimpleScenes.count) VR scenes")

            let simpleScenes = filteredSimpleScenes.map { simpleScene -> StashScene in
                // Convert the simplified paths to the format used by StashScene
                let scenePaths = StashScene.ScenePaths(
                    screenshot: simpleScene.paths.screenshot,
                    preview: nil,
                    stream: simpleScene.paths.stream
                )

                // Create a new StashScene with the limited data we have
                return StashScene(
                    id: simpleScene.id,
                    title: simpleScene.title,
                    details: nil,
                    paths: scenePaths,
                    files: [],
                    performers: [],
                    tags: simpleScene.tags.map { StashScene.Tag(id: $0.id, name: $0.name) },
                    rating100: nil,
                    o_counter: nil
                )
            }

            // Update UI with the simple scenes
            await MainActor.run {
                self.scenes = simpleScenes
                self.totalSceneCount = simpleResponse.data.findScenes.count
                print("‚úÖ Loaded \(simpleScenes.count) scenes using fallback method")
                self.isLoading = false
                self.error = nil
            }
        } catch {
            print("‚ùå Fallback loading also failed: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Execute GraphQL Query Methods

    // Add the missing executeGraphQLQuery method with generic type and completion handler
    func executeGraphQLQuery<T: Decodable>(_ query: String, variables: [String: Any]? = nil, completion: @escaping (Result<T, Error>) -> Void) {
        Task {
            do {
                let response: T = try await performGraphQLRequest(query: query, variables: variables)
                DispatchQueue.main.async {
                    completion(.success(response))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }

    // Add overload that takes named parameters for better clarity
    func executeGraphQLQuery<T: Decodable>(query: String, variables: [String: Any]? = nil, completion: @escaping (Result<T, Error>) -> Void) {
        Task {
            do {
                let response: T = try await performGraphQLRequest(query: query, variables: variables)
                DispatchQueue.main.async {
                    completion(.success(response))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }
    
    // MARK: - Performer Scenes Method
    func fetchPerformerScenes(performerId: String, page: Int = 1, perPage: Int = 100, sort: String = "date", direction: String = "DESC", appendResults: Bool = false) async {
        isLoading = true

        // Using proper JSON format like Vision Pro implementation
        let query = """
        {
            "operationName": "FindScenes",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": \(perPage),
                    "sort": "\(sort)",
                    "direction": "\(direction)"
                },
                "scene_filter": {
                    "performers": {
                        "modifier": "INCLUDES",
                        "value": ["\(performerId)"]
                    },
                    "tags": {
                        "modifier": "EXCLUDES",
                        "value": ["vr"]
                    }
                }
            },
            "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender image_path scene_count } tags { id name } studio { id name } rating100 stash_ids { endpoint stash_id } created_at updated_at } } }"
        }
        """

        print("üîç Fetching performer scenes (ID: \(performerId), page: \(page), sort: \(sort), direction: \(direction))")

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for performer scenes")
            isLoading = false
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("\(serverAddress)/performers/\(performerId)/scenes?sortby=date", forHTTPHeaderField: "Referer")
        request.httpBody = query.data(using: .utf8)

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            // Check for task cancellation
            if Task.isCancelled {
                print("‚ö†Ô∏è Performer scenes fetch task was cancelled")
                throw StashAPIError.taskCancelled
            }

            // Log HTTP response code for debugging
            if let httpResponse = response as? HTTPURLResponse {
                print("üì• HTTP response: \(httpResponse.statusCode)")

                // Show response preview for troubleshooting
                if let jsonStr = String(data: data, encoding: .utf8) {
                    print("üì• Response preview: \(jsonStr.prefix(200))...")
                }

                // Check for server errors
                if httpResponse.statusCode >= 400 {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            // Define response structure matching exactly the API format
            struct SceneResponse: Decodable {
                struct Data: Decodable {
                    let findScenes: FindScenesResult

                    struct FindScenesResult: Decodable {
                        let count: Int
                        let scenes: [StashScene]
                    }
                }
                let data: Data
                let errors: [GraphQLError]?
            }

            // Decode the response
            let scenesResponse = try JSONDecoder().decode(SceneResponse.self, from: data)

            // Check for GraphQL errors
            if let errors = scenesResponse.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            // Update our data on the main thread
            await MainActor.run {
                // Update total count
                self.totalSceneCount = scenesResponse.data.findScenes.count

                // Update scenes array
                if appendResults {
                    // Filter out duplicates before appending
                    let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                        !self.scenes.contains { $0.id == newScene.id }
                    }
                    self.scenes.append(contentsOf: newScenes)
                    print("‚úÖ Added \(newScenes.count) new performer scenes (total: \(self.scenes.count))")
                } else {
                    // Filter out VR scenes in memory
                    let allScenes = scenesResponse.data.findScenes.scenes
                    self.scenes = allScenes.filter { scene in
                        // Filter out scenes with VR tag
                        !scene.tags.contains { tag in
                            tag.name.lowercased() == "vr"
                        }
                    }
                    print("‚úÖ Loaded \(self.scenes.count) performer scenes (filtered from \(allScenes.count) total)")

                    // Update loading state
                    self.isLoading = false
                    self.error = nil
                }
            }
        } catch {
            // Only update UI state if task wasn't cancelled
            if !Task.isCancelled {
                await MainActor.run {
                    print("‚ùå Error fetching performer scenes: \(error.localizedDescription)")
                    // Try to get more detailed error info
                    if let decodingError = error as? DecodingError {
                        switch decodingError {
                        case .keyNotFound(let key, let context):
                            print("Missing key: \(key) - \(context.debugDescription)")
                        case .typeMismatch(let type, let context):
                            print("Type mismatch: \(type) - \(context.debugDescription)")
                        case .valueNotFound(let type, let context):
                            print("Value not found: \(type) - \(context.debugDescription)")
                        case .dataCorrupted(let context):
                            print("Data corrupted: \(context.debugDescription)")
                        @unknown default:
                            print("Unknown decoding error")
                        }
                    }
                    self.error = error
                    self.isLoading = false
                }
            }
        }
    }

    // MARK: - System Methods

    // Method to get system status with completion handler
    func getSystemStatus(completion: @escaping (Result<SystemStatus, Error>) -> Void) {
        let query = """
        query SystemStatus {
          systemStatus {
            databaseSchema
            databasePath
            configPath
            appSchema
            status
            appName
            appVersion
            logFile
            maxSessionAge
          }
        }
        """

        struct SystemStatusResponse: Decodable {
            let systemStatus: SystemStatus
        }

        // Added named parameter to fix trailing closure issue
        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<SystemStatusResponse, Error>) in
            switch result {
            case .success(let response):
                self.systemStatus = response.systemStatus
                self.isConnected = true
                completion(.success(response.systemStatus))
            case .failure(let error):
                self.isConnected = false
                completion(.failure(error))
            }
        })
    }

    /// Checks if the Stash server is reachable and if the API key is valid
    func checkServerConnection() async throws {
        print("üîÑ Checking server connection to \(serverAddress)")

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid server URL")
            throw StashAPIError.invalidURL
        }

        // Create a simple query to check server status
        let query = """
        {
            "operationName": "FindPerformers",
            "variables": {
                "filter": {
                    "page": 1,
                    "per_page": 1,
                    "sort": "name",
                    "direction": "ASC"
                }
            },
            "query": "query FindPerformers($filter: FindFilterType) { findPerformers(filter: $filter) { count performers { id name } } }"
        }
        """

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Add both authentication methods to ensure compatibility
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        request.httpBody = query.data(using: .utf8)

        do {
            print("üì§ Sending connection check request...")
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ùå Invalid response type")
                throw StashAPIError.invalidResponse
            }

            print("üì° Server responded with status code: \(httpResponse.statusCode)")

            switch httpResponse.statusCode {
            case 200:
                guard !data.isEmpty else {
                    print("‚ùå Empty response data")
                    throw StashAPIError.emptyResponse
                }

                // Try to decode the response
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("üì• Response: \(jsonString.prefix(200))...")
                }

                do {
                    let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]

                    // Check if we got a data field
                    guard let dataField = json?["data"] as? [String: Any] else {
                        print("‚ùå Response missing data field")
                        throw StashAPIError.invalidData("Response missing data field")
                    }

                    // Check if we have performers data
                    guard let findPerformers = dataField["findPerformers"] as? [String: Any] else {
                        print("‚ùå Response missing performers data")
                        throw StashAPIError.invalidData("Response missing performers data")
                    }

                    print("‚úÖ Server connection successful")
                    print("üìä Performers data: \(findPerformers)")

                } catch {
                    print("‚ùå Failed to parse response: \(error)")
                    throw StashAPIError.decodingError(error)
                }

            case 401, 403:
                print("üîí Authentication failed")
                throw StashAPIError.authenticationFailed

            case 404:
                print("‚ùå Server endpoint not found")
                throw StashAPIError.connectionFailed("Server endpoint not found")

            case 500...599:
                print("‚ùå Server error: \(httpResponse.statusCode)")
                throw StashAPIError.serverError(httpResponse.statusCode)

            default:
                print("‚ùå Unexpected status code: \(httpResponse.statusCode)")
                throw StashAPIError.invalidResponse
            }

        } catch let error as StashAPIError {
            print("‚ùå StashAPI Error: \(error.localizedDescription)")
            throw error
        } catch {
            print("‚ùå Network Error: \(error.localizedDescription)")
            throw StashAPIError.networkError(error)
        }
    }

    /// Fetches statistics from Stash server
    func fetchStats() async throws -> StashStats {
        do {
            let query = """
            query {
              stats {
                scene_count
                scenes_size
                scene_duration
                image_count
                images_size
                gallery_count
                performer_count
                studio_count
                movie_count
                tag_count
              }
            }
            """

            let response: GraphQLResponse<StatsDataResponse> = try await performGraphQLRequest(query: query)

            // Check for errors in the response
            if let errors = response.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            DispatchQueue.main.async {
                self.connectionStatus = .connected
            }

            return response.data.stats
        } catch {
            DispatchQueue.main.async {
                self.connectionStatus = .failed(error)
            }

            NSLog("Error fetching stats: \(error)")
            throw error
        }
    }

    // MARK: - Random Scene/Performer Methods

    func fetchRandomScene(completion: @escaping (Result<StashScene, Error>) -> Void) {
        let query = """
        query FindRandomScene {
          findRandomScene {
            id
            title
            details
            url
            date
            rating100
            o_counter
            organized
            interactive
            files {
              id
              path
              size
              duration
              video_codec
              audio_codec
              width
              height
              frame_rate
              bit_rate
            }
            paths {
              screenshot
              preview
              stream
              webp
              vtt
              chapters_vtt
              sprite
              funscript
            }
            scene_markers {
              id
              scene {
                id
              }
              title
              seconds
              primary_tag {
                id
                name
              }
              tags {
                id
                name
              }
              stream
              preview
              screenshot
            }
            galleries {
              id
              title
              files {
                path
              }
              folder {
                path
              }
            }
            studio {
              id
              name
              image_path
            }
            movies {
              movie {
                id
                name
                front_image_path
              }
              scene_index
            }
            tags {
              id
              name
            }
            performers {
              id
              name
              gender
              favorite
              image_path
            }
            stash_ids {
              endpoint
              stash_id
            }
          }
        }
        """

        struct SceneResponse: Decodable {
            let findRandomScene: StashScene
        }

        // Added named parameter to fix trailing closure issue
        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<SceneResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findRandomScene))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    func fetchRandomPerformer(completion: @escaping (Result<StashScene.Performer, Error>) -> Void) {
        let query = """
        query FindRandomPerformer {
          findRandomPerformer {
            id
            name
            gender
            url
            twitter
            instagram
            birthdate
            death_date
            ethnicity
            country
            eye_color
            height_cm
            measurements
            fake_tits
            penis_length
            circumcised
            hair_color
            weight
            created_at
            updated_at
            favorite
            ignore_auto_tag
            image_path
            scene_count
            image_count
            gallery_count
            movie_count
            tags {
              id
              name
            }
            stash_ids {
              stash_id
              endpoint
            }
            rating100
            details
            aliases
          }
        }
        """

        struct PerformerResponse: Decodable {
            let findRandomPerformer: StashScene.Performer
        }

        // Added named parameter to fix trailing closure issue
        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<PerformerResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findRandomPerformer))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // MARK: - Tag Methods
    
    /// Fetch all tags from the server
    /// - Returns: Array of tags
    func fetchTags() async throws -> [StashScene.Tag] {
        isLoading = true
        defer { isLoading = false }
        
        let graphQLQuery = """
        {
            "operationName": "FindTags",
            "variables": {
                "filter": {
                    "per_page": 1000,
                    "sort": "name",
                    "direction": "ASC"
                }
            },
            "query": "query FindTags($filter: FindFilterType) { findTags(filter: $filter) { count tags { id name scene_count } } }"
        }
        """
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.httpBody = graphQLQuery.data(using: .utf8)
        
        let (data, _) = try await URLSession.shared.data(for: request)
        
        struct TagsResponse: Decodable {
            let data: TagData
            
            struct TagData: Decodable {
                let findTags: TagResults
                
                struct TagResults: Decodable {
                    let count: Int
                    let tags: [StashScene.Tag]
                }
            }
        }
        
        let response = try JSONDecoder().decode(TagsResponse.self, from: data)
        return response.data.findTags.tags
    }
    
    /// Create a new tag
    /// - Parameter name: Tag name
    /// - Returns: The created tag
    func createTag(name: String) async throws -> StashScene.Tag {
        let query = """
        mutation TagCreate($input: TagCreateInput!) {
            tagCreate(input: $input) {
                id
                name
                aliases
                image_path
                scene_count
            }
        }
        """

        let input: [String: Any] = [
            "name": name
        ]

        let variables: [String: Any] = ["input": input]

        struct TagCreateResponse: Decodable {
            let tagCreate: StashScene.Tag
        }

        let response: TagCreateResponse = try await performGraphQLRequest(query: query, variables: variables)
        return response.tagCreate
    }


    func findTags(filter: TagFilter? = nil, completion: @escaping (Result<[StashScene.Tag], Error>) -> Void) {
        let query = """
        query FindTags($filter: TagFilterType) {
          findTags(tag_filter: $filter) {
            count
            tags {
              id
              name
              aliases
              image_path
              scene_count
            }
          }
        }
        """

        var variables: [String: Any] = [:]
        if let filter = filter {
            variables["filter"] = filter.toDictionary()
        }

        struct TagsResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        executeGraphQLQuery(query: query, variables: variables, completion: { (result: Result<TagsResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findTags.tags))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    /// Fetches a specific tag by its ID
    /// - Parameters:
    ///   - id: The tag ID to fetch
    ///   - completion: Callback with result
    func findTag(id: String, completion: @escaping (Result<StashScene.Tag, Error>) -> Void) {
        let query = """
        query FindTag($id: ID!) {
          findTag(id: $id) {
            id
            name
            aliases
            image_path
            scene_count
          }
        }
        """

        let variables: [String: Any] = ["id": id]

        struct TagResponse: Decodable {
            let findTag: StashScene.Tag
        }

        executeGraphQLQuery(query: query, variables: variables, completion: { (result: Result<TagResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findTag))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // MARK: - Filtering Methods
    
    /// Fetch scenes using a filter preset
    /// - Parameters:
    ///   - preset: The filter preset to use
    ///   - page: Page number (1-based)
    ///   - perPage: Number of results per page
    ///   - appendResults: Whether to append to existing results
    func filterScenesByPreset(preset: FilterPreset, page: Int = 1, perPage: Int = 40, appendResults: Bool = false) async {
        isLoading = true
        
        // Get the GraphQL query for this preset
        let query = preset.getGraphQLQuery(page: page, perPage: perPage)
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for filter preset")
            isLoading = false
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            let scenesResponse = try JSONDecoder().decode(ScenesResponse.self, from: data)
            
            await MainActor.run {
                totalSceneCount = scenesResponse.data.findScenes.count
                
                if appendResults {
                    // Filter out duplicates before appending
                    let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                        !self.scenes.contains { $0.id == newScene.id }
                    }
                    self.scenes.append(contentsOf: newScenes)
                    print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                } else {
                    // Filter out VR scenes in memory
                    let allScenes = scenesResponse.data.findScenes.scenes
                    self.scenes = allScenes.filter { scene in
                        // Filter out scenes with VR tag
                        !scene.tags.contains { tag in
                            tag.name.lowercased() == "vr"
                        }
                    }
                    print("‚úÖ Loaded \(self.scenes.count) scenes for preset \(preset.rawValue) (filtered from \(allScenes.count) total)")
                }
                
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                print("‚ùå Error loading scenes for preset: \(error)")
                self.error = error
                self.isLoading = false
            }
        }
    }
    
    // Extension to send method for GraphQL queries when using async/await
    func send<T: Decodable>(query: String) async throws -> GraphQLResponse<T> {
        // Use the existing performGraphQLRequest method
        return try await performGraphQLRequest(query: query)
    }

    // MARK: - Scene Tag Methods
    
    /// Delete a scene by its ID (also deletes the file and generated assets)
    /// - Parameter id: The scene ID to delete
    /// - Throws: StashAPIError on failure
    func deleteScene(id: String) async throws -> Bool {
        isLoading = true
        defer { isLoading = false }
        
        // Build GraphQL mutation for ScenesDestroy
        let deleteFile = true
        let deleteGenerated = true
        let variables: [String: Any] = [
            "ids": [id],
            "delete_file": deleteFile,
            "delete_generated": deleteGenerated
        ]
        
        // Construct JSON body
        let payload: [String: Any] = [
            "operationName": "ScenesDestroy",
            "variables": variables,
            "query": "mutation ScenesDestroy($ids: [ID!]!, $delete_file: Boolean, $delete_generated: Boolean) { scenesDestroy(input: {ids: $ids, delete_file: $delete_file, delete_generated: $delete_generated}) }"
        ]
        
        let bodyData = try JSONSerialization.data(withJSONObject: payload, options: [])
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw URLError(.badURL)
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.httpBody = bodyData
        
        let (data, response) = try await URLSession.shared.data(for: request)
        if let http = response as? HTTPURLResponse, !(200...299).contains(http.statusCode) {
            throw StashAPIError.networkError(URLError(.badServerResponse))
        }
        
        // Decode GraphQL response
        struct ScenesDestroyResponse: Decodable {
            struct Data: Decodable {
                let scenesDestroy: Bool
            }
            let data: Data
            let errors: [GraphQLError]?
        }
        
        let resp = try JSONDecoder().decode(ScenesDestroyResponse.self, from: data)
        if let errors = resp.errors, !errors.isEmpty {
            let msgs = errors.map { $0.message }.joined(separator: "\n")
            throw StashAPIError.graphQLError(msgs)
        }
        
        return resp.data.scenesDestroy
    }

    func updateSceneTags(sceneID: String, tagIDs: [String]) async throws -> StashScene {
        let query = """
        mutation UpdateSceneTags($input: SceneUpdateInput!) {
            sceneUpdate(input: $input) {
                id
                title
                details
                url
                date
                rating100
                organized
                o_counter
                paths {
                    screenshot
                    preview
                    stream
                    webp
                    vtt
                    sprite
                    funscript
                    interactive_heatmap
                }
                files {
                    size
                    duration
                    video_codec
                    width
                    height
                }
                performers {
                    id
                    name
                    gender
                    image_path
                    scene_count
                }
                tags {
                    id
                    name
                }
                studio {
                    id
                    name
                }
                stash_ids {
                    endpoint
                    stash_id
                }
                created_at
                updated_at
            }
        }
        """

        let input: [String: Any] = [
            "id": sceneID,
            "tag_ids": tagIDs
        ]

        let variables: [String: Any] = ["input": input]

        struct SceneUpdateResponse: Decodable {
            let sceneUpdate: StashScene
        }

        let response: SceneUpdateResponse = try await performGraphQLRequest(query: query, variables: variables)
        return response.sceneUpdate
    }

    // Async version of searchTags
    func searchTags(query: String) async throws -> [StashScene.Tag] {
        let graphQLQuery = """
        query FindTags($filter: FindFilterType) {
          findTags(filter: $filter) {
            count
            tags {
              id
              name
              scene_count
              image_count
            }
          }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "per_page": 20,
                "sort": "name",
                "direction": "ASC"
            ]
        ]

        struct TagSearchAsyncResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        let response: TagSearchAsyncResponse = try await performGraphQLRequest(query: graphQLQuery, variables: variables)
        return response.findTags.tags
    }

    // MARK: - Additional Missing Methods

    func searchTags(query: String, completion: @escaping (Result<[StashScene.Tag], Error>) -> Void) {
        let graphQLQuery = """
        query FindTags($filter: FindFilterType) {
          findTags(filter: $filter) {
            count
            tags {
              id
              name
              scene_count
              image_count
            }
          }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "per_page": 10,
                "sort": "name",
                "direction": "ASC"
            ]
        ]

        struct TagSearchResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        executeGraphQLQuery(query: graphQLQuery, variables: variables, completion: { (result: Result<TagSearchResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findTags.tags))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // MARK: - DLNA Configuration
    
    /// Update DLNA settings in Stash
    /// - Parameter enabled: Whether DLNA should be enabled
    /// - Returns: The new state of DLNA (enabled/disabled)
    func updateDLNASettings(enabled: Bool) async throws -> Bool {
        let query = """
        mutation {
          configureDLNA(input: {
            enabled: \(enabled)
          }) {
            enabled
          }
        }
        """
        
        struct DLNAUpdateResponse: Decodable {
            struct Data: Decodable {
                struct ConfigureDLNA: Decodable {
                    let enabled: Bool
                }
                let configureDLNA: ConfigureDLNA
            }
            let data: Data
        }
        
        do {
            let data = try await performGraphQLRequest(query: query)
            let decoder = JSONDecoder()
            let response = try decoder.decode(DLNAUpdateResponse.self, from: data)
            return response.data.configureDLNA.enabled
        } catch {
            print("‚ùå Error updating DLNA settings: \(error)")
            throw error
        }
    }

    func fetchPerformers(filter: PerformerFilter = .all, page: Int = 1, appendResults: Bool = false, search: String = "", completion: @escaping (Result<[StashScene.Performer], Error>) -> Void) {
        isLoading = true

        let sceneCountValue: String
        switch filter {
        case .all:
            sceneCountValue = "0"
        case .lessThanTwo:
            sceneCountValue = "2"
        case .twoOrMore:
            sceneCountValue = "2"
        case .tenOrMore:
            sceneCountValue = "10"
        }

        let sceneCountModifier = filter == .lessThanTwo ? "LESS_THAN" : "GREATER_THAN"

        let escapedQuery = search.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\"")

        // Use full JSON-formatted query for females with >2 scenes and all results (no pagination)
        let query = """
        {
            "operationName": "FindPerformers",
            "variables": {
                "filter": {
                    "q": "\(escapedQuery)",
                    "page": 1,
                    "per_page": 10000,
                    "sort": "name",
                    "direction": "ASC"
                },
                "performer_filter": {
                    "gender": {
                        "value": "FEMALE",
                        "modifier": "EQUALS"
                    },
                    "scene_count": {
                        "modifier": "GREATER_THAN",
                        "value": "2"
                    }
                }
            },
            "query": "query FindPerformers($filter: FindFilterType, $performer_filter: PerformerFilterType) { findPerformers(filter: $filter, performer_filter: $performer_filter) { count performers { id name gender image_path scene_count favorite } } }"
        }
        """

        print("üì° Fetching performers with query: \(query)")

        Task {
            do {
                let data = try await executeGraphQLQuery(query)

                struct PerformersResponseData: Decodable {
                    struct Data: Decodable {
                        let findPerformers: FindPerformersResult
                    }

                    struct FindPerformersResult: Decodable {
                        let count: Int
                        let performers: [StashScene.Performer]
                    }

                    let data: Data
                }

                let decoder = JSONDecoder()
                do {
                    let response = try decoder.decode(PerformersResponseData.self, from: data)

                    await MainActor.run {
                        if appendResults {
                            // Filter out duplicates before appending
                            let newPerformers = response.data.findPerformers.performers.filter { newPerformer in
                                !self.performers.contains { $0.id == newPerformer.id }
                            }
                            self.performers.append(contentsOf: newPerformers)
                            self.totalPerformerCount = response.data.findPerformers.count
                            completion(.success(self.performers))
                        } else {
                            // Clear logging to understand what's happening
                            print("üìä PerformersAPI: Setting performers array with \(response.data.findPerformers.performers.count) performers")
                            self.performers = response.data.findPerformers.performers
                            self.totalPerformerCount = response.data.findPerformers.count
                            print("üìä PerformersAPI: After setting, self.performers has \(self.performers.count) items")
                            completion(.success(response.data.findPerformers.performers))
                        }
                        self.isLoading = false
                    }
                } catch {
                    print("‚ùå Error decoding performers: \(error)")
                    await MainActor.run {
                        self.isLoading = false
                        completion(.failure(error))
                    }
                }
            } catch {
                print("‚ùå Error loading performers: \(error)")
                await MainActor.run {
                    self.isLoading = false
                    completion(.failure(error))
                }
            }
        }
    }

    func searchScenes(query: String, completion: @escaping (Result<[StashScene], Error>) -> Void) {
        // Escape special characters in the search term
        let escaped = query
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")

        // Use filter.q for full-text search across scenes
        let graphQLQuery = """
        query FindScenes($filter: FindFilterType) {
            findScenes(filter: $filter) {
                count
                scenes {
                    id
                    title
                    details
                    url
                    date
                    rating100
                    organized
                    o_counter
                    paths {
                        screenshot
                        preview
                        stream
                    }
                    files {
                        size
                        duration
                        video_codec
                        width
                        height
                    }
                    performers {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                    studio {
                        id
                        name
                    }
                    stash_ids {
                        endpoint
                        stash_id
                    }
                    created_at
                    updated_at
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": escaped,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        executeGraphQLQuery(query: graphQLQuery, variables: variables, completion: { (result: Result<ScenesResponseData, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findScenes.scenes))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // Async version of searchScenes
    func searchScenes(query: String) async throws -> [StashScene] {
        // Escape special characters in the search term
        let escaped = query
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")

        // Use filter.q for full-text search across scenes
        let graphQLQuery = """
        query FindScenes($filter: FindFilterType) {
            findScenes(filter: $filter) {
                count
                scenes {
                    id
                    title
                    details
                    url
                    date
                    rating100
                    organized
                    o_counter
                    paths {
                        screenshot
                        preview
                        stream
                    }
                    files {
                        size
                        duration
                        video_codec
                        width
                        height
                    }
                    performers {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                    studio {
                        id
                        name
                    }
                    stash_ids {
                        endpoint
                        stash_id
                    }
                    created_at
                    updated_at
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": escaped,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        let response: ScenesResponseData = try await performGraphQLRequest(query: graphQLQuery, variables: variables)
        return response.findScenes.scenes
    }
    
    /// Find scenes with specified filters (tags, performers, etc.)
    /// - Parameters:
    ///   - filter: Scene filter options
    ///   - page: Page number
    ///   - perPage: Results per page
    /// - Returns: Tuple with scenes array and total count
    func findScenes(filter: SceneFilterType, page: Int = 1, perPage: Int = 20) async throws -> (scenes: [StashScene], count: Int) {
        // Create tag IDs filter if tags are provided
        var tagIDs: String? = nil
        if let tags = filter.tags, !tags.isEmpty {
            tagIDs = "[" + tags.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
            print("üè∑Ô∏è Including tags with IDs: \(tagIDs!)")
        }

        // Create excluded tag IDs filter - always exclude VR tag
        var excludedTagIDs = "[\"vr\"]"
        if let excludedTags = filter.excludedTags, !excludedTags.isEmpty {
            // Include additional excluded tags if present
            if !excludedTags.contains("vr") {
                excludedTagIDs = "[\"vr\", " + excludedTags.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
            } else {
                excludedTagIDs = "[" + excludedTags.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
            }
            print("üè∑Ô∏è Excluding tags with IDs/names: \(excludedTagIDs)")
        } else {
            print("üè∑Ô∏è Excluding VR tag by default")
        }

        // Create performer IDs filter if performers are provided
        var performerIDs: String? = nil
        if let performers = filter.performers, !performers.isEmpty {
            performerIDs = "[" + performers.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
        }

        // Create studio IDs filter if studios are provided
        var studioIDs: String? = nil
        if let studios = filter.studios, !studios.isEmpty {
            studioIDs = "[" + studios.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
        }
        
        let query = """
        {
          "operationName": "FindTaggedScenes",
          "variables": {
            "filter": {
              "page": \(page),
              "per_page": \(perPage)
              \(filter.searchTerm != nil ? ", \"q\": \"\(filter.searchTerm!)\"" : "")
            },
            "scene_filter": {
              \(tagIDs != nil ? "\"tags\": {\"value\": \(tagIDs!), \"modifier\": \"INCLUDES\"}," : "")
              "tags_v2": {
                "value": \(excludedTagIDs),
                "modifier": "EXCLUDES"
              }
              \(performerIDs != nil ? ", \"performers\": {\"value\": \(performerIDs!), \"modifier\": \"INCLUDES\"}" : "")
              \(studioIDs != nil ? ", \"studios\": {\"value\": \(studioIDs!), \"modifier\": \"INCLUDES\"}" : "")
              \(filter.minRating != nil ? ", \"rating100\": {\"value\": \(filter.minRating!), \"modifier\": \"GREATER_THAN\"}" : "")
              \(filter.favoritesOnly == true ? ", \"favorite\": {\"value\": true}" : "")
              \(filter.minDuration != nil ? ", \"duration\": {\"value\": \(filter.minDuration!), \"modifier\": \"GREATER_THAN\"}" : "")
              \(filter.maxDuration != nil ? ", \"duration\": {\"value\": \(filter.maxDuration!), \"modifier\": \"LESS_THAN\"}" : "")
            }
          },
          "query": "query FindTaggedScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details date rating100 o_counter paths { screenshot stream preview } tags { id name } performers { id name image_path } studio { id name } files { width height video_codec } } } }"
        }
        """
        
        struct FindScenesResponse: Decodable {
            struct Data: Decodable {
                struct FindScenes: Decodable {
                    let count: Int
                    let scenes: [StashScene]
                }
                let findScenes: FindScenes
            }
            let data: Data
        }
        
        do {
            print("üì§ Sending GraphQL query for tag filter: \(query)")
            let data = try await performGraphQLRequest(query: query)
            
            // Debug the response data
            if let jsonString = String(data: data, encoding: .utf8) {
                print("üì• Received GraphQL response: \(jsonString.prefix(500))...")
            }
            
            let decoder = JSONDecoder()
            do {
                let response = try decoder.decode(FindScenesResponse.self, from: data)
                print("‚úÖ Successfully decoded response with \(response.data.findScenes.scenes.count) scenes")
                return (scenes: response.data.findScenes.scenes, count: response.data.findScenes.count)
            } catch let decodingError {
                print("‚ùå Decoding error: \(decodingError)")
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("üì• Failed to decode: \(jsonString)")
                }
                throw decodingError
            }
        } catch {
            print("‚ùå Error fetching scenes: \(error)")
            throw error
        }
    }

    /// Fetch markers for a specific performer with completion handler
    /// - Parameters:
    ///   - performerId: The performer's ID
    ///   - page: Page number
    ///   - completion: Callback with result
    func fetchPerformerMarkers(performerId: String, page: Int = 1, completion: @escaping (Result<[SceneMarker], Error>) -> Void) {
        // Use Task to call the core implementation and return result via completion handler
        Task {
            do {
                let markers = try await fetchPerformerMarkersCore(performerId: performerId, page: page)
                DispatchQueue.main.async {
                    completion(.success(markers))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }

    /// Search for markers by query string with completion handler
    /// - Parameters:
    ///   - query: Search term
    ///   - completion: Callback with result
    func searchMarkers(query: String, completion: @escaping (Result<[SceneMarker], Error>) -> Void) {
        // Use Task to call the core implementation and return result via completion handler
        Task {
            do {
                let markers = try await searchMarkersCore(query: query)
                DispatchQueue.main.async {
                    completion(.success(markers))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }

    // Core implementation for searching markers
    private func searchMarkersCore(query: String) async throws -> [SceneMarker] {
        let graphQLQuery = """
        query FindSceneMarkers($filter: FindFilterType) {
            findSceneMarkers(filter: $filter) {
                count
                scene_markers {
                    id
                    title
                    seconds
                    stream
                    preview
                    screenshot
                    scene {
                        id
                        title
                        paths {
                            screenshot
                            preview
                            stream
                        }
                        performers {
                            id
                            name
                            image_path
                        }
                        studio {
                            id
                            name
                        }
                    }
                    primary_tag {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        struct SceneMarkersResponse: Decodable {
            let findSceneMarkers: SceneMarkersData

            struct SceneMarkersData: Decodable {
                let count: Int
                let scene_markers: [SceneMarker]
            }
        }

        // Use executeGraphQLQuery instead of performGraphQLRequest
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        let requestBody: [String: Any] = [
            "query": graphQLQuery,
            "variables": variables
        ]

        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        request.httpBody = jsonData

        let (data, _) = try await URLSession.shared.data(for: request)

        struct GraphQLResponse<T: Decodable>: Decodable {
            let data: T
            let errors: [GraphQLError]?
        }

        let response = try JSONDecoder().decode(GraphQLResponse<SceneMarkersResponse>.self, from: data)

        if let errors = response.errors, !errors.isEmpty {
            let errorMessages = errors.map { $0.message }.joined(separator: ", ")
            throw StashAPIError.graphQLError(errorMessages)
        }

        return response.data.findSceneMarkers.scene_markers
    }

    // Public async version of searchMarkers
    func searchMarkers(query: String) async throws -> [SceneMarker] {
        return try await searchMarkersCore(query: query)
    }

    /// Helper method that updates the internal markers array with search results
    /// - Parameter query: Search term
    func updateMarkersFromSearch(query: String) async {
        isLoading = true

        let graphQLQuery = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "q": "\(query)",
                    "page": 1,
                    "per_page": 40,
                    "sort": "title",
                    "direction": "ASC"
                },
                "scene_marker_filter": {}
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title paths { screenshot preview stream } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
        }
        """

        print("üîç Searching markers with query: '\(query)'")

        do {
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("*/*", forHTTPHeaderField: "Accept")
            request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
            request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
            request.setValue("keep-alive", forHTTPHeaderField: "Connection")
            request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.setValue(serverAddress, forHTTPHeaderField: "Origin")
            request.httpBody = graphQLQuery.data(using: .utf8)

            let (data, _) = try await URLSession.shared.data(for: request)

            struct SceneMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data
            }

            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)

            await MainActor.run {
                self.markers = response.data.findSceneMarkers.scene_markers
                print("‚úÖ Found \(response.data.findSceneMarkers.scene_markers.count) markers matching '\(query)'")
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                print("‚ùå Error searching markers: \(error)")
                self.markers = []
                self.error = error
                self.isLoading = false
            }
        }
    }

    func createSceneMarker(sceneId: String, title: String, seconds: Float, primaryTagId: String, tagIds: [String], completion: @escaping (Result<SceneMarker, Error>) -> Void) {
        let query = """
        mutation SceneMarkerCreate($input: SceneMarkerCreateInput!) {
            sceneMarkerCreate(input: $input) {
                id
                title
                seconds
                stream
                preview
                screenshot
                primary_tag {
                    id
                    name
                }
                tags {
                    id
                    name
                }
                scene {
                    id
                    title
                }
            }
        }
        """

        let input: [String: Any] = [
            "scene_id": sceneId,
            "title": title,
            "seconds": seconds,
            "primary_tag_id": primaryTagId,
            "tag_ids": tagIds
        ]

        let variables: [String: Any] = ["input": input]

        struct CreateMarkerResponse: Decodable {
            let sceneMarkerCreate: SceneMarker
        }

        executeGraphQLQuery(query: query, variables: variables, completion: { (result: Result<CreateMarkerResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.sceneMarkerCreate))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    func testConnection(completion: @escaping (Bool) -> Void) {
        let query = """
        query SystemStatus {
          systemStatus {
            status
          }
        }
        """

        struct SystemStatusResponse: Decodable {
            let systemStatus: SystemStatus
        }

        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<SystemStatusResponse, Error>) in
            switch result {
            case .success(_):
                completion(true)
            case .failure(_):
                completion(false)
            }
        })
    }

    // Helper method to encode dictionary to JSON string
    private func encodeJSON(_ dict: [String: Any]) -> String {
        guard let data = try? JSONSerialization.data(withJSONObject: dict) else {
            return "{}"
        }
        return String(data: data, encoding: .utf8) ?? "{}"
    }

    // Method for async/await calls and to support MarkersView
    func fetchMarkers(page: Int = 1, appendResults: Bool = false, performerId: String? = nil) async {
        isLoading = true
        
        // Generate a random seed for consistent random sorting
        let randomSeed = Int.random(in: 0...999999)
        
        let graphQLQuery = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 100,
                    "sort": "random_\(randomSeed)",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    \(performerId != nil ? "\"performers\": {\"value\": [\"\(performerId!)\"], \"modifier\": \"INCLUDES\"}" : "")
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { ...SceneMarkerData __typename } __typename } } fragment SceneMarkerData on SceneMarker { id title seconds end_seconds stream preview screenshot scene { ...SceneMarkerSceneData __typename } primary_tag { id name __typename } tags { id name __typename } __typename } fragment SceneMarkerSceneData on Scene { id title files { width height path __typename } performers { id name image_path __typename } __typename }"
        }
        """
        
        print("üîç Fetching markers (page \(page)) from \(serverAddress)")
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for markers")
            isLoading = false
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("u=3, i", forHTTPHeaderField: "Priority")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.setValue("\(serverAddress)/scenes/markers", forHTTPHeaderField: "Referer")
        request.httpBody = graphQLQuery.data(using: .utf8)
        
        // Add API Key header which wasn't in the original but might be needed according to documentation
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)

            // Debug: Print the response data
            if let jsonString = String(data: data, encoding: .utf8)?.prefix(500) {
                print("üîç Response data preview: \(jsonString)...")
            }

            // Define a structure that matches the JSON exactly
            struct GraphQLResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data
            }

            let response = try JSONDecoder().decode(GraphQLResponse.self, from: data)
            
            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let newMarkers = response.data.findSceneMarkers.scene_markers.filter { newMarker in
                        !self.markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: newMarkers)
                    print("‚úÖ Added \(newMarkers.count) new markers")

                    // Debug log for first marker
                    if let firstMarker = self.markers.first {
                        print("üìä First marker details:")
                        print("  ID: \(firstMarker.id)")
                        print("  Title: \(firstMarker.title)")
                        print("  Scene ID: \(firstMarker.scene.id)")
                    }
                } else {
                    self.markers = response.data.findSceneMarkers.scene_markers
                    print("‚úÖ Set \(response.data.findSceneMarkers.scene_markers.count) markers")

                    // Debug log for first marker
                    if let firstMarker = self.markers.first {
                        print("üìä First marker details:")
                        print("  ID: \(firstMarker.id)")
                        print("  Title: \(firstMarker.title)")
                        print("  Scene ID: \(firstMarker.scene.id)")
                    }
                }
                
                self.isLoading = false
            }
        } catch {
            print("‚ùå Error loading markers: \(error)")
            self.error = error
            isLoading = false
        }
    }// END NEW FETCHMARKERS
    func fetchMarkersByTag(tagId: String, page: Int = 1, appendResults: Bool = false) async {
        isLoading = true

        let query = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 40,
                    "sort": "title",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    "tags": {
                        "value": ["\(tagId)"],
                        "modifier": "INCLUDES"
                    }
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title paths { screenshot preview stream } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
        }
        """

        print("üîç Fetching markers for tag \(tagId) (page \(page))")

        do {
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("*/*", forHTTPHeaderField: "Accept")
            request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.setValue(serverAddress, forHTTPHeaderField: "Origin")
            request.httpBody = query.data(using: .utf8)

            let (data, _) = try await URLSession.shared.data(for: request)

            struct SceneMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data
            }

            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)

            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let newMarkers = response.data.findSceneMarkers.scene_markers.filter { newMarker in
                        !self.markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: newMarkers)
                    print("‚úÖ Added \(newMarkers.count) new markers for tag \(tagId)")
                } else {
                    self.markers = response.data.findSceneMarkers.scene_markers
                    print("‚úÖ Set \(response.data.findSceneMarkers.scene_markers.count) markers for tag \(tagId)")
                }

                self.isLoading = false
            }
        } catch {
            print("‚ùå Error loading markers by tag: \(error)")
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }

    // Core implementation for fetching performer markers
    private func fetchPerformerMarkersCore(performerId: String, page: Int = 1) async throws -> [SceneMarker] {
        print("üîçüîçüîç DEBUG: Fetching markers for performer ID: \(performerId), page: \(page)")

        // Generate random seed for random sorting
        let randomSeed = Int.random(in: 0...999999)

        // Build the proper GraphQL body with both filter and scene_marker_filter variables
        let graphQLBody: [String: Any] = [
            "operationName": "FindSceneMarkers",
            "variables": [
                "filter": [
                    "page": page, 
                    "per_page": 50, 
                    "sort": "random_\(randomSeed)", 
                    "direction": "ASC"
                ],
                "scene_marker_filter": [
                    "performers": [
                        "value": [performerId],
                        "modifier": "INCLUDES_ALL"
                    ]
                ]
            ],
            "query": """
            query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) {
              findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) {
                count
                scene_markers { 
                  id 
                  title 
                  seconds 
                  end_seconds
                  stream
                  preview
                  screenshot
                  scene {
                    id
                    title
                    performers {
                      id
                      name
                      image_path
                    }
                  }
                  primary_tag {
                    id
                    name
                  }
                  tags {
                    id
                    name
                  }
                }
              }
            }
            """
        ]
        
        // Let the JSON encoder handle serialization properly
        let jsonData = try JSONSerialization.data(withJSONObject: graphQLBody, options: [])
        let graphQLQuery = String(data: jsonData, encoding: .utf8) ?? "{}"
        
        // Log the complete request body to verify both filter and scene_marker_filter are included
        print("üîç DEBUG: Performer markers GraphQL request:")
        print("üìã FULL GraphQL body: \(graphQLQuery)")
        print("üìã performerId being used: \(performerId)")

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        
        // Follow the successful pattern from executeGraphQLQuery
        // Set ApiKey header without prefix
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        
        // Set Authorization header with Bearer prefix
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = graphQLQuery.data(using: .utf8)
        
        // Log the final JSON payload right before sending it to verify it's well-formed
        if let requestBody = String(data: request.httpBody ?? Data(), encoding: .utf8) {
            print("üì§ FINAL GraphQL request body:")
            print(requestBody)
            
            // Verify the performer ID is in the request
            if requestBody.contains(performerId) {
                print("‚úÖ Performer ID \(performerId) found in request")
            } else {
                print("‚ùå ERROR: Performer ID not found in request!")
            }
            
            // Verify the INCLUDES_ALL modifier is in the request
            if requestBody.contains("INCLUDES_ALL") {
                print("‚úÖ INCLUDES_ALL modifier found in request")
            } else {
                print("‚ùå ERROR: INCLUDES_ALL modifier not found in request!")
            }
            
            // Verify scene_marker_filter is in the request
            if requestBody.contains("scene_marker_filter") {
                print("‚úÖ scene_marker_filter found in request")
            } else {
                print("‚ùå ERROR: scene_marker_filter not found in request!")
            }
        }
        
        print("üîë Auth headers set with working pattern from executeGraphQLQuery")

        print("üì§ Fetching performer markers for ID: \(performerId), page: \(page)")
        let (data, response) = try await URLSession.shared.data(for: request)

        // Log HTTP response code for debugging
        if let httpResponse = response as? HTTPURLResponse {
            print("üì• HTTP response: \(httpResponse.statusCode)")

            // Show FULL response for troubleshooting
            if let jsonStr = String(data: data, encoding: .utf8) {
                print("üì• DEBUG: FULL Response for performer \(performerId):")
                print("\(jsonStr)")
                
                // Log more detailed error info for GraphQL errors
                if jsonStr.contains("errors") {
                    print("‚ùå GraphQL error detected in response")
                }
            }

            // Check for server errors
            if httpResponse.statusCode >= 400 {
                // For 401 specifically, provide more detailed debugging
                if httpResponse.statusCode == 401 {
                    print("üîê Authentication failure (401): Check API key configuration")
                    print("üîë API Key Length: \(apiKey.count) characters")
                    print("üîë API Key First 5 chars: \(apiKey.prefix(5))")
                    
                    // Check headers that were sent
                    print("üì§ Auth headers sent: ApiKey=\(request.value(forHTTPHeaderField: "ApiKey")?.prefix(5) ?? "nil"), Authorization=\(request.value(forHTTPHeaderField: "Authorization")?.prefix(12) ?? "nil")")
                }
                
                throw StashAPIError.serverError(httpResponse.statusCode)
            }
        }

        // Define response structure matching our updated API query format
        struct MarkerResponse: Decodable {
            struct Data: Decodable {
                let findSceneMarkers: FindSceneMarkersResult
                
                struct FindSceneMarkersResult: Decodable {
                    let count: Int
                    let scene_markers: [SceneMarker]
                }
            }
            let data: Data
            let errors: [GraphQLError]?
        }

        // Decode the response with more detailed error handling
        do {
            let response = try JSONDecoder().decode(MarkerResponse.self, from: data)

            // Check for GraphQL errors
            if let errors = response.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            // Get markers directly from response
            let markers = response.data.findSceneMarkers.scene_markers
            print("‚úÖ Found \(markers.count) markers for performer ID: \(performerId)")
            
            // Log first 3 markers IDs and titles to verify results
            if !markers.isEmpty {
                let displayCount = min(3, markers.count)
                for i in 0..<displayCount {
                    let marker = markers[i]
                    print("üéØ Marker \(i+1): ID=\(marker.id), Title=\(marker.title), Seconds=\(marker.seconds)")
                }
            }
            
            return markers
        } catch {
            print("‚ùå JSON decoding error: \(error)")

            // Try to identify structure issues
            if let decodingError = error as? DecodingError {
                switch decodingError {
                case .keyNotFound(let key, let context):
                    print("Missing key: \(key) - \(context.debugDescription)")
                case .typeMismatch(let type, let context):
                    print("Type mismatch: \(type) - \(context.debugDescription)")
                case .valueNotFound(let type, let context):
                    print("Value not found: \(type) - \(context.debugDescription)")
                case .dataCorrupted(let context):
                    print("Data corrupted: \(context.debugDescription)")
                @unknown default:
                    print("Unknown decoding error")
                }
            }

            throw error
        }
    }

    /// Public async method for fetching performer markers
    /// - Parameters:
    ///   - performerId: The performer ID
    ///   - page: Page number
    /// - Returns: Array of scene markers
    func fetchPerformerMarkers(performerId: String, page: Int = 1) async throws -> [SceneMarker] {
        return try await fetchPerformerMarkersCore(performerId: performerId, page: page)
    }

    /// Helper method that updates the internal markers array and handles state
    /// - Parameters:
    ///   - performerId: The performer ID
    ///   - page: Page number
    ///   - appendResults: Whether to append results or replace existing ones
    func fetchPerformerMarkers(performerId: String, page: Int = 1, appendResults: Bool = false) async {
        isLoading = true
        do {
            let newMarkers = try await fetchPerformerMarkersCore(performerId: performerId, page: page)
            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let uniqueNewMarkers = newMarkers.filter { newMarker in
                        !markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: uniqueNewMarkers)
                } else {
                    self.markers = newMarkers
                }
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                print("Error loading performer markers: \(error)")
                self.error = error
                self.isLoading = false
            }
        }
    }
}

// MARK: - Additional Data Models

// StashStats model for stats endpoint
struct StashStats: Codable {
    let scene_count: Int
    let scenes_size: Int64
    let scene_duration: Double
    let image_count: Int
    let images_size: Int64
    let gallery_count: Int
    let performer_count: Int
    let studio_count: Int
    let movie_count: Int
    let tag_count: Int
}

// Additional filter models
struct TagFilter {
    var name: String?
    var sceneCount: Int?

    func toDictionary() -> [String: Any] {
        var result: [String: Any] = [:]
        if let name = name {
            result["name"] = ["modifier": "INCLUDES", "value": name]
        }
        if let sceneCount = sceneCount {
            result["scene_count"] = ["modifier": "GREATER_THAN", "value": sceneCount]
        }
        return result
    }
}

================
File: stash/Networking/StashAPI.swift.bak2
================
import Foundation
import SwiftUI
import Combine

enum PerformerFilter {
    case all
    case lessThanTwo
    case twoOrMore
    case tenOrMore
}

struct ScenesResponseData: Decodable {
    let findScenes: FindScenesResult

    struct FindScenesResult: Decodable {
        let scenes: [StashScene]
        let count: Int
    }
}

struct GraphQLResponse<T: Decodable>: Decodable {
    let data: T
    let errors: [GraphQLError]?
}

struct GraphQLError: Decodable {
    let message: String
}

struct PerformersResponse: Decodable {
    let findPerformers: FindPerformersResult

    struct FindPerformersResult: Decodable {
        let count: Int
        let performers: [StashScene.Performer]
    }
}

struct ScenesResponse: Decodable {
    let data: ScenesData

    struct ScenesData: Decodable {
        let findScenes: FindScenesResult

        struct FindScenesResult: Decodable {
            let count: Int
            let scenes: [StashScene]
        }
    }
}

struct SceneResponse: Decodable {
    let findScene: StashScene
}

struct SystemStatus: Decodable {
    let databaseSchema: Int?
    let databasePath: String?
    let configPath: String?
    let appSchema: Int?
    let status: String?
    let appName: String?
    let appVersion: String?
    let logFile: String?
    let maxSessionAge: Int?
}

struct TagSearchResponse: Decodable {
    let data: TagData

    struct TagData: Decodable {
        let findTags: TagResults

        struct TagResults: Decodable {
            let count: Int
            let tags: [StashScene.Tag]
        }
    }
}

/// Stats data response from the Stash API
struct StatsDataResponse: Decodable {
    let stats: StashStats
}

class StashAPI: ObservableObject {
    // MARK: - Published Properties
    @Published var scenes: [StashScene] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var performers: [StashScene.Performer] = []
    @Published var markers: [SceneMarker] = []
    @Published var totalSceneCount: Int = 0
    @Published var totalPerformerCount: Int = 0
    @Published var connectionStatus: ConnectionStatus = .unknown
    @Published var sceneID: String?
    @Published var isAuthenticated = false
    @Published var isConnected = false
    @Published var systemStatus: SystemStatus?
    @Published var serverAddressPublic = ""
    @Published var preview: Bool = false

    // MARK: - Properties
    let serverAddress: String
    private var currentTask: Task<Void, Never>?
    private var cancellables = Set<AnyCancellable>()

    // API Authentication
    private let apiKey: String

    let decoder = JSONDecoder()
    let encoder = JSONEncoder()

    // MARK: - Connection Status
    enum ConnectionStatus: Equatable {
        case connected
        case disconnected
        case authenticationFailed
        case unknown
        case failed(Error)

        static func == (lhs: ConnectionStatus, rhs: ConnectionStatus) -> Bool {
            switch (lhs, rhs) {
            case (.connected, .connected),
                 (.disconnected, .disconnected),
                 (.authenticationFailed, .authenticationFailed),
                 (.unknown, .unknown):
                return true
            case (.failed(let lhsError), .failed(let rhsError)):
                return lhsError.localizedDescription == rhsError.localizedDescription
            default:
                return false
            }
        }
    }

    // MARK: - Initialization
    init(serverAddress: String, apiKey: String) {
        self.serverAddress = serverAddress
        self.apiKey = apiKey
        print("üîÑ StashAPI initializing with server: \(serverAddress)")
        print("üîë Using API key: \(apiKey.prefix(10))...")

        self.decoder.keyDecodingStrategy = .convertFromSnakeCase

        // Check if we have an API key
        if !apiKey.isEmpty {
            self.isAuthenticated = true
        }

        // Configure session
        URLSession.shared.configuration.timeoutIntervalForRequest = 30.0
        URLSession.shared.configuration.timeoutIntervalForResource = 60.0

        // Trigger a connection check asynchronously
        Task {
            await checkAndUpdateConnectionStatus()
        }
    }

    // Check server connection and update the connectionStatus property
    private func checkAndUpdateConnectionStatus() async {
        print("üîÑ Checking connection status...")
        do {
            // Try to connect to the server
            try await checkServerConnection()
            await MainActor.run {
                self.connectionStatus = .connected
                self.isConnected = true
                self.error = nil
                print("‚úÖ Connection successful")
            }
        } catch let error as StashAPIError {
            await MainActor.run {
                switch error {
                case .authenticationFailed:
                    print("üîí Authentication failed - check API key")
                    self.connectionStatus = .authenticationFailed
                case .connectionFailed(let reason):
                    print("‚ùå Connection failed: \(reason)")
                    self.connectionStatus = .disconnected
                case .invalidURL:
                    print("‚ùå Invalid server URL configured")
                    self.connectionStatus = .failed(error)
                default:
                    print("‚ùå Connection error: \(error.localizedDescription)")
                    self.connectionStatus = .failed(error)
                }
                self.error = error
                self.isConnected = false
            }

            // Try to determine if server is reachable without authentication
            do {
                guard let url = URL(string: serverAddress) else {
                    return
                }

                var request = URLRequest(url: url)
                request.timeoutInterval = 5

                let (_, response) = try await URLSession.shared.data(for: request)

                if let httpResponse = response as? HTTPURLResponse {
                    print("üì° Basic server check response: \(httpResponse.statusCode)")

                    await MainActor.run {
                        if (200...299).contains(httpResponse.statusCode) {
                            // Server is reachable but we had auth issues
                            if self.connectionStatus != .authenticationFailed {
                                self.connectionStatus = .authenticationFailed
                            }
                        } else if (500...599).contains(httpResponse.statusCode) {
                            self.connectionStatus = .failed(StashAPIError.serverError(httpResponse.statusCode))
                        }
                    }
                }
            } catch {
                print("‚ùå Server completely unreachable: \(error.localizedDescription)")
                await MainActor.run {
                    self.connectionStatus = .disconnected
                }
            }
        } catch {
            print("‚ùå Unexpected error during connection check: \(error.localizedDescription)")
            await MainActor.run {
                self.connectionStatus = .failed(error)
                self.error = error
                self.isConnected = false
            }
        }
    }

    // Helper method to retry connection
    func retryConnection() async {
        print("üîÑ Retrying connection...")
        await checkAndUpdateConnectionStatus()
    }

    // Helper to get a user-friendly connection status message
    var connectionStatusMessage: String {
        switch connectionStatus {
        case .connected:
            return "Connected to server"
        case .disconnected:
            return "Unable to connect to server"
        case .authenticationFailed:
            return "Authentication failed - check API key"
        case .unknown:
            return "Checking connection..."
        case .failed(let error):
            if let stashError = error as? StashAPIError {
                return stashError.localizedDescription
            } else {
                return "Connection failed: \(error.localizedDescription)"
            }
        }
    }
    
    // MARK: - Authentication Methods
    private func configureRequestWithAuth(_ request: inout URLRequest, referer: String? = nil) {
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        if let referer = referer {
            request.setValue(referer, forHTTPHeaderField: "Referer")
        }
        request.timeoutInterval = 30.0
    }

    // MARK: - Modern Async/Await GraphQL Methods

    /// Public method to execute GraphQL queries directly with async/await
    func executeGraphQLQueryAsync(_ query: String) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = query.data(using: .utf8)

        let (data, response) = try await URLSession.shared.data(for: request)

        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
            throw StashAPIError.serverError(httpResponse.statusCode)
        }

        return data
    }

    /// Performs a GraphQL request using async/await
    private func performGraphQLRequest<T: Decodable>(query: String, variables: [String: Any]? = nil) async throws -> T {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        // Create the request body
        var requestBody: [String: Any] = [
            "query": query
        ]
        if let variables = variables {
            requestBody["variables"] = variables
        }

        // Convert request body to JSON data
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        // Create and configure the request
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.httpBody = jsonData

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                print("üì° GraphQL Response Status: \(httpResponse.statusCode)")

                if httpResponse.statusCode == 401 {
                    throw StashAPIError.authenticationFailed
                }

                if !(200...299).contains(httpResponse.statusCode) {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            print("‚ùå GraphQL Error: \(error)")
            throw error
        }
    }

    // Add a version of performGraphQLRequest that returns raw Data
    private func performGraphQLRequest(query: String, variables: [String: Any]? = nil) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        // Create the request body
        var requestBody: [String: Any] = [
            "query": query
        ]
        if let variables = variables {
            requestBody["variables"] = variables
        }

        // Convert request body to JSON data
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        // Create and configure the request
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.httpBody = jsonData

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                print("üì° GraphQL Response Status: \(httpResponse.statusCode)")

                if httpResponse.statusCode == 401 {
                    throw StashAPIError.authenticationFailed
                }

                if !(200...299).contains(httpResponse.statusCode) {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            return data
        } catch {
            print("‚ùå GraphQL Error: \(error)")
            throw error
        }
    }

    // Public method to execute GraphQL queries directly
    public func executeGraphQLQuery(_ query: String) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = query.data(using: .utf8)

        let (data, response) = try await URLSession.shared.data(for: request)

        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
            throw StashAPIError.serverError(httpResponse.statusCode)
        }

        return data
    }
    
    // MARK: - Scenes Methods
    func fetchScenes(page: Int = 1, sort: String = "file_mod_time", direction: String = "DESC", appendResults: Bool = false, filterOptions: FilterOptions? = nil) async {
        do {
            // Generate random seed for random sorting
            let randomSeed = Int.random(in: 0...999999)
            let sortField = sort == "random" ? "random_\(randomSeed)" : sort
            
            // Prepare variables
            var queryVars: [String: Any] = [
                "filter": [
                    "page": page,
                    "per_page": 100,
                    "sort": sortField,
                    "direction": direction
                ]
            ]
            
            // Add scene filters if provided
            if let filterOptions = filterOptions {
                let sceneFilter = filterOptions.generateSceneFilter()
                if !sceneFilter.isEmpty {
                    queryVars["scene_filter"] = sceneFilter
                }
            }
            
            // Prepare GraphQL query
            let graphQLRequest: [String: Any] = [
                "operationName": "FindScenes",
                "variables": queryVars,
                "query": """
                query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) {
                    findScenes(filter: $filter, scene_filter: $scene_filter) {
                        count
                        scenes {
                            id
                            title
                            details
                            url
                            date
                            rating100
                            organized
                            o_counter
                            paths {
                                screenshot
                                preview
                                stream
                                webp
                                vtt
                                sprite
                                funscript
                                interactive_heatmap
                            }
                            files {
                                size
                                duration
                                video_codec
                                width
                                height
                            }
                            performers {
                                id
                                name
                                gender
                                image_path
                                scene_count
                            }
                            tags {
                                id
                                name
                            }
                            studio {
                                id
                                name
                            }
                            stash_ids {
                                endpoint
                                stash_id
                            }
                            created_at
                            updated_at
                        }
                    }
                }
                """
            ]
            
            // Convert to JSON data
            let jsonData = try JSONSerialization.data(withJSONObject: graphQLRequest)
            
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            configureRequestWithAuth(&request)
            request.httpBody = jsonData

            print("üì§ Fetching scenes page \(page) (sort: \(sort), direction: \(direction))")
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            // Check for task cancellation
            if Task.isCancelled {
                print("‚ö†Ô∏è Scene fetch task was cancelled")
                throw StashAPIError.taskCancelled
            }
            
            // Log HTTP response code for debugging
            if let httpResponse = response as? HTTPURLResponse {
                print("üì• HTTP response: \(httpResponse.statusCode)")
                
                // Check for server errors
                if httpResponse.statusCode >= 400 {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }
            
            // Decode the response
            let scenesResponse = try JSONDecoder().decode(GraphQLResponse<ScenesResponseData>.self, from: data)
            
            // Check for GraphQL errors
            if let errors = scenesResponse.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }
            
            // Update our data on the main thread
            await MainActor.run {
                // Update total count
                self.totalSceneCount = scenesResponse.data.findScenes.count
                
                // Update scenes array
                if appendResults {
                    // Filter out duplicates before appending
                    let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                        !self.scenes.contains { $0.id == newScene.id }
                    }
                    self.scenes.append(contentsOf: newScenes)
                    print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                } else {
                    self.scenes = scenesResponse.data.findScenes.scenes
                    print("‚úÖ Loaded \(self.scenes.count) scenes")
                }
                
                self.isLoading = false
                self.error = nil
            }
        } catch {
            // Only update UI state if task wasn't cancelled
            if !Task.isCancelled {
                await MainActor.run {
                    print("‚ùå Error fetching scenes: \(error.localizedDescription)")
                    self.error = error
                    self.isLoading = false
                }
            }
        }
    }
    
    // MARK: - Execute GraphQL Query Method
    // Removed duplicate method - using other executeGraphQLQuery implementation instead
    
    // MARK: - Performer Scenes Method
    func fetchPerformerScenes(performerId: String, page: Int = 1, perPage: Int = 100, sort: String = "file_mod_time", direction: String = "DESC", appendResults: Bool = false) async {
        do {
            // Prepare variables
            var queryVars: [String: Any] = [
                "filter": [
                    "page": page,
                    "per_page": perPage,
                    "sort": sort,
                    "direction": direction
                ],
                "performer_id": performerId
            ]

            // Prepare GraphQL query
            let graphQLRequest: [String: Any] = [
                "operationName": "FindPerformerScenes",
                "variables": queryVars,
                "query": """
                query FindPerformerScenes($filter: FindFilterType, $performer_id: ID!) {
                    findScenes(filter: $filter, scene_filter: { performers: [$performer_id] }) {
                        count
                        scenes {
                            id
                            title
                            details
                            url
                            date
                            rating100
                            organized
                            o_counter
                            paths {
                                screenshot
                                preview
                                stream
                                webp
                                vtt
                                sprite
                                funscript
                                interactive_heatmap
                            }
                            files {
                                size
                                duration
                                video_codec
                                width
                                height
                            }
                            performers {
                                id
                                name
                                gender
                                image_path
                                scene_count
                            }
                            tags {
                                id
                                name
                            }
                            studio {
                                id
                                name
                            }
                            stash_ids {
                                endpoint
                                stash_id
                            }
                            created_at
                            updated_at
                        }
                    }
                }
                """
            ]

            // Convert to JSON data
            let jsonData = try JSONSerialization.data(withJSONObject: graphQLRequest)

            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            configureRequestWithAuth(&request)
            request.httpBody = jsonData

            print("üì§ Fetching performer scenes (ID: \(performerId), page: \(page)")

            let (data, response) = try await URLSession.shared.data(for: request)

            // Check for task cancellation
            if Task.isCancelled {
                print("‚ö†Ô∏è Performer scenes fetch task was cancelled")
                throw StashAPIError.taskCancelled
            }

            // Log HTTP response code for debugging
            if let httpResponse = response as? HTTPURLResponse {
                print("üì• HTTP response: \(httpResponse.statusCode)")

                // Check for server errors
                if httpResponse.statusCode >= 400 {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            // Decode the response
            let scenesResponse = try JSONDecoder().decode(GraphQLResponse<ScenesResponseData>.self, from: data)

            // Check for GraphQL errors
            if let errors = scenesResponse.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            // Update our data on the main thread
            await MainActor.run {
                // Update total count
                self.totalSceneCount = scenesResponse.data.findScenes.count

                // Update scenes array
                if appendResults {
                    // Filter out duplicates before appending
                    let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                        !self.scenes.contains { $0.id == newScene.id }
                    }
                    self.scenes.append(contentsOf: newScenes)
                    print("‚úÖ Added \(newScenes.count) new performer scenes (total: \(self.scenes.count))")
                } else {
                    self.scenes = scenesResponse.data.findScenes.scenes
                    print("‚úÖ Loaded \(self.scenes.count) performer scenes")
                }

                self.isLoading = false
                self.error = nil
            }
        } catch {
            // Only update UI state if task wasn't cancelled
            if !Task.isCancelled {
                await MainActor.run {
                    print("‚ùå Error fetching performer scenes: \(error.localizedDescription)")
                    self.error = error
                    self.isLoading = false
                }
            }
        }
    }

    // MARK: - System Methods

    func getSystemStatus(completion: @escaping (Result<SystemStatus, Error>) -> Void) {
        let query = """
        query SystemStatus {
          systemStatus {
            databaseSchema
            databasePath
            configPath
            appSchema
            status
            appName
            appVersion
            logFile
            maxSessionAge
          }
        }
        """

        struct SystemStatusResponse: Decodable {
            let systemStatus: SystemStatus
        }

        executeGraphQLQuery<SystemStatusResponse>(query) { result in
            switch result {
            case .success(let response):
                self.systemStatus = response.systemStatus
                self.isConnected = true
                completion(.success(response.systemStatus))
            case .failure(let error):
                self.isConnected = false
                completion(.failure(error))
            }
        }
    }

    /// Checks if the Stash server is reachable and if the API key is valid
    func checkServerConnection() async throws {
        print("üîÑ Checking server connection to \(serverAddress)")

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid server URL")
            throw StashAPIError.invalidURL
        }

        // Create a simple query to check server status
        let query = """
        {
            "operationName": "FindPerformers",
            "variables": {
                "filter": {
                    "page": 1,
                    "per_page": 1,
                    "sort": "name",
                    "direction": "ASC"
                }
            },
            "query": "query FindPerformers($filter: FindFilterType) { findPerformers(filter: $filter) { count performers { id name } } }"
        }
        """

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Add both authentication methods to ensure compatibility
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        request.httpBody = query.data(using: .utf8)

        do {
            print("üì§ Sending connection check request...")
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ùå Invalid response type")
                throw StashAPIError.invalidResponse
            }

            print("üì° Server responded with status code: \(httpResponse.statusCode)")

            switch httpResponse.statusCode {
            case 200:
                guard !data.isEmpty else {
                    print("‚ùå Empty response data")
                    throw StashAPIError.emptyResponse
                }

                // Try to decode the response
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("üì• Response: \(jsonString.prefix(200))...")
                }

                do {
                    let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]

                    // Check if we got a data field
                    guard let dataField = json?["data"] as? [String: Any] else {
                        print("‚ùå Response missing data field")
                        throw StashAPIError.invalidData("Response missing data field")
                    }

                    // Check if we have performers data
                    guard let findPerformers = dataField["findPerformers"] as? [String: Any] else {
                        print("‚ùå Response missing performers data")
                        throw StashAPIError.invalidData("Response missing performers data")
                    }

                    print("‚úÖ Server connection successful")
                    print("üìä Performers data: \(findPerformers)")

                } catch {
                    print("‚ùå Failed to parse response: \(error)")
                    throw StashAPIError.decodingError(error)
                }

            case 401, 403:
                print("üîí Authentication failed")
                throw StashAPIError.authenticationFailed

            case 404:
                print("‚ùå Server endpoint not found")
                throw StashAPIError.connectionFailed("Server endpoint not found")

            case 500...599:
                print("‚ùå Server error: \(httpResponse.statusCode)")
                throw StashAPIError.serverError(httpResponse.statusCode)

            default:
                print("‚ùå Unexpected status code: \(httpResponse.statusCode)")
                throw StashAPIError.invalidResponse
            }

        } catch let error as StashAPIError {
            print("‚ùå StashAPI Error: \(error.localizedDescription)")
            throw error
        } catch {
            print("‚ùå Network Error: \(error.localizedDescription)")
            throw StashAPIError.networkError(error)
        }
    }

    /// Fetches statistics from Stash server
    func fetchStats() async throws -> StashStats {
        do {
            let query = """
            query {
              stats {
                scene_count
                scenes_size
                scene_duration
                image_count
                images_size
                gallery_count
                performer_count
                studio_count
                movie_count
                tag_count
              }
            }
            """

            let response: GraphQLResponse<StatsDataResponse> = try await performGraphQLRequest(query: query)

            // Check for errors in the response
            if let errors = response.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            DispatchQueue.main.async {
                self.connectionStatus = .connected
            }

            return response.data.stats
        } catch {
            DispatchQueue.main.async {
                self.connectionStatus = .failed(error)
            }

            NSLog("Error fetching stats: \(error)")
            throw error
        }
    }

    // MARK: - Random Scene/Performer Methods

    func fetchRandomScene(completion: @escaping (Result<StashScene, Error>) -> Void) {
        let query = """
        query FindRandomScene {
          findRandomScene {
            id
            title
            details
            url
            date
            rating100
            o_counter
            organized
            interactive
            files {
              id
              path
              size
              duration
              video_codec
              audio_codec
              width
              height
              frame_rate
              bit_rate
            }
            paths {
              screenshot
              preview
              stream
              webp
              vtt
              chapters_vtt
              sprite
              funscript
            }
            scene_markers {
              id
              scene {
                id
              }
              title
              seconds
              primary_tag {
                id
                name
              }
              tags {
                id
                name
              }
              stream
              preview
              screenshot
            }
            galleries {
              id
              title
              files {
                path
              }
              folder {
                path
              }
            }
            studio {
              id
              name
              image_path
            }
            movies {
              movie {
                id
                name
                front_image_path
              }
              scene_index
            }
            tags {
              id
              name
            }
            performers {
              id
              name
              gender
              favorite
              image_path
            }
            stash_ids {
              endpoint
              stash_id
            }
          }
        }
        """

        struct SceneResponse: Decodable {
            let findRandomScene: StashScene
        }

        executeGraphQLQuery<SceneResponse>(query) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findRandomScene))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func fetchRandomPerformer(completion: @escaping (Result<StashScene.Performer, Error>) -> Void) {
        let query = """
        query FindRandomPerformer {
          findRandomPerformer {
            id
            name
            gender
            url
            twitter
            instagram
            birthdate
            death_date
            ethnicity
            country
            eye_color
            height_cm
            measurements
            fake_tits
            penis_length
            circumcised
            hair_color
            weight
            created_at
            updated_at
            favorite
            ignore_auto_tag
            image_path
            scene_count
            image_count
            gallery_count
            movie_count
            tags {
              id
              name
            }
            stash_ids {
              stash_id
              endpoint
            }
            rating100
            details
            aliases
          }
        }
        """

        struct PerformerResponse: Decodable {
            let findRandomPerformer: StashScene.Performer
        }

        executeGraphQLQuery<PerformerResponse>(query) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findRandomPerformer))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    // MARK: - Tag Methods

    func findTags(filter: TagFilter? = nil, completion: @escaping (Result<[StashScene.Tag], Error>) -> Void) {
        let query = """
        query FindTags($filter: TagFilterType) {
          findTags(tag_filter: $filter) {
            count
            tags {
              id
              name
              aliases
              image_path
              scene_count
            }
          }
        }
        """

        var variables: [String: Any] = [:]
        if let filter = filter {
            variables["filter"] = filter.toDictionary()
        }

        struct TagsResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        executeGraphQLQuery<TagsResponse>(query, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findTags.tags))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    // Extension to send method for GraphQL queries when using async/await
    func send<T: Decodable>(query: String) async throws -> GraphQLResponse<T> {
        // Use the existing performGraphQLRequest method
        return try await performGraphQLRequest(query: query)
    }

    // MARK: - Additional Missing Methods

    func searchTags(query: String, completion: @escaping (Result<[StashScene.Tag], Error>) -> Void) {
        let graphQLQuery = """
        query FindTags($filter: FindFilterType) {
          findTags(filter: $filter) {
            count
            tags {
              id
              name
              scene_count
              image_count
            }
          }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "per_page": 10,
                "sort": "name",
                "direction": "ASC"
            ]
        ]

        struct TagSearchResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        executeGraphQLQuery<TagSearchResponse>(graphQLQuery, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findTags.tags))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func findTag(id: String, completion: @escaping (Result<StashScene.Tag, Error>) -> Void) {
        let query = """
        query FindTag($id: ID!) {
          findTag(id: $id) {
            id
            name
            aliases
            image_path
            scene_count
          }
        }
        """

        let variables: [String: Any] = ["id": id]

        struct TagResponse: Decodable {
            let findTag: StashScene.Tag
        }

        executeGraphQLQuery<TagResponse>(query, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findTag))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func fetchPerformers(filter: PerformerFilter = .all, page: Int = 1, appendResults: Bool = false, search: String = "", completion: @escaping (Result<[StashScene.Performer], Error>) -> Void) {
        let sceneCountValue: String
        switch filter {
        case .all:
            sceneCountValue = "0"
        case .lessThanTwo:
            sceneCountValue = "2"
        case .twoOrMore:
            sceneCountValue = "2"
        case .tenOrMore:
            sceneCountValue = "10"
        }

        let sceneCountModifier = filter == .lessThanTwo ? "LESS_THAN" : "GREATER_THAN"

        let escapedQuery = search.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\"")
        let query = """
        query FindPerformers($filter: FindFilterType, $performer_filter: PerformerFilterType) {
            findPerformers(filter: $filter, performer_filter: $performer_filter) {
                count
                performers {
                    id
                    name
                    gender
                    image_path
                    scene_count
                    favorite
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": escapedQuery,
                "page": page,
                "per_page": 25,
                "sort": "name",
                "direction": "ASC"
            ],
            "performer_filter": [
                "scene_count": [
                    "modifier": sceneCountModifier,
                    "value": sceneCountValue
                ]
            ]
        ]

        struct PerformersResponse: Decodable {
            let findPerformers: FindPerformersResult

            struct FindPerformersResult: Decodable {
                let count: Int
                let performers: [StashScene.Performer]
            }
        }

        executeGraphQLQuery<PerformersResponse>(query, variables: variables) { result in
            switch result {
            case .success(let response):
                if appendResults {
                    // Filter out duplicates before appending
                    let newPerformers = response.findPerformers.performers.filter { newPerformer in
                        !self.performers.contains { $0.id == newPerformer.id }
                    }
                    self.performers.append(contentsOf: newPerformers)
                    self.totalPerformerCount = response.findPerformers.count
                    completion(.success(self.performers))
                } else {
                    self.performers = response.findPerformers.performers
                    self.totalPerformerCount = response.findPerformers.count
                    completion(.success(response.findPerformers.performers))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func searchScenes(query: String, completion: @escaping (Result<[StashScene], Error>) -> Void) {
        // Escape special characters in the search term
        let escaped = query
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")

        // Use filter.q for full-text search across scenes
        let graphQLQuery = """
        query FindScenes($filter: FindFilterType) {
            findScenes(filter: $filter) {
                count
                scenes {
                    id
                    title
                    details
                    url
                    date
                    rating100
                    organized
                    o_counter
                    paths {
                        screenshot
                        preview
                        stream
                    }
                    files {
                        size
                        duration
                        video_codec
                        width
                        height
                    }
                    performers {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                    studio {
                        id
                        name
                    }
                    stash_ids {
                        endpoint
                        stash_id
                    }
                    created_at
                    updated_at
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": escaped,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        executeGraphQLQuery<ScenesResponseData>(graphQLQuery, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findScenes.scenes))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func fetchPerformerMarkers(performerId: String, page: Int = 1, completion: @escaping (Result<[SceneMarker], Error>) -> Void) {
        let graphQLQuery = """
        query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) {
            findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) {
                count
                scene_markers {
                    id
                    title
                    seconds
                    stream
                    preview
                    screenshot
                    scene {
                        id
                        title
                        paths {
                            screenshot
                            preview
                            stream
                        }
                        performers {
                            id
                            name
                            image_path
                        }
                        studio {
                            id
                            name
                        }
                    }
                    primary_tag {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "page": page,
                "per_page": 50
            ],
            "scene_marker_filter": [
                "performers": [
                    "value": [performerId],
                    "modifier": "INCLUDES_ALL"
                ]
            ]
        ]

        struct SceneMarkersResponse: Decodable {
            let findSceneMarkers: SceneMarkersData

            struct SceneMarkersData: Decodable {
                let count: Int
                let scene_markers: [SceneMarker]
            }
        }

        executeGraphQLQuery<SceneMarkersResponse>(graphQLQuery, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findSceneMarkers.scene_markers))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func searchMarkers(query: String, completion: @escaping (Result<[SceneMarker], Error>) -> Void) {
        let graphQLQuery = """
        query FindSceneMarkers($filter: FindFilterType) {
            findSceneMarkers(filter: $filter) {
                count
                scene_markers {
                    id
                    title
                    seconds
                    stream
                    preview
                    screenshot
                    scene {
                        id
                        title
                        paths {
                            screenshot
                            preview
                            stream
                        }
                        performers {
                            id
                            name
                            image_path
                        }
                        studio {
                            id
                            name
                        }
                    }
                    primary_tag {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        struct SceneMarkersResponse: Decodable {
            let findSceneMarkers: SceneMarkersData

            struct SceneMarkersData: Decodable {
                let count: Int
                let scene_markers: [SceneMarker]
            }
        }

        executeGraphQLQuery<SceneMarkersResponse>(graphQLQuery, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.findSceneMarkers.scene_markers))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func createSceneMarker(sceneId: String, title: String, seconds: Float, primaryTagId: String, tagIds: [String], completion: @escaping (Result<SceneMarker, Error>) -> Void) {
        let query = """
        mutation SceneMarkerCreate($input: SceneMarkerCreateInput!) {
            sceneMarkerCreate(input: $input) {
                id
                title
                seconds
                stream
                preview
                screenshot
                primary_tag {
                    id
                    name
                }
                tags {
                    id
                    name
                }
                scene {
                    id
                    title
                }
            }
        }
        """

        let input: [String: Any] = [
            "scene_id": sceneId,
            "title": title,
            "seconds": seconds,
            "primary_tag_id": primaryTagId,
            "tag_ids": tagIds
        ]

        let variables: [String: Any] = ["input": input]

        struct CreateMarkerResponse: Decodable {
            let sceneMarkerCreate: SceneMarker
        }

        executeGraphQLQuery<CreateMarkerResponse>(query, variables: variables) { result in
            switch result {
            case .success(let response):
                completion(.success(response.sceneMarkerCreate))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func testConnection(completion: @escaping (Bool) -> Void) {
        let query = """
        query SystemStatus {
          systemStatus {
            status
          }
        }
        """

        struct SystemStatusResponse: Decodable {
            let systemStatus: SystemStatus
        }

        executeGraphQLQuery<SystemStatusResponse>(query) { result in
            switch result {
            case .success(_):
                completion(true)
            case .failure(_):
                completion(false)
            }
        }
    }

    // Method for async/await calls and to support MarkersView
    func fetchMarkers(page: Int = 1, appendResults: Bool = false) async {
        let query = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 40
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType) { findSceneMarkers(filter: $filter) { count scene_markers { id title seconds stream preview screenshot scene { id title paths { screenshot preview stream } } primary_tag { id name } tags { id name } } } }"
        }
        """

        isLoading = true

        do {
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.httpBody = query.data(using: .utf8)

            let (data, _) = try await URLSession.shared.data(for: request)

            struct SceneMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data
            }

            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)

            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let newMarkers = response.data.findSceneMarkers.scene_markers.filter { newMarker in
                        !self.markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: newMarkers)
                } else {
                    self.markers = response.data.findSceneMarkers.scene_markers
                }

                self.isLoading = false
            }
        } catch {
            print("Error fetching markers: \(error)")
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }
}

// MARK: - Additional Data Models

// StashStats model for stats endpoint
struct StashStats: Codable {
    let scene_count: Int
    let scenes_size: Int64
    let scene_duration: Double
    let image_count: Int
    let images_size: Int64
    let gallery_count: Int
    let performer_count: Int
    let studio_count: Int
    let movie_count: Int
    let tag_count: Int
}

// Additional filter models
struct TagFilter {
    var name: String?
    var sceneCount: Int?

    func toDictionary() -> [String: Any] {
        var result: [String: Any] = [:]
        if let name = name {
            result["name"] = ["modifier": "INCLUDES", "value": name]
        }
        if let sceneCount = sceneCount {
            result["scene_count"] = ["modifier": "GREATER_THAN", "value": sceneCount]
        }
        return result
    }
}

================
File: stash/Networking/StashAPIError.swift
================
import Foundation

enum StashAPIError: Error, LocalizedError {
    case graphQLError(String)
    case networkError(Error)
    case decodingError(Error)
    case dataNotFound(String)
    case invalidURL
    case invalidResponse
    case serverError(Int)
    case connectionFailed(String)
    case authenticationFailed
    case emptyResponse
    case invalidData(String)
    case taskCancelled
    
    var errorDescription: String? {
        switch self {
        case .graphQLError(let message):
            return "GraphQL Error: \(message)"
        case .networkError(let error):
            return "Network Error: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Decoding Error: \(error.localizedDescription)"
        case .dataNotFound(let message):
            return "Data Not Found: \(message)"
        case .invalidURL:
            return "Invalid URL"
        case .invalidResponse:
            return "Invalid Server Response"
        case .serverError(let code):
            return "Server Error (\(code))"
        case .connectionFailed(let reason):
            return "Connection Failed: \(reason)"
        case .authenticationFailed:
            return "Authentication Failed"
        case .emptyResponse:
            return "Server returned empty response"
        case .invalidData(let details):
            return "Invalid Data: \(details)"
        case .taskCancelled:
            return "Request was cancelled"
        }
    }
}

================
File: stash/Preview Content/Preview Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: stash/Utilities/AnimationModifiers.swift
================
import SwiftUI

// MARK: - Entrance Animation Modifiers

/// Slide in animation from a direction
struct SlideIn: ViewModifier {
    let direction: Edge
    let delay: Double
    let duration: Double
    @State private var isActive = false
    
    init(direction: Edge, delay: Double = 0, duration: Double = 0.3) {
        self.direction = direction
        self.delay = delay
        self.duration = duration
    }
    
    func body(content: Content) -> some View {
        content
            .offset(
                x: offsetX,
                y: offsetY
            )
            .opacity(isActive ? 1 : 0)
            .onAppear {
                withAnimation(.easeOut(duration: duration).delay(delay)) {
                    isActive = true
                }
            }
    }
    
    private var offsetX: CGFloat {
        guard !isActive else { return 0 }
        
        switch direction {
        case .leading: return -50
        case .trailing: return 50
        default: return 0
        }
    }
    
    private var offsetY: CGFloat {
        guard !isActive else { return 0 }
        
        switch direction {
        case .top: return -50
        case .bottom: return 50
        default: return 0
        }
    }
}

/// Fade in animation
struct FadeIn: ViewModifier {
    let delay: Double
    let duration: Double
    @State private var isActive = false
    
    func body(content: Content) -> some View {
        content
            .opacity(isActive ? 1 : 0)
            .onAppear {
                withAnimation(.easeIn(duration: duration).delay(delay)) {
                    isActive = true
                }
            }
    }
}

/// Scale animation
struct ScaleIn: ViewModifier {
    let scale: CGFloat
    let delay: Double
    let duration: Double
    @State private var isActive = false
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(isActive ? 1.0 : scale)
            .opacity(isActive ? 1.0 : 0.0)
            .onAppear {
                withAnimation(.spring(response: duration, dampingFraction: 0.6).delay(delay)) {
                    isActive = true
                }
            }
    }
}

// MARK: - Hover Effect Modifiers

/// Hover effect for iPadOS
struct HoverEffect: ViewModifier {
    let scale: CGFloat
    let shadowRadius: CGFloat
    @State private var isHovering = false
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(isHovering ? scale : 1.0)
            .shadow(radius: isHovering ? shadowRadius : 0)
            .shadow(color: .blue.opacity(UIDevice.current.userInterfaceIdiom == .pad ? 0.3 : 0.1), 
                    radius: isHovering ? shadowRadius * 1.5 : 0, 
                    x: 0, 
                    y: 0)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isHovering)
            .onHover { hovering in
                isHovering = hovering
            }
    }
}

// MARK: - Loading Animation Modifiers

/// Shimmer loading effect
struct ShimmerEffect: ViewModifier {
    @State private var isAnimating = false
    
    func body(content: Content) -> some View {
        content
            .overlay(
                GeometryReader { geometry in
                    ZStack {
                        Color.white.opacity(0.1)
                        
                        Rectangle()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.clear,
                                        Color.white.opacity(0.3),
                                        Color.clear
                                    ]),
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .rotationEffect(.degrees(45))
                            .offset(x: isAnimating ? geometry.size.width : -geometry.size.width)
                            .animation(
                                Animation.linear(duration: 1.5)
                                    .repeatForever(autoreverses: false),
                                value: isAnimating
                            )
                    }
                }
                .mask(content)
                .onAppear {
                    isAnimating = true
                }
            )
    }
}

// MARK: - Pulse Animation Modifier

/// Pulsating animation
struct PulseEffect: ViewModifier {
    let duration: Double
    let minScale: CGFloat
    let maxScale: CGFloat
    @State private var isAnimating = false
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(isAnimating ? maxScale : minScale)
            .animation(
                Animation.easeInOut(duration: duration)
                    .repeatForever(autoreverses: true),
                value: isAnimating
            )
            .onAppear {
                isAnimating = true
            }
    }
}

// MARK: - SlideInModifier (used in MarkerView)
struct SlideInModifier: ViewModifier {
    let edge: Edge
    let delay: Double
    let duration: Double
    
    @State private var isActive = false
    
    func body(content: Content) -> some View {
        content
            .offset(x: edge == .leading ? (isActive ? 0 : -30) : (edge == .trailing ? (isActive ? 0 : 30) : 0),
                   y: edge == .top ? (isActive ? 0 : -30) : (edge == .bottom ? (isActive ? 0 : 30) : 0))
            .opacity(isActive ? 1 : 0)
            .animation(.easeOut(duration: duration).delay(delay), value: isActive)
            .onAppear {
                withAnimation {
                    isActive = true
                }
            }
    }
}

// MARK: - ScaleButtonStyle (used in MarkerView and MarkerRow)
public struct ScaleButtonStyle: ButtonStyle {
    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1)
            .opacity(configuration.isPressed ? 0.9 : 1)
            .animation(.easeInOut(duration: 0.15), value: configuration.isPressed)
    }
}

// MARK: - View Extensions

extension View {
    /// Apply slide in animation
    func slideIn(from edge: Edge, delay: Double = 0, duration: Double = 0.3) -> some View {
        modifier(SlideIn(direction: edge, delay: delay, duration: duration))
    }
    
    /// Apply fade in animation
    func fadeIn(delay: Double = 0, duration: Double = 0.3) -> some View {
        modifier(FadeIn(delay: delay, duration: duration))
    }
    
    /// Apply hover effect using ScaleButtonStyle
    func applyHoverEffect() -> some View {
        self.buttonStyle(ScaleButtonStyle())
    }
    
    /// Apply scale in animation
    func scaleIn(from scale: CGFloat = 0.8, delay: Double = 0, duration: Double = 0.5) -> some View {
        modifier(ScaleIn(scale: scale, delay: delay, duration: duration))
    }
    
    /// Apply hover effect for iPadOS
    func applyHoverEffect(scale: CGFloat = 0, shadowRadius: CGFloat = 5) -> some View {
        let deviceScale = UIDevice.current.userInterfaceIdiom == .pad ? 1.08 : 1.05
        let actualScale = scale > 0 ? scale : deviceScale
        return modifier(HoverEffect(scale: actualScale, shadowRadius: shadowRadius))
    }
    
    /// Apply shimmer loading effect
    func shimmer() -> some View {
        modifier(ShimmerEffect())
    }
    
    /// Apply pulse animation
    func pulse(duration: Double = 1.0, minScale: CGFloat = 0.95, maxScale: CGFloat = 1.05) -> some View {
        modifier(PulseEffect(duration: duration, minScale: minScale, maxScale: maxScale))
    }
}

================
File: stash/Utilities/VideoPlayerUtility.swift
================
import Foundation
import AVKit
import UIKit
import SwiftUI

/// Utility class for handling video player URLs and requests
class VideoPlayerUtility {
    /// Gets a thumbnail URL for a scene at a specific timestamp
    /// - Parameters:
    ///   - sceneID: The scene ID
    ///   - seconds: The timestamp in seconds to get the thumbnail for
    /// - Returns: URL for the thumbnail image
    static func getThumbnailURL(forSceneID sceneID: String, seconds: Double) -> URL? {
        guard let serverAddress = StashAPIManager.shared.api?.serverAddress else {
            return nil
        }

        var components = URLComponents(string: "\(serverAddress)/scene/\(sceneID)/screenshot")

        var queryItems = [URLQueryItem]()
        queryItems.append(URLQueryItem(name: "t", value: String(format: "%.2f", seconds)))

        // Avoid caching by adding a timestamp
        let timestamp = Int(Date().timeIntervalSince1970)
        queryItems.append(URLQueryItem(name: "_ts", value: "\(timestamp)"))

        // Add API key for authentication
        if let apiKey = StashAPIManager.shared.api?.apiKeyForURLs {
            queryItems.append(URLQueryItem(name: "apikey", value: apiKey))
        }

        components?.queryItems = queryItems
        return components?.url
    }

    /// Gets the default screenshot URL for a scene
    /// - Parameter sceneID: The scene ID
    /// - Returns: URL for the screenshot image
    static func getScreenshotURL(forSceneID sceneID: String) -> URL? {
        guard let serverAddress = StashAPIManager.shared.api?.serverAddress else {
            return nil
        }

        var components = URLComponents(string: "\(serverAddress)/scene/\(sceneID)/screenshot")

        var queryItems = [URLQueryItem]()

        // Avoid caching by adding a timestamp
        let timestamp = Int(Date().timeIntervalSince1970)
        queryItems.append(URLQueryItem(name: "_ts", value: "\(timestamp)"))

        // Add API key for authentication
        if let apiKey = StashAPIManager.shared.api?.apiKeyForURLs {
            queryItems.append(URLQueryItem(name: "apikey", value: apiKey))
        }

        components?.queryItems = queryItems
        return components?.url
    }

    /// Gets a sprite image URL for a scene
    /// - Parameter sceneID: The scene ID
    /// - Returns: URL for the sprite image
    static func getSpriteURL(forSceneID sceneID: String) -> URL? {
        guard let serverAddress = StashAPIManager.shared.api?.serverAddress else {
            return nil
        }

        var components = URLComponents(string: "\(serverAddress)/scene/\(sceneID)/sprite")

        var queryItems = [URLQueryItem]()

        // Avoid caching by adding a timestamp
        let timestamp = Int(Date().timeIntervalSince1970)
        queryItems.append(URLQueryItem(name: "_ts", value: "\(timestamp)"))

        // Add API key for authentication
        if let apiKey = StashAPIManager.shared.api?.apiKeyForURLs {
            queryItems.append(URLQueryItem(name: "apikey", value: apiKey))
        }

        components?.queryItems = queryItems
        return components?.url
    }

    /// Gets a VTT file URL for a scene (for video chapters/thumbnails)
    /// - Parameter sceneID: The scene ID
    /// - Returns: URL for the VTT file
    static func getVTTURL(forSceneID sceneID: String) -> URL? {
        guard let serverAddress = StashAPIManager.shared.api?.serverAddress else {
            return nil
        }

        var components = URLComponents(string: "\(serverAddress)/scene/\(sceneID)/vtt/thumbnails")

        var queryItems = [URLQueryItem]()

        // Avoid caching by adding a timestamp
        let timestamp = Int(Date().timeIntervalSince1970)
        queryItems.append(URLQueryItem(name: "_ts", value: "\(timestamp)"))

        // Add API key for authentication
        if let apiKey = StashAPIManager.shared.api?.apiKeyForURLs {
            queryItems.append(URLQueryItem(name: "apikey", value: apiKey))
        }

        components?.queryItems = queryItems
        return components?.url
    }

    /// Gets a preview video URL for a scene
    /// - Parameter sceneID: The scene ID
    /// - Returns: URL for the preview video
    static func getPreviewURL(forSceneID sceneID: String) -> URL? {
        guard let serverAddress = StashAPIManager.shared.api?.serverAddress else {
            return nil
        }

        var components = URLComponents(string: "\(serverAddress)/scene/\(sceneID)/preview")

        var queryItems = [URLQueryItem]()

        // Avoid caching by adding a timestamp
        let timestamp = Int(Date().timeIntervalSince1970)
        queryItems.append(URLQueryItem(name: "_ts", value: "\(timestamp)"))

        // Add API key for authentication
        if let apiKey = StashAPIManager.shared.api?.apiKeyForURLs {
            queryItems.append(URLQueryItem(name: "apikey", value: apiKey))
        }

        components?.queryItems = queryItems
        return components?.url
    }

    /// Utility method to convert a direct stream URL to an HLS stream URL
    /// - Parameter directURL: The direct stream URL
    /// - Returns: The corresponding HLS stream URL
    static func getHLSStreamURL(from directURL: URL) -> URL? {
        print("üéØ Converting direct URL to HLS: \(directURL.absoluteString)")

        // Extract components from the URL
        var urlString = directURL.absoluteString
        
        // Extract any start parameter from the original URL if present
        var startParameter: String?
        if let startRange = directURL.absoluteString.range(of: "start=[^&]+") {
            startParameter = String(directURL.absoluteString[startRange])
            print("üéØ Found start parameter: \(startParameter!)")
        }
        
        // Check if this is a marker URL (either scene_marker or has start parameter)
        let isMarkerURL = directURL.absoluteString.contains("scene_marker") || startParameter != nil

        // Check if the URL already ends with .m3u8
        if urlString.contains("stream.m3u8") {
            // URL is already an HLS stream, just make sure it has the resolution parameter
            if !urlString.contains("resolution=") {
                // Add resolution parameter if not present
                if urlString.contains("?") {
                    // URL already has parameters, add resolution as an additional parameter
                    urlString += "&resolution=ORIGINAL"
                } else {
                    // URL has no parameters, add resolution as the first parameter
                    urlString += "?resolution=ORIGINAL"
                }
            }
            
            // Add start parameter if this is a marker URL and doesn't already have it
            if isMarkerURL && startParameter != nil && !urlString.contains("start=") {
                urlString += "&\(startParameter!)"
            }
            
            print("‚úÖ Using existing HLS stream URL with resolution: \(urlString)")
            return URL(string: urlString)
        }

        // Replace /stream with /stream.m3u8 if present
        if urlString.contains("/stream") {
            urlString = urlString.replacingOccurrences(of: "/stream", with: "/stream.m3u8")

            // Build query parameters with all needed values
            var parameters = ["resolution=ORIGINAL"]
            
            // Add apikey parameter if present in original URL
            if directURL.absoluteString.contains("apikey=") {
                // Extract the apikey from the original URL
                if let apiKeyRange = directURL.absoluteString.range(of: "apikey=[^&]+") {
                    let apiKey = String(directURL.absoluteString[apiKeyRange])
                    parameters.append(apiKey)
                }
            }
            
            // Add start parameter for marker playback
            if isMarkerURL && startParameter != nil {
                parameters.append(startParameter!)
            } else if urlString.contains("scene_marker") {
                // For scene_marker endpoints, try to extract the timestamp
                // This is a fallback for direct scene_marker URLs without start parameter
                if let markerIdRange = urlString.range(of: "scene_marker/([^/]+)", options: .regularExpression),
                   let markerId = Int(urlString[markerIdRange].replacingOccurrences(of: "scene_marker/", with: "")) {
                    print("üéØ Extracted marker ID: \(markerId), adding default timestamp")
                    parameters.append("start=0")
                }
            }
            
            // Add all parameters to URL
            if urlString.contains("?") {
                urlString += "&" + parameters.joined(separator: "&")
            } else {
                urlString += "?" + parameters.joined(separator: "&")
            }

            print("üîÑ Converted to HLS URL: \(urlString)")
            return URL(string: urlString)
        }

        // If we can't determine the HLS URL, return nil
        print("‚ö†Ô∏è Unable to convert to HLS URL")
        return nil
    }

    /// Jumps to a random position in the provided AVPlayer
    /// - Parameter player: The AVPlayer to jump to a random position in
    /// - Returns: True if the jump was successful, false otherwise
    @discardableResult
    static func jumpToRandomPosition(in player: AVPlayer) -> Bool {
        // Get the current item and check status
        guard let currentItem = player.currentItem else {
            print("‚ö†Ô∏è Cannot jump to random position - no current item")
            return false
        }

        // When video first loads, duration might not be available or fully loaded
        let duration: Double

        // Handle different states of video loading
        if currentItem.status == .readyToPlay && currentItem.duration.isValid && !currentItem.duration.seconds.isNaN && currentItem.duration.seconds > 0 {
            // Normal case - video is ready with valid duration
            duration = currentItem.duration.seconds
            print("üé≤ Current video duration: \(duration) seconds")
        } else {
            // Fallback case - try to use a reasonable default duration if not fully loaded
            // This allows jumping to work even if the video is still loading
            print("‚ö†Ô∏è Video duration not fully loaded yet, using estimated duration")

            // Try to get duration from file information if available
            if let loadedTimeRanges = currentItem.loadedTimeRanges.first {
                let timeRange = loadedTimeRanges.timeRangeValue
                let loadedDuration = timeRange.duration.seconds

                if loadedDuration > 0 {
                    print("üé≤ Using loaded time range: \(loadedDuration) seconds")
                    duration = loadedDuration
                } else {
                    // If no loaded time range, use a reasonable default (typical video length)
                    duration = 1800 // 30 minutes as a fallback
                    print("üé≤ Using default duration: \(duration) seconds (30 minutes)")
                }
            } else {
                // No loaded time ranges, use a reasonable default
                duration = 1800 // 30 minutes as a fallback
                print("üé≤ Using default duration: \(duration) seconds (30 minutes)")
            }
        }

        // Current time for logging
        let currentSeconds = currentItem.currentTime().seconds.isNaN ? 0 : currentItem.currentTime().seconds
        print("üé≤ Current position: \(currentSeconds) seconds")

        // Calculate a random position between 20 seconds and 90% of the duration
        // For very short videos, ensure at least some meaningful jump
        let minPosition = max(20, duration * 0.05) // At least 20 seconds or 5% in
        let maxPosition = min(duration - 5, duration * 0.9) // At most 90% through the video

        if minPosition >= maxPosition {
            print("‚ö†Ô∏è Video too short or invalid duration range: \(minPosition) >= \(maxPosition)")
            // Still try to jump to a reasonable position
            let defaultPosition = max(20, min(300, duration / 2))
            print("üé≤ Using default position: \(defaultPosition) seconds")

            let time = CMTime(seconds: defaultPosition, preferredTimescale: 1000)
            player.seek(to: time)
            return true
        }

        // Generate random position
        let randomPosition = Double.random(in: minPosition...maxPosition)
        let minutes = Int(randomPosition / 60)
        let seconds = Int(randomPosition) % 60

        print("üé≤ Jumping to random position: \(randomPosition) seconds (\(minutes):\(String(format: "%02d", seconds)))")

        // Create time with higher precision timescale
        let time = CMTime(seconds: randomPosition, preferredTimescale: 1000)

        // Set tolerances for more precise seeking
        let toleranceBefore = CMTime(seconds: 0.5, preferredTimescale: 1000)
        let toleranceAfter = CMTime(seconds: 0.5, preferredTimescale: 1000)

        // Perform the seek operation
        print("üé≤ Seeking to new position...")
        player.seek(to: time, toleranceBefore: toleranceBefore, toleranceAfter: toleranceAfter) { success in
            if success {
                print("‚úÖ Successfully jumped to \(minutes):\(String(format: "%02d", seconds))")

                // Provide haptic feedback
                let generator = UIImpactFeedbackGenerator(style: .medium)
                generator.impactOccurred()

                // Make sure playback continues
                if player.timeControlStatus != .playing {
                    player.play()
                }
            } else {
                print("‚ùå Seek operation failed, attempting simplified seek")
                // Try a simplified seek without tolerances as a fallback
                player.seek(to: time)

                // Make sure playback continues
                if player.timeControlStatus != .playing {
                    player.play()
                }
            }
        }

        return true
    }
}

// MARK: - Global Video Manager
class GlobalVideoManager {
    static let shared = GlobalVideoManager()

    private var activePlayers = Set<AVPlayer>()
    private var observationTokens = [AVPlayer: Any]()

    private init() {}

    func registerPlayer(_ player: AVPlayer) {
        DispatchQueue.main.async {
            self.activePlayers.insert(player)
            print("üé¨ GlobalVideoManager: Registered player, total active: \(self.activePlayers.count)")
        }
    }

    func unregisterPlayer(_ player: AVPlayer) {
        DispatchQueue.main.async {
            self.activePlayers.remove(player)
            if let token = self.observationTokens[player] {
                self.observationTokens.removeValue(forKey: player)
            }
            print("üé¨ GlobalVideoManager: Unregistered player, total active: \(self.activePlayers.count)")
        }
    }

    func stopAllPreviews() {
        DispatchQueue.main.async {
            print("üé¨ GlobalVideoManager: Stopping all \(self.activePlayers.count) active preview players")
            for player in self.activePlayers {
                player.pause()
            }
        }
    }

    func pauseAllExcept(_ player: AVPlayer) {
        DispatchQueue.main.async {
            for activePlayer in self.activePlayers {
                if activePlayer != player && activePlayer.timeControlStatus == .playing {
                    activePlayer.pause()
                }
            }
        }
    }

    func cleanupAllPlayers() {
        DispatchQueue.main.async {
            print("üßπ GlobalVideoManager: Cleaning up all \(self.activePlayers.count) active players")
            for player in self.activePlayers {
                player.pause()
                player.replaceCurrentItem(with: nil)
            }
            self.activePlayers.removeAll()
            self.observationTokens.removeAll()
        }
    }
}

// MARK: - Player Manager
class VideoPlayerManager: ObservableObject {
    @Published var useHLS: Bool = true
    @Published var isPlaying: Bool = false
    @Published var isBuffering: Bool = false
    @Published var currentTime: Double = 0
    @Published var duration: Double = 0

    init(useHLS: Bool = true) {
        self.useHLS = useHLS
    }

    func toggleHLS() {
        useHLS.toggle()
    }
}

// MARK: - Singleton API Manager
class StashAPIManager {
    static let shared = StashAPIManager()
    var api: StashAPI?

    private init() {}
}

// MARK: - Player Creation Methods
extension VideoPlayerUtility {
    /// Seek to a specific time in a player with robust error handling
    /// - Parameters:
    ///   - player: The AVPlayer to seek
    ///   - time: The time in seconds to seek to
    /// - Returns: True if seek was initiated successfully
    static func seekToTime(player: AVPlayer, time: Double) -> Bool {
        print("‚è± Seeking to time: \(time) seconds")
        
        // Add a quick log to confirm startTime > 0
        if time > 0 {
            print("‚úì Confirmed startTime (\(time)) is greater than 0")
        }
        
        // Create precise time value with high timescale for accuracy
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        
        // Use zero tolerances for precise seeking with marker positions
        player.seek(to: cmTime, toleranceBefore: .zero, toleranceAfter: .zero) { success in
            if success {
                print("‚úÖ Successfully sought to \(time) seconds")
                
                // Ensure playback continues after seeking
                if player.timeControlStatus != .playing {
                    player.play()
                }
            } else {
                print("‚ö†Ô∏è Precise seek failed, trying standard seek")
                
                // Try standard seek without tolerance specifications as fallback
                player.seek(to: cmTime) { innerSuccess in
                    if innerSuccess {
                        print("‚úÖ Standard seek succeeded to \(time) seconds")
                        if player.timeControlStatus != .playing {
                            player.play()
                        }
                    } else {
                        print("‚ùå All seek attempts failed to \(time) seconds")
                    }
                }
            }
        }
        
        return true
    }
    /// Creates and configures an AVPlayerViewController for playing video content
    /// - Parameters:
    ///   - url: URL of the video to play
    ///   - startTime: Optional starting time in seconds
    ///   - scenes: Optional array of scenes for playlist functionality
    ///   - currentIndex: The index of the current scene in the scenes array
    ///   - appModel: The app model
    /// - Returns: A configured AVPlayerViewController
    static func createPlayerViewController(
        url: URL,
        startTime: Double? = nil,
        scenes: [StashScene] = [],
        currentIndex: Int = 0,
        appModel: AppModel
    ) -> AVPlayerViewController {
        // First check if the URL already includes .m3u8 for HLS
        let isAlreadyHLS = url.absoluteString.contains("stream.m3u8")

        // Convert the direct URL to an HLS URL if it's not already HLS
        let finalURL: URL
        if isAlreadyHLS {
            print("üé¨ Using provided HLS URL: \(url.absoluteString)")
            finalURL = url
        } else {
            // Try to convert to HLS
            if let hlsURL = getHLSStreamURL(from: url) {
                print("üé¨ Converted to HLS URL: \(hlsURL.absoluteString)")
                finalURL = hlsURL
            } else {
                print("‚ö†Ô∏è Could not convert to HLS, using original URL: \(url.absoluteString)")
                finalURL = url
            }
        }

        // Create player and view controller
        let playerViewController = AVPlayerViewController()
        let player = AVPlayer(url: finalURL)
        playerViewController.player = player

        // Configure player options
        playerViewController.allowsPictureInPicturePlayback = true
        playerViewController.showsPlaybackControls = true

        // Set start time if provided
        if let startTime = startTime {
            print("‚è± Setting start time to \(startTime) seconds")
            // Use the consolidated seeking method for consistency
            _ = seekToTime(player: player, time: startTime)
        } else {
            print("‚ÑπÔ∏è No start time provided, starting from beginning")
        }

        // Add observer for playback progress
        if let sceneId = appModel.currentScene?.id {
            print("üìä Adding playback progress observer for scene ID: \(sceneId)")
            let interval = CMTime(seconds: 5, preferredTimescale: 1)
            player.addPeriodicTimeObserver(forInterval: interval, queue: .main) { time in
                let seconds = CMTimeGetSeconds(time)
                if seconds > 0 {
                    UserDefaults.standard.setVideoProgress(seconds, for: sceneId)
                }
            }
        }

        // Register with VideoPlayerRegistry for consistent access
        print("üìù Registering player with VideoPlayerRegistry in createPlayerViewController")
        VideoPlayerRegistry.shared.currentPlayer = player
        VideoPlayerRegistry.shared.playerViewController = playerViewController

        // Also register with GlobalVideoManager
        GlobalVideoManager.shared.registerPlayer(player)

        // Start playback
        print("‚ñ∂Ô∏è Starting playback")
        player.play()

        return playerViewController
    }
}

================
File: stash/ViewModels/MarkerViewModel.swift
================
import Foundation
import Combine
import SwiftUI

/// The sorting options for markers
enum MarkerSortOption: String, CaseIterable, Identifiable {
    case timestamp = "timestamp"
    case title = "title"
    case createdAtDesc = "created_at_desc"
    case createdAtAsc = "created_at_asc"
    case sceneTitleAsc = "scene_title_asc"
    case sceneTitleDesc = "scene_title_desc"
    
    var id: String { rawValue }
    
    var label: String {
        switch self {
        case .timestamp: return "Time"
        case .title: return "Title"
        case .createdAtDesc: return "Newest First"
        case .createdAtAsc: return "Oldest First"
        case .sceneTitleAsc: return "Scene (A-Z)"
        case .sceneTitleDesc: return "Scene (Z-A)"
        }
    }
}

/// ViewModel for managing marker data and operations 
class MarkerViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var markers: [SceneMarker] = []
    @Published var filteredMarkers: [SceneMarker] = []
    @Published var isLoading: Bool = false
    @Published var isLoadingMore: Bool = false
    @Published var hasMorePages: Bool = true
    @Published var error: String? = nil
    @Published var availableTags: [StashScene.Tag] = []
    
    // MARK: - Private Properties
    private var currentPage: Int = 1
    private var visibleMarkers: Set<String> = []
    private var currentSortOption: MarkerSortOption = .timestamp
    private var currentTagFilter: String? = nil
    private var cancellables = Set<AnyCancellable>()
    private var sceneId: String? = nil
    private var performerId: String? = nil
    
    // MARK: - Methods for loading markers
    
    /// Load markers for a specific scene
    /// - Parameters:
    ///   - scene: The scene to load markers for
    ///   - api: The StashAPI instance to use
    func loadMarkers(for scene: StashScene, api: StashAPI) async {
        await MainActor.run {
            self.isLoading = true
            self.error = nil
            self.sceneId = scene.id
            self.performerId = nil
            self.currentPage = 1
            self.hasMorePages = true
        }
        
        // Since fetchSceneMarkers doesn't exist, we'll use a direct GraphQL query
        do {
            let query = """
            {
                "operationName": "FindSceneMarkers",
                "variables": {
                    "filter": {
                        "q": "",
                        "page": 1,
                        "per_page": 100,
                        "sort": "timestamp",
                        "direction": "ASC"
                    }, 
                    "scene_marker_filter": {
                        "scene_ids": {
                            "value": ["\(scene.id)"],
                            "modifier": "INCLUDES"
                        }
                    }
                },
                "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count markers { id title seconds stream scene { id name date created_at title studio { id name } performers { id name } files { height width duration } galleries { id } } preview tags { id name } primary_tag { id name } screenshot } } }"
            }
            """
            
            let data = try await api.executeGraphQLQuery(query)
            
            struct MarkersResponseData: Decodable {
                let data: MarkerData
                
                struct MarkerData: Decodable {
                    let findSceneMarkers: MarkersPayload
                    
                    struct MarkersPayload: Decodable {
                        let count: Int
                        let markers: [SceneMarker]
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkersResponseData.self, from: data)
            let loadedMarkers = response.data.findSceneMarkers.markers
            
            // Extract all tags from markers for filtering
            var tags = Set<StashScene.Tag>()
            
            for marker in loadedMarkers {
                // Add primary tag - it's non-optional in the model
                let primaryTag = marker.primary_tag
                let stashTag = StashScene.Tag(id: primaryTag.id, name: primaryTag.name)
                tags.insert(stashTag)
                
                // Add other tags
                for tag in marker.tags {
                    let stashTag = StashScene.Tag(id: tag.id, name: tag.name)
                    tags.insert(stashTag)
                }
            }
            
            await MainActor.run {
                self.markers = loadedMarkers
                self.filteredMarkers = loadedMarkers
                self.availableTags = Array(tags).sorted { $0.name < $1.name }
                self.isLoading = false
                self.hasMorePages = loadedMarkers.count >= 100 // Assuming 100 per page
            }
        } catch {
            await MainActor.run {
                self.error = error.localizedDescription
                self.isLoading = false
            }
            print("Error loading markers: \(error)")
        }
    }
    
    /// Load markers for a specific performer
    /// - Parameters:
    ///   - performer: The performer to load markers for
    ///   - api: The StashAPI instance to use
    func loadMarkers(for performer: StashScene.Performer, api: StashAPI) async {
        print("üß© DEBUG MARKERVM: Loading markers for performer \(performer.name) (ID: \(performer.id))")
        
        await MainActor.run {
            self.isLoading = true
            self.error = nil
            self.performerId = performer.id
            self.sceneId = nil
            self.currentPage = 1
            self.hasMorePages = true
        }
        
        do {
            print("üß© DEBUG MARKERVM: Using direct GraphQL query for performer markers")
            
            // Generate a random seed for random sorting
            let randomSeed = Int.random(in: 100000...999999)
            
            // Build the GraphQL query as a proper dictionary first
            let graphQLBody: [String: Any] = [
                "operationName": "FindSceneMarkers",
                "variables": [
                    "filter": [
                        "page": 1, 
                        "per_page": 40, 
                        "sort": "random_\(randomSeed)", 
                        "direction": "ASC"
                    ],
                    "scene_marker_filter": [
                        "performers": [
                            "value": [performer.id],
                            "modifier": "INCLUDES_ALL"  // Critical: This modifier ensures filtering works
                        ]
                    ]
                ],
                "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title files { width height path } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
            ]
            
            // Let JSON encoder handle serialization
            let jsonData = try JSONSerialization.data(withJSONObject: graphQLBody, options: [])
            let query = String(data: jsonData, encoding: .utf8) ?? "{}"
            
            // Log the full JSON body to verify structure
            print("üì§ MARKERVM: Full GraphQL request body:")
            print(query)
            
            // Verify the request contains the critical elements
            if query.contains(performer.id) && query.contains("INCLUDES_ALL") && query.contains("scene_marker_filter") {
                print("‚úÖ MARKERVM: Request contains performer ID, INCLUDES_ALL modifier, and scene_marker_filter")
            } else {
                print("‚ùå ERROR: Request missing critical elements!")
                if !query.contains(performer.id) { print("- Missing performer ID") }
                if !query.contains("INCLUDES_ALL") { print("- Missing INCLUDES_ALL modifier") }
                if !query.contains("scene_marker_filter") { print("- Missing scene_marker_filter") }
            }
            
            print("üß© DEBUG MARKERVM: Executing GraphQL query with INCLUDES_ALL modifier")
            let data = try await api.executeGraphQLQuery(query)
            
            // Define new response structure to match the different API response
            struct MarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindMarkers
                }
                let data: Data
            }
            
            let response = try JSONDecoder().decode(MarkersResponse.self, from: data)
            let loadedMarkers = response.data.findSceneMarkers.scene_markers
            
            print("üß© DEBUG MARKERVM: Received \(loadedMarkers.count) markers from API")
            
            // Debug marker details for performer validation
            if !loadedMarkers.isEmpty {
                print("üß© DEBUG MARKERVM: Checking first few markers for performer...")
                var validMarkers = 0
                
                for (index, marker) in loadedMarkers.prefix(5).enumerated() {
                    print("  [\(index)] Marker: \(marker.title) (ID: \(marker.id))")
                    var hasTargetPerformer = false
                    
                    if let performers = marker.scene.performers {
                        print("    Has \(performers.count) performers in scene")
                        
                        for scenePerformer in performers {
                            print("    - Performer: \(scenePerformer.name) (ID: \(scenePerformer.id))")
                            
                            if scenePerformer.id == performer.id {
                                print("    ‚úì MATCH: Contains target performer \(performer.name)")
                                hasTargetPerformer = true
                                validMarkers += 1
                                break
                            }
                        }
                    } else {
                        print("    ‚ö†Ô∏è Warning: No performers in scene!")
                    }
                    
                    if !hasTargetPerformer {
                        print("    ‚ùå ERROR: Does NOT contain target performer \(performer.name)!")
                    }
                }
                
                print("üß© DEBUG MARKERVM: \(validMarkers) out of \(min(5, loadedMarkers.count)) checked markers have the performer")
            }
            
            // Extract all tags from markers for filtering
            var tags = Set<StashScene.Tag>()
            
            for marker in loadedMarkers {
                // Add primary tag - it's non-optional in the model
                let primaryTag = marker.primary_tag
                let stashTag = StashScene.Tag(id: primaryTag.id, name: primaryTag.name)
                tags.insert(stashTag)
                
                // Add other tags
                for tag in marker.tags {
                    let stashTag = StashScene.Tag(id: tag.id, name: tag.name)
                    tags.insert(stashTag)
                }
            }
            
            await MainActor.run {
                self.markers = loadedMarkers
                self.filteredMarkers = loadedMarkers
                self.availableTags = Array(tags).sorted { $0.name < $1.name }
                self.isLoading = false
                self.hasMorePages = loadedMarkers.count >= 20 // Assuming default page size of 20
                
                print("üß© DEBUG MARKERVM: Updated state with \(self.markers.count) markers")
            }
        } catch {
            print("‚ùå DEBUG MARKERVM ERROR: Error loading markers for performer: \(error)")
            await MainActor.run {
                self.error = error.localizedDescription
                self.isLoading = false
            }
        }
    }
    
    /// Load all markers
    /// - Parameter api: The StashAPI instance to use
    func loadAllMarkers(api: StashAPI) async {
        await MainActor.run {
            self.isLoading = true
            self.error = nil
            self.sceneId = nil
            self.performerId = nil
            self.currentPage = 1
            self.hasMorePages = true
        }
        
        // Since fetchAllMarkers doesn't exist, we'll use a direct GraphQL query
        do {
            let query = """
            {
                "operationName": "FindSceneMarkers",
                "variables": {
                    "filter": {
                        "q": "",
                        "page": 1,
                        "per_page": 40,
                        "sort": "created_at",
                        "direction": "DESC"
                    }
                },
                "query": "query FindSceneMarkers($filter: FindFilterType) { findSceneMarkers(filter: $filter) { count markers { id title seconds stream scene { id name date created_at title studio { id name } performers { id name } files { height width duration } galleries { id } } preview tags { id name } primary_tag { id name } screenshot } } }"
            }
            """
            
            let data = try await api.executeGraphQLQuery(query)
            
            struct MarkersResponseData: Decodable {
                let data: MarkerData
                
                struct MarkerData: Decodable {
                    let findSceneMarkers: MarkersPayload
                    
                    struct MarkersPayload: Decodable {
                        let count: Int
                        let markers: [SceneMarker]
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkersResponseData.self, from: data)
            let loadedMarkers = response.data.findSceneMarkers.markers
            
            // Extract all tags from markers for filtering
            var tags = Set<StashScene.Tag>()
            
            for marker in loadedMarkers {
                // Add primary tag - it's non-optional in the model
                let primaryTag = marker.primary_tag
                let stashTag = StashScene.Tag(id: primaryTag.id, name: primaryTag.name)
                tags.insert(stashTag)
                
                // Add other tags
                for tag in marker.tags {
                    let stashTag = StashScene.Tag(id: tag.id, name: tag.name)
                    tags.insert(stashTag)
                }
            }
            
            await MainActor.run {
                self.markers = loadedMarkers
                self.filteredMarkers = loadedMarkers
                self.availableTags = Array(tags).sorted { $0.name < $1.name }
                self.isLoading = false
                self.hasMorePages = loadedMarkers.count >= 40 // Assuming 40 per page
            }
        } catch {
            await MainActor.run {
                self.error = error.localizedDescription
                self.isLoading = false
            }
            print("Error loading all markers: \(error)")
        }
    }
    
    /// Load more markers for pagination
    func loadMoreMarkers() async {
        guard !isLoadingMore, hasMorePages else { return }
        
        await MainActor.run {
            self.isLoadingMore = true
            self.currentPage += 1
        }
        
        if let performerId = performerId {
            // Using performer markers
            await loadMorePerformerMarkers(performerId: performerId)
        } else if let sceneId = sceneId {
            // Using scene markers
            await loadMoreSceneMarkers(sceneId: sceneId)
        } else {
            // Loading all markers
            await loadMoreAllMarkers()
        }
    }
    
    // MARK: - Helper methods for loading more markers
    
    private func loadMorePerformerMarkers(performerId: String) async {
        do {
            let api = StashAPI.shared ?? StashAPI(serverAddress: "", apiKey: "")
            
            // Generate a random seed for random sorting
            let randomSeed = Int.random(in: 100000...999999)
            
            // Use the same dictionary-based approach for pagination
            let graphQLBody: [String: Any] = [
                "operationName": "FindSceneMarkers",
                "variables": [
                    "filter": [
                        "page": currentPage, 
                        "per_page": 40, 
                        "sort": "random_\(randomSeed)", 
                        "direction": "ASC"
                    ],
                    "scene_marker_filter": [
                        "performers": [
                            "value": [performerId],
                            "modifier": "INCLUDES_ALL"  // Critical: This modifier ensures filtering works
                        ]
                    ]
                ],
                "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title files { width height path } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
            ]
            
            // Let JSON encoder handle serialization
            let jsonData = try JSONSerialization.data(withJSONObject: graphQLBody, options: [])
            let query = String(data: jsonData, encoding: .utf8) ?? "{}"
            
            // Log the pagination query for debugging
            print("üì§ MARKERVM PAGINATION: Page \(currentPage) query for performer \(performerId)")
            
            // Execute the GraphQL query
            let data = try await api.executeGraphQLQuery(query)
            
            // Define new response structure to match the API response
            struct MarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindMarkers
                }
                let data: Data
            }
            
            let response = try JSONDecoder().decode(MarkersResponse.self, from: data)
            let newMarkers = response.data.findSceneMarkers.scene_markers
            
            await MainActor.run {
                self.hasMorePages = !newMarkers.isEmpty
                
                // Filter out duplicates
                let newUniqueMarkers = newMarkers.filter { newMarker in
                    !self.markers.contains { $0.id == newMarker.id }
                }
                
                print("üìä PAGINATION: Found \(newMarkers.count) markers on page \(currentPage), \(newUniqueMarkers.count) are unique")
                
                self.markers.append(contentsOf: newUniqueMarkers)
                
                // Apply filtering if needed
                if let tagId = self.currentTagFilter {
                    self.filterMarkersByTag(tagId: tagId)
                } else {
                    self.filteredMarkers = self.markers
                }
                
                self.sortMarkers(by: self.currentSortOption)
                self.isLoadingMore = false
            }
        } catch {
            await MainActor.run {
                self.error = error.localizedDescription
                self.isLoadingMore = false
                self.hasMorePages = false
            }
            print("‚ùå ERROR loading more performer markers: \(error)")
        }
    }
    
    private func loadMoreSceneMarkers(sceneId: String) async {
        // Direct GraphQL query for pagination with scene id
        do {
            let api = StashAPI.shared ?? StashAPI(serverAddress: "", apiKey: "")
            
            let query = """
            {
                "operationName": "FindSceneMarkers",
                "variables": {
                    "filter": {
                        "q": "",
                        "page": \(currentPage),
                        "per_page": 40,
                        "sort": "timestamp",
                        "direction": "ASC"
                    },
                    "scene_marker_filter": {
                        "scene_ids": {
                            "value": ["\(sceneId)"],
                            "modifier": "INCLUDES"
                        }
                    }
                },
                "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count markers { id title seconds stream scene { id name date created_at title studio { id name } performers { id name } files { height width duration } galleries { id } } preview tags { id name } primary_tag { id name } screenshot } } }"
            }
            """
            
            let data = try await api.executeGraphQLQuery(query)
            
            struct MarkersResponseData: Decodable {
                let data: MarkerData
                
                struct MarkerData: Decodable {
                    let findSceneMarkers: MarkersPayload
                    
                    struct MarkersPayload: Decodable {
                        let count: Int
                        let markers: [SceneMarker]
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkersResponseData.self, from: data)
            let newMarkers = response.data.findSceneMarkers.markers
            
            await MainActor.run {
                self.hasMorePages = !newMarkers.isEmpty
                
                // Filter out duplicates
                let newUniqueMarkers = newMarkers.filter { newMarker in
                    !self.markers.contains { $0.id == newMarker.id }
                }
                
                self.markers.append(contentsOf: newUniqueMarkers)
                
                // Apply filtering if needed
                if let tagId = self.currentTagFilter {
                    self.filterMarkersByTag(tagId: tagId)
                } else {
                    self.filteredMarkers = self.markers
                }
                
                self.sortMarkers(by: self.currentSortOption)
                self.isLoadingMore = false
            }
        } catch {
            await MainActor.run {
                self.error = error.localizedDescription
                self.isLoadingMore = false
                self.hasMorePages = false
            }
        }
    }
    
    private func loadMoreAllMarkers() async {
        // Direct GraphQL query for pagination of all markers
        do {
            let api = StashAPI.shared ?? StashAPI(serverAddress: "", apiKey: "")
            
            let query = """
            {
                "operationName": "FindSceneMarkers",
                "variables": {
                    "filter": {
                        "q": "",
                        "page": \(currentPage),
                        "per_page": 40,
                        "sort": "created_at",
                        "direction": "DESC"
                    }
                },
                "query": "query FindSceneMarkers($filter: FindFilterType) { findSceneMarkers(filter: $filter) { count markers { id title seconds stream scene { id name date created_at title studio { id name } performers { id name } files { height width duration } galleries { id } } preview tags { id name } primary_tag { id name } screenshot } } }"
            }
            """
            
            let data = try await api.executeGraphQLQuery(query)
            
            struct MarkersResponseData: Decodable {
                let data: MarkerData
                
                struct MarkerData: Decodable {
                    let findSceneMarkers: MarkersPayload
                    
                    struct MarkersPayload: Decodable {
                        let count: Int
                        let markers: [SceneMarker]
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkersResponseData.self, from: data)
            let newMarkers = response.data.findSceneMarkers.markers
            
            await MainActor.run {
                self.hasMorePages = !newMarkers.isEmpty
                
                // Filter out duplicates
                let newUniqueMarkers = newMarkers.filter { newMarker in
                    !self.markers.contains { $0.id == newMarker.id }
                }
                
                self.markers.append(contentsOf: newUniqueMarkers)
                
                // Apply filtering if needed
                if let tagId = self.currentTagFilter {
                    self.filterMarkersByTag(tagId: tagId)
                } else {
                    self.filteredMarkers = self.markers
                }
                
                self.sortMarkers(by: self.currentSortOption)
                self.isLoadingMore = false
            }
        } catch {
            await MainActor.run {
                self.error = error.localizedDescription
                self.isLoadingMore = false
                self.hasMorePages = false
            }
        }
    }
    
    // MARK: - Filtering & Sorting
    
    /// Reset the tag filter to show all markers
    func resetTagFilter() {
        self.currentTagFilter = nil
        self.filteredMarkers = self.markers
        self.sortMarkers(by: self.currentSortOption)
    }
    
    /// Filter markers by a specific tag ID
    /// - Parameter tagId: The tag ID to filter by
    func filterMarkersByTag(tagId: String) {
        self.currentTagFilter = tagId
        
        self.filteredMarkers = self.markers.filter { marker in
            // Check primary tag - it's non-optional in the model
            let primaryTag = marker.primary_tag
            if primaryTag.id == tagId {
                return true
            }
            
            // Check other tags
            return marker.tags.contains { $0.id == tagId }
        }
        
        self.sortMarkers(by: self.currentSortOption)
    }
    
    /// Sort markers by the specified option
    /// - Parameter option: The sort option to use
    func sortMarkers(by option: MarkerSortOption) {
        self.currentSortOption = option
        
        switch option {
        case .timestamp:
            self.filteredMarkers.sort(by: { marker1, marker2 in
                return marker1.seconds < marker2.seconds
            })
        case .title:
            self.filteredMarkers.sort(by: { marker1, marker2 in
                return marker1.title.localizedCaseInsensitiveCompare(marker2.title) == .orderedAscending
            })
        case .createdAtDesc:
            self.filteredMarkers.sort(by: { marker1, marker2 in
                // Since MarkerScene doesn't have created_at, use ID as a fallback
                // IDs are often sequential and can approximate creation order
                return marker1.id > marker2.id
            })
        case .createdAtAsc:
            self.filteredMarkers.sort(by: { marker1, marker2 in
                // Since MarkerScene doesn't have created_at, use ID as a fallback
                return marker1.id < marker2.id
            })
        case .sceneTitleAsc:
            self.filteredMarkers.sort(by: { marker1, marker2 in
                return (marker1.scene.title ?? "").localizedCaseInsensitiveCompare(marker2.scene.title ?? "") == .orderedAscending
            })
        case .sceneTitleDesc:
            self.filteredMarkers.sort(by: { marker1, marker2 in
                return (marker1.scene.title ?? "").localizedCaseInsensitiveCompare(marker2.scene.title ?? "") == .orderedDescending
            })
        }
    }
}

================
File: stash/ViewModels/VideoPlayerViewModel.swift
================
import AVKit
import SwiftUI

class VideoPlayerViewModel: NSObject, ObservableObject {
    let player = AVPlayer()
    @Published var isLoading = true
    @Published var error: String?
    @Published var useHLS = true
    @Published var isPlaying = false
    @Published var currentTime: Double = 0
    @Published var duration: Double = 0
    @Published var bufferingProgress: Double = 0

    private var timeObserver: Any?
    private var statusObserver: NSKeyValueObservation?
    private var bufferingObserver: NSKeyValueObservation?
    private var playerItem: AVPlayerItem?
    private var playToEndObserver: NSObjectProtocol?
    private var failedToPlayObserver: NSObjectProtocol?

    override init() {
        super.init()
        setupPlayer()

        // Register with GlobalVideoManager
        GlobalVideoManager.shared.registerPlayer(player)
    }

    private func setupPlayer() {
        try? AVAudioSession.sharedInstance().setCategory(.playback, mode: .moviePlayback)
        try? AVAudioSession.sharedInstance().setActive(true)

        player.allowsExternalPlayback = true
        player.usesExternalPlaybackWhileExternalScreenIsActive = true
        player.automaticallyWaitsToMinimizeStalling = true

        // Add periodic time observer
        timeObserver = player.addPeriodicTimeObserver(
            forInterval: CMTime(seconds: 0.5, preferredTimescale: 600),
            queue: .main
        ) { [weak self] time in
            guard let self = self else { return }
            self.isLoading = false
            self.currentTime = time.seconds

            // Update isPlaying state based on player state
            self.isPlaying = self.player.timeControlStatus == .playing
        }

        // Add play to end notification observer
        playToEndObserver = NotificationCenter.default.addObserver(
            forName: .AVPlayerItemDidPlayToEndTime,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            guard let self = self else { return }
            self.isPlaying = false

            // Seek back to beginning
            self.player.seek(to: .zero) { _ in
                self.isPlaying = false
            }
        }

        // Add failed to play notification observer
        failedToPlayObserver = NotificationCenter.default.addObserver(
            forName: .AVPlayerItemFailedToPlayToEndTime,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            guard let self = self else { return }
            if let error = notification.userInfo?[AVPlayerItemFailedToPlayToEndTimeErrorKey] as? Error {
                self.error = error.localizedDescription
                print("‚ùå Failed to play: \(error.localizedDescription)")
            }
        }
    }

    func setupPlayerItem(with url: URL) {
        // Create new player item
        let options = [
            "AVURLAssetHTTPHeaderFieldsKey": [
                "Accept": "*/*",
                "Accept-Language": "en-US,en;q=0.9",
                "Connection": "keep-alive",
                "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X)",
                "Accept-Encoding": "identity",  // Request uncompressed content
            ],
            "AVURLAssetHTTPUserAgentKey": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X)"
        ] as [String : Any]

        let asset = AVURLAsset(url: url, options: options)
        playerItem = AVPlayerItem(asset: asset)

        // Configure for better streaming
        playerItem?.canUseNetworkResourcesForLiveStreamingWhilePaused = true
        playerItem?.preferredForwardBufferDuration = 10

        // Observe player item status
        statusObserver = playerItem?.observe(\.status, options: [.new, .initial]) { [weak self] item, _ in
            guard let self = self else { return }

            DispatchQueue.main.async {
                switch item.status {
                case .readyToPlay:
                    self.isLoading = false
                    self.duration = item.duration.seconds
                    self.error = nil
                    print("‚úÖ Player ready to play")

                case .failed:
                    self.isLoading = false
                    self.error = item.error?.localizedDescription ?? "Unknown error"
                    print("‚ùå Player item failed: \(self.error ?? "Unknown error")")

                case .unknown:
                    self.isLoading = true
                    print("‚è≥ Player item status unknown")

                @unknown default:
                    self.isLoading = false
                }
            }
        }

        // Observe buffering progress
        bufferingObserver = playerItem?.observe(\.loadedTimeRanges, options: [.new]) { [weak self] item, _ in
            guard let self = self else { return }

            // Calculate buffering progress
            if let timeRange = item.loadedTimeRanges.first?.timeRangeValue,
               item.duration.seconds > 0 {
                let bufferedSeconds = timeRange.start.seconds + timeRange.duration.seconds
                let progress = bufferedSeconds / item.duration.seconds
                self.bufferingProgress = min(max(0, progress), 1.0)
            }
        }

        // Replace current item
        player.replaceCurrentItem(with: playerItem)
    }

    func play() {
        player.play()
        isPlaying = true

        // Pause other players
        GlobalVideoManager.shared.pauseAllExcept(player)
    }

    func pause() {
        player.pause()
        isPlaying = false
    }

    func togglePlayback() {
        if isPlaying {
            pause()
        } else {
            play()
        }
    }

    func mute(_ muted: Bool) {
        player.isMuted = muted
    }

    func cleanup() {
        player.pause()

        if let observer = timeObserver {
            player.removeTimeObserver(observer)
            timeObserver = nil
        }

        // Remove KVO observers
        statusObserver?.invalidate()
        statusObserver = nil

        bufferingObserver?.invalidate()
        bufferingObserver = nil

        // Remove notification observers
        if let playToEndObserver = playToEndObserver {
            NotificationCenter.default.removeObserver(playToEndObserver)
            self.playToEndObserver = nil
        }

        if let failedToPlayObserver = failedToPlayObserver {
            NotificationCenter.default.removeObserver(failedToPlayObserver)
            self.failedToPlayObserver = nil
        }

        // Remove player item
        playerItem = nil
        player.replaceCurrentItem(with: nil)

        // Unregister from GlobalVideoManager
        GlobalVideoManager.shared.unregisterPlayer(player)
    }

    deinit {
        cleanup()
    }
}

================
File: stash/Views/Connection/ConnectionView.swift
================
import SwiftUI
import os.log

struct ConnectionView: View {
    @Binding var serverAddress: String
    @Binding var isConnected: Bool
    @State private var isAttemptingConnection = false
    @State private var showError = false
    @State private var errorMessage = ""
    
    var body: some View {
        ZStack {
            VStack(spacing: 20) {
                Image(systemName: "server.rack")
                    .font(.system(size: 60))
                    .foregroundColor(.accentColor)
                
                Text("Connect to Stash Server")
                    .font(.title2)
                    .fontWeight(.semibold)
                
                VStack(alignment: .leading, spacing: 16) {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Server Address")
                            .foregroundColor(.secondary)
                        TextField("192.168.86.100:9999", text: $serverAddress)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .autocapitalization(.none)
                            .disableAutocorrection(true)
                            .keyboardType(.URL)
                        Text("Example: 192.168.86.100:9999 or localhost:9999")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .frame(maxWidth: 300)
                .padding(.horizontal)
                
                Button(action: attemptConnection) {
                    if isAttemptingConnection {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                    } else {
                        Text("Connect")
                            .frame(minWidth: 200)
                    }
                }
                .buttonStyle(.borderedProminent)
                .disabled(serverAddress.isEmpty || isAttemptingConnection)
                .controlSize(.large)
            }
            .padding()
            
            VStack {
                Spacer()
                HStack {
                    Spacer()
                    Text("v1.4")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .padding()
                }
            }
        }
        .alert("Connection Error", isPresented: $showError) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(errorMessage)
        }
    }
    
    private func attemptConnection() {
        guard !serverAddress.isEmpty else { return }
        
        var address = serverAddress
        if !address.hasPrefix("http://") && !address.hasPrefix("https://") {
            address = "http://" + address
        }
        if !address.contains(":9999") && !address.contains(":443") {
            if address.hasSuffix("/") {
                address.removeLast()
            }
            address += ":9999"
        }
        
        Logger.connection.info("üîÑ Attempting connection to: \(address)")
        
        guard let url = URL(string: address) else {
            Logger.connection.error("‚ùå Invalid server address: \(address)")
            errorMessage = "Invalid server address"
            showError = true
            return
        }
        
        isAttemptingConnection = true
        
        var request = URLRequest(url: url.appendingPathComponent("graphql"))
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let query = """
        {
            "query": "{ stats { scene_count } }"
        }
        """
        
        request.httpBody = query.data(using: .utf8)
        
        Task {
            do {
                let (data, response) = try await URLSession.shared.data(for: request)
                
                await MainActor.run {
                    guard let httpResponse = response as? HTTPURLResponse else {
                        Logger.connection.error("‚ùå Invalid response type")
                        errorMessage = "Invalid response type"
                        showError = true
                        isAttemptingConnection = false
                        return
                    }
                    
                    switch httpResponse.statusCode {
                    case 200:
                        Logger.connection.info("‚úÖ Successfully connected to server")
                        UserDefaults.standard.set(address, forKey: "serverAddress")
                        isConnected = true
                    case 401:
                        Logger.connection.error("üîí Authentication required")
                        errorMessage = "Authentication required"
                        showError = true
                    case 422:
                        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                           let errors = json["errors"] as? [[String: Any]],
                           let firstError = errors.first?["message"] as? String {
                            Logger.connection.error("‚ùå GraphQL Error: \(firstError)")
                            errorMessage = "GraphQL Error: \(firstError)"
                        } else {
                            Logger.connection.error("‚ùå Invalid query format")
                            errorMessage = "Invalid query format"
                        }
                        showError = true
                    default:
                        Logger.connection.error("‚ùå Server returned error: \(httpResponse.statusCode)")
                        errorMessage = "Server returned error: \(httpResponse.statusCode)"
                        showError = true
                    }
                    
                    isAttemptingConnection = false
                }
            } catch {
                await MainActor.run {
                    Logger.connection.error("‚ùå Connection failed: \(error.localizedDescription)")
                    errorMessage = "Connection failed: \(error.localizedDescription)"
                    showError = true
                    isAttemptingConnection = false
                }
            }
        }
    }
}

================
File: stash/Views/Connection/EnhancedConnectionView.swift
================
import SwiftUI
import os.log
import UIKit

struct EnhancedConnectionView: View {
    @EnvironmentObject private var appModel: AppModel
    @State private var showAdvancedOptions = false
    @FocusState private var isAddressFieldFocused: Bool
    
    var body: some View {
        ZStack {
            // Background gradient
            LinearGradient(
                gradient: Gradient(colors: [Color.black, Color(UIColor.systemBackground)]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
            
            VStack(spacing: 25) {
                // Logo area
                VStack(spacing: 15) {
                    Image(systemName: "play.rectangle.fill")
                        .font(.system(size: 80))
                        .foregroundStyle(.linearGradient(
                            colors: [.blue, .purple],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                        .symbolEffect(.pulse)
                    
                    Text("Stash")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.primary)
                    
                    Text("Connect to your media server")
                        .font(.headline)
                        .foregroundColor(.secondary)
                }
                .padding(.top, 50)
                
                // Connection form
                VStack(spacing: 20) {
                    connectionForm
                    
                    HStack {
                        Spacer()
                        
                        Button(action: {
                            withAnimation {
                                showAdvancedOptions.toggle()
                            }
                        }) {
                            Text(showAdvancedOptions ? "Hide Advanced" : "Advanced Options")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding(.horizontal)
                    
                    if showAdvancedOptions {
                        advancedOptions
                            .transition(.move(edge: .top).combined(with: .opacity))
                    }
                    
                    // Button area
                    connectButton
                }
                .frame(maxWidth: 350)
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 15)
                        .fill(Color(UIColor.secondarySystemBackground))
                        .shadow(radius: 5)
                )
                
                Spacer()
                
                // Version number
                Text("v2.0")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .padding(.bottom, 10)
            }
            .padding()
        }
        .alert("Connection Error", isPresented: .init(
            get: { appModel.connectionError != nil },
            set: { if !$0 { appModel.connectionError = nil } }
        )) {
            Button("OK", role: .cancel) { }
        } message: {
            if let error = appModel.connectionError {
                Text(error)
            }
        }
        .onAppear {
            isAddressFieldFocused = true
        }
    }
    
    // Connection form
    private var connectionForm: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Server Address")
                .font(.headline)
                .foregroundColor(.secondary)
            
            HStack {
                Image(systemName: "server.rack")
                    .foregroundColor(.secondary)
                
                TextField("192.168.1.100:9999", text: $appModel.serverAddress)
                    .keyboardType(.URL)
                    .autocorrectionDisabled()
                    .textInputAutocapitalization(.never)
                    .focused($isAddressFieldFocused)
                    .onSubmit {
                        appModel.attemptConnection()
                    }
                
                if !appModel.serverAddress.isEmpty {
                    Button(action: { appModel.serverAddress = "" }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding(12)
            .background(Color(UIColor.systemBackground))
            .cornerRadius(10)
            
            Text("Example: 192.168.1.100:9999 or localhost:9999")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.horizontal)
    }
    
    // Advanced options
    private var advancedOptions: some View {
        VStack(alignment: .leading, spacing: 15) {
            VStack(alignment: .leading, spacing: 8) {
                Text("API Key (Optional)")
                    .font(.headline)
                    .foregroundColor(.secondary)
                
                TextField("API Key", text: $appModel.apiKey)
                    .autocorrectionDisabled()
                    .textInputAutocapitalization(.never)
                    .padding(12)
                    .background(Color(UIColor.systemBackground))
                    .cornerRadius(10)
                    .font(.system(.body, design: .monospaced))
            }
            
            Divider()
                .padding(.vertical, 5)
            
            Toggle("Remember Connection", isOn: .constant(true))
                .font(.subheadline)
            
            Toggle("Use HTTPS", isOn: .constant(false))
                .font(.subheadline)
            
            Toggle("Skip Certificate Validation", isOn: .constant(false))
                .font(.subheadline)
            
            Button(action: {
                Task {
                    await appModel.api.testConnection { _ in
                        // Handle completion
                    }
                }
            }) {
                Text("Test Connection")
                    .font(.subheadline)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 16)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.blue.opacity(0.2))
                    )
                    .foregroundColor(.blue)
            }
            .padding(.top, 5)
        }
        .padding(.horizontal)
    }
    
    // Connect button
    private var connectButton: some View {
        Button(action: appModel.attemptConnection) {
            HStack {
                if appModel.isAttemptingConnection {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .tint(.white)
                        .frame(width: 20, height: 20)
                    Text("Connecting...")
                } else {
                    Image(systemName: "arrow.right")
                    Text("Connect")
                }
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [Color.blue, Color.purple]),
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
            )
            .foregroundColor(.white)
            .bold()
            .shadow(radius: 3)
        }
        .disabled(appModel.serverAddress.isEmpty || appModel.isAttemptingConnection)
        .padding(.horizontal)
        .padding(.top, 10)
    }
}

#Preview {
    EnhancedConnectionView()
        .environmentObject(AppModel())
}

================
File: stash/Views/Filters/FilterMenuSheet.swift
================
import SwiftUI

struct FilterMenuSheet: View {
    @EnvironmentObject private var appModel: AppModel
    @State private var currentFilter: String = "default"
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            // Title
            Text("Sort Media Library")
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            // Filter options
            VStack(spacing: 16) {
                filterButton("Default Sort", systemImage: "rectangle.grid.2x2", filter: "default") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "file_mod_time", direction: "DESC")
                        dismiss()
                    }
                }
                
                filterButton("Newest Videos", systemImage: "clock", filter: "newest") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "date", direction: "DESC")
                        dismiss()
                    }
                }
                
                filterButton("Most Played", systemImage: "number.circle", filter: "o_counter") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "o_counter", direction: "DESC")
                        dismiss()
                    }
                }
                
                filterButton("Random Order", systemImage: "shuffle", filter: "random") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "random", direction: "DESC")
                        dismiss()
                    }
                }
                
                Divider()
            }
            .padding(.vertical, 8)
            
            Spacer()
            
            // Advanced filter button
            Button {
                // Cancel this sheet and show advanced filters
                dismiss()
                // The actual implementation would depend on how you handle advanced filters in your app
                NotificationCenter.default.post(name: Notification.Name("ShowAdvancedFilters"), object: nil)
            } label: {
                HStack {
                    Image(systemName: "slider.horizontal.3")
                    Text("Advanced Filters")
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
            }
        }
        .padding()
    }
    
    private func filterButton(_ title: String, systemImage: String, filter: String, action: @escaping () -> Void) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: systemImage)
                    .frame(width: 24, height: 24)
                
                Text(title)
                    .font(.body)
                
                Spacer()
                
                if currentFilter == filter {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .padding(.vertical, 8)
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    FilterMenuSheet()
        .environmentObject(AppModel())
}

================
File: stash/Views/Filters/FilterMenuView.swift
================
import SwiftUI

struct FilterMenuView: View {
    @Binding var currentFilter: String
    let onDefaultSelected: () -> Void
    let onNewestSelected: () -> Void
    let onOCounterSelected: () -> Void
    let onRandomSelected: () -> Void
    let onAdvancedFilters: () -> Void
    let onReload: () -> Void
    
    private var filterTitle: String {
        switch currentFilter {
        case "default": return "Default"
        case "newest": return "Newest"
        case "o_counter": return "O-Counter"
        case "random": return "Random"
        default: return "Filter"
        }
    }
    
    var body: some View {
        HStack(spacing: 8) {
            Menu {
                Picker("Sorting", selection: $currentFilter) {
                    Text("Default").tag("default")
                    Text("Newest").tag("newest")
                    Text("O-Counter").tag("o_counter")
                    Text("Random").tag("random")
                }
                .pickerStyle(InlinePickerStyle())
                .onChange(of: currentFilter) { newValue in
                    switch newValue {
                    case "default":
                        onDefaultSelected()
                    case "newest":
                        onNewestSelected()
                    case "o_counter":
                        onOCounterSelected()
                    case "random":
                        onRandomSelected()
                    default:
                        break
                    }
                }
                
                Divider()
                
                Button(action: onAdvancedFilters) {
                    Label("Advanced Filters", systemImage: "slider.horizontal.3")
                }
            } label: {
                HStack {
                    Text(filterTitle)
                    Image(systemName: "chevron.down")
                        .font(.caption)
                }
                .padding(8)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(8)
            }
            
            Button(action: onReload) {
                Image(systemName: "arrow.clockwise")
                    .padding(8)
                    .background(Color.secondary.opacity(0.1))
                    .cornerRadius(8)
            }
        }
    }
}

#Preview {
    FilterMenuView(
        currentFilter: .constant("default"),
        onDefaultSelected: {},
        onNewestSelected: {},
        onOCounterSelected: {},
        onRandomSelected: {},
        onAdvancedFilters: {},
        onReload: {}
    )
}

================
File: stash/Views/Filters/FilterOptionsView.swift
================
import SwiftUI

struct FilterOptionsView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appModel: AppModel
    @Binding var filterOptions: FilterOptions
    let onApply: () -> Void
    
    @State private var tempOptions = FilterOptions()
    @State private var selectedRating: Double = 0
    @State private var showingTagSelection = false
    @State private var showingPerformerSelection = false
    @State private var selectedResolutionIndex = 0
    
    private let resolutions = ["Any", "240p", "480p", "720p", "1080p", "4K"]
    private let durationOptions = [
        "Any": nil,
        "< 5 min": 300,
        "< 15 min": 900, 
        "< 30 min": 1800,
        "< 60 min": 3600,
        "> 5 min": 300,
        "> 15 min": 900,
        "> 30 min": 1800,
        "> 60 min": 3600
    ]
    
    var body: some View {
        NavigationStack {
            Group {
                if UIDevice.current.userInterfaceIdiom == .pad {
                    // Enhanced layout for iPad
                    VStack(spacing: 0) {
                        HStack(alignment: .top, spacing: 0) {
                            // Left column
                            List {
                                sortSection
                                ratingSection
                                resolutionSection
                                favoritesSection
                                durationSection
                            }
                            .frame(minWidth: 0, maxWidth: .infinity)
                            
                            // Right column
                            List {
                                tagsSection
                                performersSection
                            }
                            .frame(minWidth: 0, maxWidth: .infinity)
                        }
                    }
                } else {
                    // Standard layout for iPhone
                    List {
                        sortSection
                        ratingSection
                        resolutionSection
                        favoritesSection
                        durationSection
                        tagsSection
                        performersSection
                    }
                }
            }
            .navigationTitle("Filter Options")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button("Reset") {
                        tempOptions.reset()
                        selectedRating = 0
                    }
                }
                
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Apply") {
                        // Copy temp options to the binding
                        filterOptions.minimumRating = tempOptions.minimumRating
                        filterOptions.selectedResolution = tempOptions.selectedResolution
                        filterOptions.isFavoritesOnly = tempOptions.isFavoritesOnly
                        filterOptions.minimumDuration = tempOptions.minimumDuration
                        filterOptions.maximumDuration = tempOptions.maximumDuration
                        filterOptions.selectedTagIds = tempOptions.selectedTagIds
                        filterOptions.selectedPerformerIds = tempOptions.selectedPerformerIds
                        filterOptions.sortField = tempOptions.sortField
                        filterOptions.sortDirection = tempOptions.sortDirection
                        
                        onApply()
                        dismiss()
                    }
                }
            }
            .onAppear {
                // Initialize temp options from binding
                tempOptions.minimumRating = filterOptions.minimumRating
                tempOptions.selectedResolution = filterOptions.selectedResolution
                tempOptions.isFavoritesOnly = filterOptions.isFavoritesOnly
                tempOptions.minimumDuration = filterOptions.minimumDuration
                tempOptions.maximumDuration = filterOptions.maximumDuration
                tempOptions.selectedTagIds = filterOptions.selectedTagIds
                tempOptions.selectedPerformerIds = filterOptions.selectedPerformerIds
                tempOptions.sortField = filterOptions.sortField
                tempOptions.sortDirection = filterOptions.sortDirection
                
                // Set UI state
                selectedRating = Double(tempOptions.minimumRating ?? 0)
                
                // Set resolution index
                if let resolution = tempOptions.selectedResolution,
                   let index = resolutions.firstIndex(of: resolution) {
                    selectedResolutionIndex = index
                } else {
                    selectedResolutionIndex = 0
                }
            }
        }
        .sheet(isPresented: $showingTagSelection) {
            NavigationStack {
                TagSelectionListView(selectedTagIds: $tempOptions.selectedTagIds)
                    .environmentObject(appModel)
            }
        }
        .sheet(isPresented: $showingPerformerSelection) {
            NavigationStack {
                PerformerSelectionListView(selectedPerformerIds: $tempOptions.selectedPerformerIds)
                    .environmentObject(appModel)
            }
        }
    }
    
    // MARK: - Sections
    
    private var sortSection: some View {
        Section(header: Text("Sort By")) {
            Picker("Field", selection: $tempOptions.sortField) {
                Text("Date").tag("date")
                Text("Title").tag("title")
                Text("Rating").tag("rating")
                Text("Duration").tag("duration")
                Text("Random").tag("random")
            }
            .pickerStyle(.menu)
            
            Picker("Direction", selection: $tempOptions.sortDirection) {
                Text("Descending").tag("DESC")
                Text("Ascending").tag("ASC")
            }
            .pickerStyle(.menu)
        }
    }
    
    private var ratingSection: some View {
        Section(header: Text("Rating")) {
            VStack(alignment: .leading) {
                Text("Minimum Rating: \(Int(selectedRating))")
                    .font(.subheadline)
                
                Slider(value: $selectedRating, in: 0...100, step: 10) { changed in
                    if changed {
                        tempOptions.minimumRating = selectedRating > 0 ? Int(selectedRating) : nil
                    }
                }
                .onChange(of: selectedRating) { oldValue, newValue in
                    tempOptions.minimumRating = newValue > 0 ? Int(newValue) : nil
                }
            }
            .padding(.vertical, 8)
        }
    }
    
    private var resolutionSection: some View {
        Section(header: Text("Resolution")) {
            Picker("Select Resolution", selection: $selectedResolutionIndex) {
                ForEach(0..<resolutions.count, id: \.self) { index in
                    Text(resolutions[index]).tag(index)
                }
            }
            .pickerStyle(.menu)
            .onChange(of: selectedResolutionIndex) { oldValue, newValue in
                tempOptions.selectedResolution = newValue > 0 ? resolutions[newValue] : nil
            }
        }
    }
    
    private var favoritesSection: some View {
        Section {
            Toggle("Favorites Only", isOn: $tempOptions.isFavoritesOnly)
        }
    }
    
    private var durationSection: some View {
        Section(header: Text("Duration")) {
            Picker("Minimum Duration", selection: $tempOptions.minimumDuration) {
                ForEach(["Any", "> 5 min", "> 15 min", "> 30 min", "> 60 min"], id: \.self) { label in
                    Text(label).tag(durationOptions[label])
                }
            }
            .pickerStyle(.menu)
            
            Picker("Maximum Duration", selection: $tempOptions.maximumDuration) {
                ForEach(["Any", "< 5 min", "< 15 min", "< 30 min", "< 60 min"], id: \.self) { label in
                    Text(label).tag(durationOptions[label])
                }
            }
            .pickerStyle(.menu)
        }
    }
    
    private var tagsSection: some View {
        Section(header: Text("Tags")) {
            VStack(alignment: .leading) {
                if tempOptions.selectedTagIds.isEmpty {
                    Text("No tags selected")
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                } else {
                    Text("\(tempOptions.selectedTagIds.count) tags selected")
                        .padding(.vertical, 8)
                }
                
                Button(action: {
                    showingTagSelection = true
                }) {
                    Label("Select Tags", systemImage: "tag")
                        .frame(maxWidth: .infinity, alignment: .center)
                }
                .buttonStyle(.bordered)
            }
        }
    }
    
    private var performersSection: some View {
        Section(header: Text("Performers")) {
            VStack(alignment: .leading) {
                if tempOptions.selectedPerformerIds.isEmpty {
                    Text("No performers selected")
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                } else {
                    Text("\(tempOptions.selectedPerformerIds.count) performers selected")
                        .padding(.vertical, 8)
                }
                
                Button(action: {
                    showingPerformerSelection = true
                }) {
                    Label("Select Performers", systemImage: "person.2")
                        .frame(maxWidth: .infinity, alignment: .center)
                }
                .buttonStyle(.bordered)
            }
        }
    }
}

// MARK: - Preview
#Preview {
    NavigationStack {
        FilterOptionsView(
            filterOptions: .constant(FilterOptions()),
            onApply: {}
        )
        .environmentObject(AppModel())
    }
}

================
File: stash/Views/Filters/PerformerSelectionListView.swift
================
import SwiftUI

struct PerformerSelectionListView: View {
    @EnvironmentObject private var appModel: AppModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedPerformerIds: [String]
    @State private var searchText = ""
    @State private var allPerformers: [StashScene.Performer] = []
    @State private var isLoading = false
    
    private var columns: [GridItem] {
        // Use more columns and larger images on iPad
        if UIDevice.current.userInterfaceIdiom == .pad {
            return [
                GridItem(.adaptive(minimum: 150, maximum: 180), spacing: 20)
            ]
        } else {
            return [
                GridItem(.adaptive(minimum: 120, maximum: 160), spacing: 16)
            ]
        }
    }
    
    var body: some View {
        VStack {
            if selectedPerformerIds.isEmpty {
                Text("No performers selected")
                    .foregroundColor(.secondary)
                    .italic()
                    .padding()
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(selectedPerformers) { performer in
                            VStack {
                                if let imagePath = performer.image_path {
                                    AsyncImage(url: URL(string: imagePath)) { image in
                                        image
                                            .resizable()
                                            .aspectRatio(contentMode: .fill)
                                    } placeholder: {
                                        Color.gray
                                    }
                                    .frame(width: 60, height: 60)
                                    .clipShape(Circle())
                                } else {
                                    Circle()
                                        .fill(Color.gray.opacity(0.5))
                                        .frame(width: 60, height: 60)
                                        .overlay(
                                            Image(systemName: "person.fill")
                                                .foregroundColor(.white)
                                        )
                                }
                                
                                Text(performer.name)
                                    .font(.caption)
                                    .lineLimit(1)
                                
                                Button(action: {
                                    removePerformerId(performer.id)
                                }) {
                                    Image(systemName: "xmark.circle.fill")
                                        .foregroundColor(.red)
                                }
                                .buttonStyle(BorderlessButtonStyle())
                            }
                            .frame(width: 80)
                            .padding(.vertical, 8)
                        }
                    }
                    .padding(.horizontal)
                }
                .background(Color.secondary.opacity(0.1))
            }
            
            Divider()
            
            if isLoading {
                ProgressView()
                    .scaleEffect(1.2)
                    .padding()
            } else if filteredPerformers.isEmpty && !searchText.isEmpty {
                Text("No performers found")
                    .foregroundColor(.secondary)
                    .italic()
                    .padding()
            } else {
                ScrollView {
                    LazyVGrid(columns: columns, spacing: 16) {
                        ForEach(filteredPerformers) { performer in
                            Button(action: {
                                togglePerformerId(performer.id)
                            }) {
                                VStack {
                                    if let imagePath = performer.image_path {
                                        AsyncImage(url: URL(string: imagePath)) { image in
                                            image
                                                .resizable()
                                                .aspectRatio(contentMode: .fill)
                                        } placeholder: {
                                            Color.gray
                                        }
                                        .frame(width: UIDevice.current.userInterfaceIdiom == .pad ? 100 : 80, 
                                               height: UIDevice.current.userInterfaceIdiom == .pad ? 100 : 80)
                                        .clipShape(Circle())
                                        .overlay(
                                            Circle()
                                                .stroke(
                                                    selectedPerformerIds.contains(performer.id) ? Color.blue : Color.clear,
                                                    lineWidth: 3
                                                )
                                        )
                                    } else {
                                        Circle()
                                            .fill(Color.gray.opacity(0.5))
                                            .frame(width: UIDevice.current.userInterfaceIdiom == .pad ? 100 : 80, 
                                                   height: UIDevice.current.userInterfaceIdiom == .pad ? 100 : 80)
                                            .overlay(
                                                Image(systemName: "person.fill")
                                                    .foregroundColor(.white)
                                            )
                                            .overlay(
                                                Circle()
                                                    .stroke(
                                                        selectedPerformerIds.contains(performer.id) ? Color.blue : Color.clear,
                                                        lineWidth: 3
                                                    )
                                            )
                                    }
                                    
                                    Text(performer.name)
                                        .font(.caption)
                                        .lineLimit(1)
                                    
                                    if let count = performer.scene_count {
                                        Text("\(count) scenes")
                                            .font(.caption2)
                                            .foregroundColor(.secondary)
                                    }
                                    
                                    if selectedPerformerIds.contains(performer.id) {
                                        Image(systemName: "checkmark.circle.fill")
                                            .foregroundColor(.blue)
                                            .scaleEffect(1.2)
                                    }
                                }
                                .padding(.vertical, 8)
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                    .padding()
                }
            }
        }
        .navigationTitle("Select Performers")
        .searchable(text: $searchText, prompt: "Search performers...")
        .onChange(of: searchText) { _, newValue in
            Task {
                await searchPerformers(query: newValue)
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    dismiss()
                }
            }
        }
        .task {
            await loadPerformers()
        }
    }
    
    // Get the actual performer objects from the selected IDs
    private var selectedPerformers: [StashScene.Performer] {
        return allPerformers.filter { performer in
            selectedPerformerIds.contains(performer.id)
        }
    }
    
    private var filteredPerformers: [StashScene.Performer] {
        if searchText.isEmpty {
            return allPerformers
        } else {
            return allPerformers.filter { performer in
                performer.name.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    private func loadPerformers() async {
        isLoading = true
        await appModel.api.fetchPerformers(filter: .all, page: 1, appendResults: false, search: "", completion: { result in
            switch result {
            case .success(let performers):
                self.allPerformers = performers
            case .failure(let error):
                print("Error loading performers: \(error)")
            }
            self.isLoading = false
        })
    }
    
    private func searchPerformers(query: String) async {
        isLoading = true
        
        // TODO: Implement performer search API call
        // For now, we'll just filter locally
        isLoading = false
    }
    
    private func togglePerformerId(_ performerId: String) {
        if selectedPerformerIds.contains(performerId) {
            selectedPerformerIds.removeAll { $0 == performerId }
        } else {
            selectedPerformerIds.append(performerId)
        }
    }
    
    private func removePerformerId(_ performerId: String) {
        selectedPerformerIds.removeAll { $0 == performerId }
    }
}

#Preview {
    NavigationStack {
        PerformerSelectionListView(selectedPerformerIds: .constant([]))
            .environmentObject(AppModel())
    }
}

================
File: stash/Views/Filters/TagSelectionListView.swift
================
import SwiftUI

struct TagSelectionListView: View {
    @EnvironmentObject private var appModel: AppModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedTagIds: [String]
    @State private var searchText = ""
    @State private var allTags: [StashScene.Tag] = []
    @State private var isLoading = false
    
    var body: some View {
        List {
            Section(header: Text("Selected Tags (\(selectedTagIds.count))")) {
                if selectedTagIds.isEmpty {
                    Text("No tags selected")
                        .foregroundColor(.secondary)
                        .italic()
                } else {
                    ForEach(allTags.filter { tag in selectedTagIds.contains(tag.id) }) { tag in
                        HStack {
                            Text(tag.name)
                            Spacer()
                            Button(action: {
                                removeTagId(tag.id)
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .foregroundColor(.red)
                            }
                        }
                    }
                }
            }
            
            if isLoading {
                Section {
                    HStack {
                        Spacer()
                        ProgressView()
                            .scaleEffect(1.2)
                        Spacer()
                    }
                    .padding()
                }
            } else {
                Section(header: Text(searchText.isEmpty ? "All Tags" : "Search Results")) {
                    ForEach(filteredTags) { tag in
                        HStack {
                            Text(tag.name)
                            Spacer()
                            if selectedTagIds.contains(tag.id) {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            toggleTagId(tag.id)
                        }
                    }
                }
            }
        }
        .listStyle(.insetGrouped)
        .navigationTitle("Select Tags")
        .searchable(text: $searchText, prompt: "Search tags...")
        .onChange(of: searchText) { _, newValue in
            Task {
                await searchTags(query: newValue)
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    dismiss()
                }
            }
        }
        .task {
            await loadTags()
        }
    }
    
    private var filteredTags: [StashScene.Tag] {
        if searchText.isEmpty {
            return allTags
        } else {
            return allTags.filter { tag in
                tag.name.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    private func loadTags() async {
        isLoading = true
        do {
            try await appModel.api.searchTags(query: "") { result in
                switch result {
                case .success(let tags):
                    self.allTags = tags
                case .failure(let error):
                    print("Error loading tags: \(error)")
                }
                self.isLoading = false
            }
        } catch {
            print("Error loading tags: \(error)")
            isLoading = false
        }
    }
    
    private func searchTags(query: String) async {
        guard !query.isEmpty else {
            return
        }

        isLoading = true
        do {
            try await appModel.api.searchTags(query: query) { result in
                switch result {
                case .success(let tags):
                    self.allTags = tags
                case .failure(let error):
                    print("Error searching tags: \(error)")
                }
                self.isLoading = false
            }
        } catch {
            print("Error searching tags: \(error)")
            isLoading = false
        }
    }
    
    private func toggleTagId(_ tagId: String) {
        if selectedTagIds.contains(tagId) {
            selectedTagIds.removeAll { $0 == tagId }
        } else {
            selectedTagIds.append(tagId)
        }
    }
    
    private func removeTagId(_ tagId: String) {
        selectedTagIds.removeAll { $0 == tagId }
    }
}

#Preview {
    NavigationStack {
        TagSelectionListView(selectedTagIds: .constant([]))
            .environmentObject(AppModel())
    }
}

================
File: stash/Views/Markers/CreateMarkerView.swift
================
import SwiftUI
import Foundation

struct CreateMarkerView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.colorScheme) private var colorScheme
    @EnvironmentObject private var appModel: AppModel
    // No longer needed: @ObservedObject var api: StashAPI
    @State private var primaryTagId: String = ""
    @State private var primaryTagName: String = ""
    @State private var seconds: String
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showError = false
    @State private var showingTagSelection = false
    @State private var allTags: [StashScene.Tag] = []
    
    var sceneID: String {
        return appModel.api.sceneID ?? appModel.currentScene?.id ?? ""
    }
    
    let onMarkerCreated: () -> Void
    
    init(initialSeconds: String = "", sceneID: String = "", onMarkerCreated: @escaping () -> Void = {}) {
        if !sceneID.isEmpty {
            // We'll set this in .onAppear
        }
        
        let formattedSeconds = if let doubleValue = Double(initialSeconds) {
            String(format: "%.3f", doubleValue)
        } else {
            initialSeconds
        }
        self._seconds = State(initialValue: formattedSeconds)
        self.onMarkerCreated = onMarkerCreated
    }
    
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    HStack {
                        Text("Timestamp:")
                        Spacer()
                        Text(formatTimestamp(seconds))
                            .foregroundColor(.secondary)
                    }
                }
                
                Section {
                    Button(action: {
                        Task {
                            do {
                                allTags = try await appModel.api.searchTags(query: "")
                                showingTagSelection = true
                            } catch {
                                print("‚ùå Error loading tags: \(error)")
                            }
                        }
                    }) {
                        if primaryTagName.isEmpty {
                            Text("Select Primary Tag")
                                .foregroundColor(.accentColor)
                        } else {
                            Text(primaryTagName)
                                .foregroundColor(.accentColor)
                        }
                    }
                }
                
                Section {
                    Button(action: createMarker) {
                        if isLoading {
                            ProgressView()
                        } else {
                            Text("Create Marker")
                        }
                    }
                    .disabled(isLoading || !isValid)
                }
            }
            .navigationTitle("Create Marker")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .sheet(isPresented: $showingTagSelection) {
                NavigationStack {
                    TagSelectionView(
                        selectedTagId: $primaryTagId,
                        selectedTagName: $primaryTagName
                    )
                }
            }
            .alert("Error", isPresented: $showError, presenting: errorMessage) { _ in
                Button("OK", role: .cancel) { }
            } message: { error in
                Text(error)
            }
            .onAppear {
                if !sceneID.isEmpty {
                    appModel.api.sceneID = sceneID
                }
            }
        }
    }
    
    private func formatTimestamp(_ timestamp: String) -> String {
        guard let seconds = Double(timestamp) else { return timestamp }
        let minutes = Int(seconds / 60)
        let remainingSeconds = Int(seconds.truncatingRemainder(dividingBy: 60))
        let milliseconds = Int((seconds * 1000).truncatingRemainder(dividingBy: 1000))
        return String(format: "%02d:%02d.%03d", minutes, remainingSeconds, milliseconds)
    }
    
    private var isValid: Bool {
        print("üìç Validation check - seconds: \(seconds), sceneID: \(sceneID), primaryTagId: \(primaryTagId)")
        
        let hasSeconds = !seconds.isEmpty
        let hasSceneID = !sceneID.isEmpty
        let hasTagID = !primaryTagId.isEmpty
        
        print("üìç Validation details - hasSeconds: \(hasSeconds), hasSceneID: \(hasSceneID), hasTagID: \(hasTagID)")
        
        let isValid = hasSeconds && hasSceneID && hasTagID
        print("üìç Is valid: \(isValid)")
        return isValid
    }
    
    private func createMarker() {
        guard let secondsFloat = Float(seconds) else {
            errorMessage = "Invalid time format"
            showError = true
            return
        }
        
        guard !sceneID.isEmpty else {
            errorMessage = "No scene selected"
            showError = true
            return
        }
        
        guard !primaryTagId.isEmpty else {
            errorMessage = "Please select a tag"
            showError = true
            return
        }
        
        isLoading = true
        
        Task {
            do {
                print("Creating marker for scene: \(sceneID) at \(seconds) with tag: \(primaryTagId)")
                _ = try await appModel.api.createSceneMarker(
                    sceneId: sceneID,
                    title: primaryTagName,  // Use tag name as title
                    seconds: secondsFloat,
                    primaryTagId: primaryTagId,
                    tagIds: [], // Empty array for additional tags
                    completion: { _ in }
                )
                await MainActor.run {
                    onMarkerCreated()
                    dismiss()
                }
            } catch {
                print("‚ùå Error creating marker: \(error)")
                errorMessage = error.localizedDescription
                showError = true
                isLoading = false
            }
        }
    }
}

================
File: stash/Views/Markers/MarkerRow.swift
================
import SwiftUI
import AVKit
import Foundation
import ObjectiveC
import Combine

// Helper extension to find the topmost view controller
extension UIViewController {
    func topMostViewController() -> UIViewController {
        // If this controller is presenting another controller, recurse into that one
        if let presentedViewController = self.presentedViewController {
            return presentedViewController.topMostViewController()
        }
        
        // Handle different controller types
        if let navigationController = self as? UINavigationController {
            if let visibleViewController = navigationController.visibleViewController {
                return visibleViewController.topMostViewController()
            }
            return navigationController
        } else if let tabBarController = self as? UITabBarController {
            if let selectedViewController = tabBarController.selectedViewController {
                return selectedViewController.topMostViewController()
            }
            return tabBarController
        }
        
        // This is the top-most view controller
        return self
    }
}

// Using shared ScaleButtonStyle defined in AnimationModifiers.swift

// Observer for monitoring player item
class PlayerItemObserver: NSObject, ObservableObject {
    // Published properties to make this class ObservableObject compliant
    @Published var streamAttempts = 0
    @Published var isBufferEmpty = false
    @Published var isPlaybackLikely = true
    
    // Callback handlers
    var onStreamingToggle: ((Bool) -> Void)?
    var onBufferEmpty: (() -> Void)?
    
    // Track which objects and keypaths we're observing to prevent double removal
    private var observedItems = NSMapTable<NSObject, NSMutableSet>.weakToStrongObjects()
    
    // Added to ensure synchronization during initialization and deallocation
    private let lock = NSLock()
    
    deinit {
        // Ensure we clean up any observers that might still be active when this observer is deallocated
        print("üßπ PlayerItemObserver being deallocated")
        // Use safe version to prevent crash
        safelyRemoveAllObservers()
    }
    
    // Method to safely add an observer and track it
    func safelyAddObserver(to object: NSObject, forKeyPath keyPath: String) {
        lock.lock()
        defer { lock.unlock() }
        
        // Get or create the set of keypaths for this object
        let keypaths: NSMutableSet
        if let existingKeypaths = observedItems.object(forKey: object) {
            keypaths = existingKeypaths
        } else {
            keypaths = NSMutableSet()
            observedItems.setObject(keypaths, forKey: object)
        }
        
        // Only add the observer if we're not already observing this keypath
        if !keypaths.contains(keyPath) {
            // Create a unique context pointer based on the keypath to avoid ambiguity
            let contextValue = keyPath.hash
            let contextPointer = UnsafeMutableRawPointer(bitPattern: contextValue)
            
            object.addObserver(self, forKeyPath: keyPath, options: [.new, .initial], context: contextPointer)
            keypaths.add(keyPath)
            print("üëÄ Added observer for keyPath: \(keyPath) with context \(contextValue)")
        } else {
            print("‚ÑπÔ∏è Already observing keyPath: \(keyPath)")
        }
    }
    
    // Method to safely remove an observer and update tracking
    func safelyRemoveObserver(from object: NSObject, forKeyPath keyPath: String) {
        lock.lock()
        defer { lock.unlock() }
        
        // Check if we're observing this object
        guard let keypaths = observedItems.object(forKey: object) else {
            print("‚ÑπÔ∏è No observers found for object")
            return
        }
        
        // Check if we're observing this keypath
        if keypaths.contains(keyPath) {
            // Use the same context as when adding
            let contextValue = keyPath.hash
            let contextPointer = UnsafeMutableRawPointer(bitPattern: contextValue)
            
            do {
                // Use try-catch to handle potential errors
                try {
                    object.removeObserver(self, forKeyPath: keyPath, context: contextPointer)
                }()
                keypaths.remove(keyPath)
                print("üëã Removed observer for keyPath: \(keyPath)")
                
                // If we removed all keypaths for this object, remove it from our tracking
                if keypaths.count == 0 {
                    observedItems.removeObject(forKey: object)
                }
            } catch {
                print("‚ö†Ô∏è Error removing observer: \(error.localizedDescription)")
                // Remove from tracking anyway to avoid getting into an inconsistent state
                keypaths.remove(keyPath)
                if keypaths.count == 0 {
                    observedItems.removeObject(forKey: object)
                }
            }
        } else {
            print("‚ÑπÔ∏è Not observing keyPath: \(keyPath)")
        }
    }
    
    // Remove all observers with objc_sync
    func removeAllObservers() {
        objc_sync_enter(self)
        defer { objc_sync_exit(self) }
        
        // Create a copy to avoid mutation during enumeration
        let enumerator = observedItems.keyEnumerator()
        let objectsToRemove = NSMutableArray()
        
        while let object = enumerator.nextObject() as? NSObject {
            objectsToRemove.add(object)
        }
        
        // Now safely remove all observers
        for case let object as NSObject in objectsToRemove {
            if let keypaths = observedItems.object(forKey: object) {
                for case let keyPath as String in keypaths {
                    do {
                        object.removeObserver(self, forKeyPath: keyPath)
                        print("üëã Cleanup: removed observer for keyPath: \(keyPath)")
                    } catch {
                        print("‚ÑπÔ∏è Cleanup: observer already removed for keyPath: \(keyPath)")
                    }
                }
            }
            observedItems.removeObject(forKey: object)
        }
        
        // Clear the map
        observedItems = NSMapTable<NSObject, NSMutableSet>.weakToStrongObjects()
    }
    
    // Safe version to use during deallocation
    func safelyRemoveAllObservers() {
        lock.lock()
        defer { lock.unlock() }
        
        // Create a snapshot to avoid mutation during enumeration
        let snapshot = NSMapTable<NSObject, NSMutableSet>.weakToStrongObjects()
        let enumerator = observedItems.keyEnumerator()
        
        while let object = enumerator.nextObject() as? NSObject {
            if let keypaths = observedItems.object(forKey: object) {
                snapshot.setObject(keypaths.mutableCopy() as? NSMutableSet, forKey: object)
            }
        }
        
        // Clear the original map first to prevent any new observers from being added during cleanup
        observedItems = NSMapTable<NSObject, NSMutableSet>.weakToStrongObjects()
        
        // Now safely remove all observers from the snapshot
        let objectsEnumerator = snapshot.keyEnumerator()
        while let object = objectsEnumerator.nextObject() as? NSObject {
            if let keypaths = snapshot.object(forKey: object) {
                for case let keyPath as String in keypaths {
                    do {
                        object.removeObserver(self, forKeyPath: keyPath)
                        print("üëã Safe cleanup: removed observer for keyPath: \(keyPath)")
                    } catch {
                        // Just continue if an error occurs - we're in deinit anyway
                        print("‚ÑπÔ∏è Safe cleanup: observer already removed for keyPath: \(keyPath)")
                    }
                }
            }
        }
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        guard let keyPath = keyPath, let object = object as? NSObject else {
            super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
            return
        }
        
        if keyPath == "playbackLikelyToKeepUp" {
            if let item = object as? AVPlayerItem {
                // Update the published property on the main thread
                DispatchQueue.main.async {
                    self.isPlaybackLikely = item.isPlaybackLikelyToKeepUp
                    if !item.isPlaybackLikelyToKeepUp {
                        print("‚ö†Ô∏è Playback not likely to keep up - buffer issues")
                        // Natural recovery will happen
                    } else {
                        print("‚úÖ Playback likely to keep up again")
                    }
                }
            }
        } else if keyPath == "playbackBufferEmpty" {
            if let item = object as? AVPlayerItem {
                // Update the published property on the main thread
                DispatchQueue.main.async {
                    self.isBufferEmpty = item.isPlaybackBufferEmpty
                    if item.isPlaybackBufferEmpty {
                        print("‚ö†Ô∏è Playback buffer empty")
                        self.onBufferEmpty?()
                    } else {
                        print("‚úÖ Playback buffer filled")
                    }
                }
            }
        } else {
            super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
        }
    }
}

struct MarkerRow: View {
    let marker: SceneMarker
    let serverAddress: String
    let onTitleTap: (SceneMarker) -> Void
    let onTagTap: (String) -> Void
    
    // State
    @State private var isVisible = false
    @State private var isMuted = true
    @State private var isPreviewPlaying = false
    @State private var streamAttempts = 0
    @State private var showStreamingOptions = false
    @State private var isLoadingScene = false
    @State private var selectedPerformer: StashScene.Performer?
    @State private var associatedPerformer: StashScene.Performer?
    
    // Environment
    @EnvironmentObject private var appModel: AppModel
    
    // View models
    @StateObject private var playerManager = VideoPlayerManager()
    @State private var player: AVPlayer?
    
    // Observer for player item - use StateObject instead of lazy var to allow state to be modified within the View
    @StateObject private var playerObserver = PlayerItemObserver()
    
    // Stream URL with HLS support
    private var streamURL: URL? {
        let apiKey = appModel.api.apiKeyForURLs
        if apiKey.isEmpty {
            print("‚ùå No API key available for stream URL")
            return nil
        }
        
        // Log the original marker stream URL for debugging
        print("üîç Original marker stream URL: \(marker.stream)")
        
        // Check if this is a scene_marker stream or a scene stream
        let isMarkerStream = marker.stream.contains("scene_marker")
        print("üîç Stream type: \(isMarkerStream ? "scene_marker" : "scene")")
        
        // Extract the marker ID and scene ID
        let markerId = marker.id
        let sceneId = marker.scene.id
        print("üîç Marker ID: \(markerId), Scene ID: \(sceneId)")
        
        // Construct the proper URL based on stream type
        if isMarkerStream {
            // This is already a marker-specific stream
            if playerManager.useHLS {
                // Use HLS streaming for marker
                let baseURL: String
                if marker.stream.hasSuffix("/stream") {
                    baseURL = marker.stream.replacingOccurrences(of: "/stream", with: "/stream.m3u8")
                } else {
                    baseURL = "\(marker.stream).m3u8"
                }
                // Add start parameter for marker timestamp with HLS
                let urlString = "\(baseURL)?apikey=\(apiKey)&resolution=ORIGINAL&start=\(marker.seconds)"
                print("üîç HLS marker URL with start parameter: \(urlString)")
                return URL(string: urlString)
            } else {
                // Use direct streaming for marker
                let urlString = "\(marker.stream)?apikey=\(apiKey)"
                print("üîç Direct marker URL: \(urlString)")
                return URL(string: urlString)
            }
        } else {
            // Need to construct a proper marker stream URL
            let baseServerURL = serverAddress.trimmingCharacters(in: CharacterSet(charactersIn: "/"))
            
            if playerManager.useHLS {
                // Use HLS streaming for the scene, starting at marker position
                // CRITICAL: Add start parameter to begin playback at marker position
                let urlString = "\(baseServerURL)/scene/\(sceneId)/stream.m3u8?apikey=\(apiKey)&resolution=ORIGINAL&start=\(marker.seconds)"
                print("üîç HLS scene URL with start parameter: \(urlString)")
                return URL(string: urlString)
            } else {
                // Use direct streaming for the scene, starting at marker position
                // For markers, use scene_marker endpoint instead of scene endpoint
                let urlString = "\(baseServerURL)/scene_marker/\(markerId)/stream?apikey=\(apiKey)"
                print("üîç Direct scene_marker URL: \(urlString)")
                return URL(string: urlString)
            }
        }
    }
    
    // Format duration in mm:ss format
    private func formatDuration(_ seconds: Float) -> String {
        let minutes = Int(seconds) / 60
        let remainingSeconds = Int(seconds) % 60
        return String(format: "%d:%02d", minutes, remainingSeconds)
    }
    
    // Main View
    var body: some View {
        let _ = print("üì± SCENE ROW: Rendering marker: \(marker.id), title: \(marker.title ?? "missing title")")
        let titleValue = marker.title.isEmpty ? "Untitled" : marker.title // Cache title for consistent use

        return VStack(alignment: .leading) {
            // Thumbnail with preview
            GeometryReader { geometry in
                ZStack {
                    // Thumbnail
                    AsyncImage(url: URL(string: marker.screenshot)) { image in
                        image
                            .resizable()
                            .aspectRatio(16/9, contentMode: .fill)
                    } placeholder: {
                        Rectangle()
                            .fill(Color.gray.opacity(0.2))
                    }

                    // Video preview
                    if isVisible, isPreviewPlaying {
                        VideoPlayer(player: player)
                            .onAppear {
                                player?.isMuted = isMuted
                                
                                if player == nil, let url = streamURL {
                                    setupPreviewPlayer(videoURL: url)
                                }
                            }
                    }

                    // Duration and mute overlay
                    HStack {
                        Text(formatDuration(marker.seconds))
                            .font(.caption)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(.ultraThinMaterial)
                            .cornerRadius(4)

                        Spacer()

                        if isVisible && isPreviewPlaying {
                            Button(action: {
                                isMuted.toggle()
                                player?.isMuted = isMuted
                            }) {
                                Image(systemName: isMuted ? "speaker.slash.fill" : "speaker.wave.2.fill")
                                    .foregroundColor(.white)
                                    .padding(8)
                                    .background(.ultraThinMaterial)
                                    .clipShape(Circle())
                            }
                        }
                    }
                    .padding(8)

                    // Play button when not playing
                    if !isPreviewPlaying {
                        Image(systemName: "play.circle.fill")
                            .font(.system(size: 50))
                            .foregroundColor(.white)
                            .shadow(color: .black.opacity(0.5), radius: 4)
                    }
                    
                    // Play full marker button at top-right
                    VStack {
                        HStack {
                            Spacer()

                            // Play Full button at top-right
                            Button {
                                print("üì± MARKERROW: Play full marker tapped: \(marker.id)")
                                // Use the direct navigation instead of playMarkerVideo
                                onTitleTap(marker)
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.purple.opacity(0.8))
                                        .frame(width: 50, height: 50)
                                        .shadow(color: .black.opacity(0.5), radius: 3, x: 0, y: 2)
                                    
                                    // Icon
                                    Image(systemName: "play.fill")
                                        .font(.system(size: 22, weight: .bold))
                                        .foregroundColor(.white)
                                    
                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 50, height: 50)
                                }
                            }
                            .padding(12)
                        }
                        Spacer()
                    }
                }
                .onTapGesture {
                    handleTap()
                }
                .onChange(of: geometry.frame(in: .global).minY) { _, newValue in
                    let frame = geometry.frame(in: .global)
                    let isNowVisible = frame.minY > 0 && frame.maxY < UIScreen.main.bounds.height

                    if isNowVisible != isVisible {
                        print("üì± MarkerRow: Visibility changed to \(isNowVisible)")
                        isVisible = isNowVisible
                        
                        if isNowVisible {
                            // Preload performer when visible
                            if associatedPerformer == nil, let performers = marker.scene.performers, !performers.isEmpty {
                                associatedPerformer = performers.first
                            }
                        } else {
                            // Stop playback when out of view
                            if isPreviewPlaying {
                                isPreviewPlaying = false
                                cleanupPlayer()
                            }
                        }
                    }
                }
                .onAppear {
                    // When the row appears, check if it's visible in the viewport
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        let frame = geometry.frame(in: .global)
                        let isNowVisible = frame.minY > 0 && frame.maxY < UIScreen.main.bounds.height
                        
                        if isNowVisible && !isVisible {
                            isVisible = true
                        }
                    }
                }
            }
            .frame(height: 180)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            
            // Info section with higher priority for title
            VStack(alignment: .leading, spacing: 8) {
                // Title section gets higher layout priority to ensure it's always visible
                VStack(alignment: .leading) {
                    // Title in separate stack with better contrast
                    HStack {
                        Button(action: {
                            // Instead of using playMarkerVideo which has complex logic,
                            // use the direct navigation function which is more reliable
                            print("üé¨ Marker title tapped - using direct navigation")
                            onTitleTap(marker)
                        }) {
                            Text(titleValue)
                                .font(.headline)
                                .fontWeight(.bold)
                                .lineLimit(2) // Allow up to 2 lines for longer titles
                                .fixedSize(horizontal: false, vertical: true) // Ensure text doesn't get cut off
                                .padding(.vertical, 4) // Add padding above and below title
                                .foregroundColor(.primary) // Ensure high contrast
                                .layoutPriority(100) // Give title highest layout priority
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    
                    // Controls in separate row
                    HStack {
                        // Marker ID for debugging
                        Text("ID: \(marker.id)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                            .opacity(0.7)
                        
                        Spacer()
                        
                        // Tag editing button (for consistency with SceneRow)
                        Button(action: { 
                            // No tag editing for markers, so play marker instead
                            playMarkerVideo()
                         }) {
                            Image(systemName: "tag")
                                .foregroundColor(.blue)
                        }
                        
                        // Display timestamp for the marker
                        HStack(spacing: 2) {
                            Image(systemName: "clock.fill")
                                .foregroundColor(.orange)
                            Text(marker.formattedTime)
                                .foregroundColor(.secondary)
                        }
                        .font(.subheadline)
                    }
                }
                
                // Performer (if available)
                if let performer = associatedPerformer {
                    HStack {
                        Button(action: {
                            selectedPerformer = performer
                        }) {
                            Text(performer.name)
                                .font(.subheadline)
                                .foregroundColor(.blue)
                        }
                    }
                    .lineLimit(1)
                }
                
                // Tags (primary tag + regular tags)
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 4) {
                        // Primary tag
                        Button(action: { onTagTap(marker.primary_tag.name) }) {
                            HStack(spacing: 3) {
                                Image(systemName: "tag.fill")
                                    .font(.system(size: 10))
                                Text(marker.primary_tag.name)
                                    .fontWeight(.medium)
                            }
                            .font(.caption)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 5)
                            .background(Color.blue.opacity(0.2))
                            .cornerRadius(12)
                        }
                        .buttonStyle(ScaleButtonStyle())
                        
                        // Additional tags
                        ForEach(marker.tags) { tag in
                            Button(action: { onTagTap(tag.name) }) {
                                Text(tag.name)
                                    .font(.caption)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.secondary.opacity(0.15))
                                    .cornerRadius(12)
                            }
                            .buttonStyle(ScaleButtonStyle())
                        }
                    }
                }
                
                // Scene info
                HStack(spacing: 12) {
                    Label("From: \(marker.scene.title ?? "Unknown Scene")", systemImage: "film")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .padding(8)
        }
        // Use minimal styling to match SceneRow grid appearance
        .cornerRadius(8)
        .shadow(radius: 1)
        .scaleEffect(isVisible ? 1.0 : 0.98)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isVisible)
        .onDisappear {
            print("üîç MarkerRow disappearing - cleaning up resources")
            cleanupPlayer()
            // Can't call playerObserver.removeAllObservers() directly in onDisappear as it would require mutating self
            DispatchQueue.main.async {
                GlobalVideoManager.shared.cleanupAllPlayers()
            }
        }
        .navigationDestination(isPresented: Binding(
            get: { selectedPerformer != nil },
            set: { if !$0 { selectedPerformer = nil } }
        )) {
            if let performer = selectedPerformer {
                PerformerDetailView(performer: performer)
            }
        }
    }
    
    // Handle the tap gesture
    private func handleTap() {
        // Reset streaming options view if shown
        if showStreamingOptions {
            showStreamingOptions = false
            streamAttempts = 0
            return
        }
        
        // Toggle playback when tapped
        print("üîç MarkerRow - Tapped marker: \(marker.id)")
        isPreviewPlaying.toggle()
        
        if isPreviewPlaying {
            // If we're starting playback and the player isn't set up yet, set it up first
            if player == nil {
                if let url = streamURL {
                    print("üîç MarkerRow - Setting up player with URL: \(url)")
                    print("üîç Using \(playerManager.useHLS ? "HLS" : "direct") streaming mode")
                    setupPreviewPlayer(videoURL: url)
                    player?.play()
                } else {
                    print("‚ùå MarkerRow - Failed to create URL from marker stream: \(marker.stream)")
                }
            } else {
                print("üîç MarkerRow - Using existing player")
                player?.play()
            }
        } else {
            // If we're stopping playback
            print("üîç MarkerRow - Pausing player")
            player?.pause()
        }
    }
    
    // Public method to play marker video with HLS streaming
    func playMarkerVideo() {
        print("üé¨ Playing marker: \(marker.title) at \(marker.seconds) seconds")
        print("üé¨ Scene ID from marker: \(marker.scene.id)")
        print("üé¨ Marker ID: \(marker.id)")

        // Get the root view controller using a more reliable approach
        func findTopViewController() -> UIViewController? {
            // First try the most reliable method for iOS 15+
            guard let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                  let sceneDelegate = scene.delegate as? UIWindowSceneDelegate,
                  let window = scene.windows.first(where: { $0.isKeyWindow }) else {
                
                // Fallback for older iOS versions
                guard let keyWindow = UIApplication.shared.windows.first(where: { $0.isKeyWindow }) ?? UIApplication.shared.windows.first else {
                    return nil
                }
                
                return keyWindow.rootViewController?.topMostViewController()
            }
            
            return window.rootViewController?.topMostViewController()
        }
        
        guard let rootViewController = findTopViewController() else {
            print("‚ùå Failed to get required application context")
            // Fallback method using scene-based approach
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let controller = windowScene.windows.first?.rootViewController {
                presentPlayerViewController(on: controller)
                return
            }
            
            print("‚ö†Ô∏è Could not find any suitable view controller - using indirect navigation")
            // Use playFullScene which knows how to fetch the complete StashScene
            playFullScene()
            return
        }
        
        // Present using the found controller
        presentPlayerViewController(on: rootViewController)
    }
    
    // Helper method to present the player view controller
    private func presentPlayerViewController(on viewController: UIViewController) {
        // Instead of manually constructing a player view controller,
        // use the playFullScene method which will properly fetch the full scene
        // and navigate to it using appModel.navigateToScene
        print("üé¨ Using playFullScene to properly fetch and navigate to scene")
        playFullScene()
    }
    
    // MARK: - Player Setup and Cleanup
    private func setupPreviewPlayer(videoURL: URL) {
        print("üîç MarkerRow setupPreviewPlayer - Setting up player with URL: \(videoURL)")
        print("üîç Using \(playerManager.useHLS ? "HLS" : "direct") streaming mode")
        
        // Check if we're playing a scene or marker direct stream
        let isSceneStream = !videoURL.absoluteString.contains("scene_marker") && videoURL.absoluteString.contains("scene")
        let isHLSStream = videoURL.absoluteString.contains("m3u8")
        
        // Debug logging to help diagnose URL issues
        if playerManager.useHLS && !isHLSStream {
            print("‚ö†Ô∏è Warning: HLS mode is enabled but URL does not contain m3u8: \(videoURL)")
        }
        
        self.streamAttempts += 1
        
        // Set up asset with required headers and improved settings
        var headers = [
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Connection": "keep-alive",
            "User-Agent": "Mozilla/5.0 (Apple Vision; Vision Pro) AppleWebKit/605.1.15",
            "X-Playback-Session-Id": UUID().uuidString,
            "ApiKey": appModel.api.apiKeyForURLs,
            "Authorization": "Bearer \(appModel.api.apiKeyForURLs)"
        ]
        
        // For direct streaming, use identity encoding
        if !playerManager.useHLS {
            headers["Accept-Encoding"] = "identity"
        }
        
        // Enhanced asset options for better streaming
        let assetOptions: [String: Any] = [
            "AVURLAssetHTTPHeaderFieldsKey": headers,
            "AVURLAssetAllowsExpensiveNetworkAccess": true,
            "AVURLAssetAllowsConstrainedNetworkAccess": true,
            "AVURLAssetUsesNSURLSessionKey": true,
            "AVURLAssetPreferPreciseDurationAndTimingKey": true,
            "AVURLAssetHTTPMaximumConnectionsPerHostKey": NSNumber(value: 5),
            "AVURLAssetHTTPUserAgentKey": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X)"
        ]
        
        let asset = AVURLAsset(url: videoURL, options: assetOptions)
        let playerItem = AVPlayerItem(asset: asset)
        
        // Configure for optimal streaming
        playerItem.preferredForwardBufferDuration = 10
        playerItem.canUseNetworkResourcesForLiveStreamingWhilePaused = true
        
        // Create new player with enhanced configuration
        let newPlayer = AVPlayer(playerItem: playerItem)
        newPlayer.automaticallyWaitsToMinimizeStalling = !playerManager.useHLS // Enable for direct, disable for HLS
        newPlayer.isMuted = true
        
        // Store the player in state
        self.player = newPlayer
        print("üîç MarkerRow setupPreviewPlayer - Player created and configured")
        
        // Register with global manager for full cleanup support
        GlobalVideoManager.shared.registerPlayer(newPlayer)
        
        // If playing a scene stream (vs. marker stream), we need to seek to marker position
        // because scene streams start from the beginning of the video
        if isSceneStream {
            // Create a time observer to perform the seek once the player is ready
            let seekTime = CMTime(seconds: Double(marker.seconds), preferredTimescale: 600)
            print("üîç Will seek to marker position: \(marker.seconds) seconds once player is ready")
            
            // Status observer for seeking
            let statusObserver = playerItem.observe(\.status) { item, _ in
                if item.status == .readyToPlay {
                    print("‚úÖ Player ready, seeking to marker position: \(seekTime.seconds) seconds")
                    newPlayer.seek(to: seekTime, toleranceBefore: .zero, toleranceAfter: .zero) { success in
                        print("üîç Seek to marker position \(success ? "succeeded" : "failed")")
                    }
                }
            }
            
            // Store observer to prevent it from being deallocated
            playerItem.accessibilityElements = [statusObserver, playerItem.accessibilityElements].compactMap { $0 }.flatMap { $0 }
        }
        
        // Observe status changes to detect failures
        let statusObserver = playerItem.observe(\.status) { item, _ in
            DispatchQueue.main.async {
                switch item.status {
                case .readyToPlay:
                    print("‚úÖ Marker preview player ready to play")
                    // Success! Reset attempt counter
                    self.streamAttempts = 0
                    
                case .failed:
                    print("‚ùå Marker preview player failed: \(String(describing: item.error))")
                    
                    // Get detailed error information
                    if let itemError = item.error as NSError? {
                        print("‚ùå Error domain: \(itemError.domain)")
                        print("‚ùå Error code: \(itemError.code)")
                        print("‚ùå Error description: \(itemError.localizedDescription)")
                        
                        if let underlyingError = itemError.userInfo[NSUnderlyingErrorKey] as? NSError {
                            print("‚ùå Underlying error: \(underlyingError.localizedDescription)")
                            
                            // Check for 404 errors specifically
                            if underlyingError.domain == "CoreMediaErrorDomain" && 
                                underlyingError.localizedDescription.contains("HTTP 404") {
                                print("üîç Detected 404 error - URL not found, trying alternate URL format")
                                
                                // Try both URL formats with improved fallback strategy
                                self.cleanupPlayer()
                                
                                // First try: If we're using HLS with 404, try HLS with scene_marker endpoint
                                if self.playerManager.useHLS {
                                    print("üîÑ 404 error with HLS, trying HLS with scene_marker endpoint")
                                    let baseServerURL = self.serverAddress.trimmingCharacters(in: CharacterSet(charactersIn: "/"))
                                    let markerHLSURL = URL(string: "\(baseServerURL)/scene_marker/\(self.marker.id)/stream.m3u8?apikey=\(self.appModel.api.apiKeyForURLs)&resolution=ORIGINAL")
                                    
                                    if let url = markerHLSURL {
                                        print("üîÑ Retrying with HLS scene_marker URL: \(url)")
                                        self.setupPreviewPlayer(videoURL: url)
                                        self.player?.play()
                                        return
                                    }
                                }
                                
                                // Second try: Toggle HLS mode and try again
                                self.playerManager.useHLS.toggle()
                                print("üîÑ Toggling HLS mode to \(self.playerManager.useHLS ? "enabled" : "disabled")")
                                
                                // Try with new streaming mode
                                if let newURL = self.streamURL {
                                    print("üîÑ Retrying with alternate URL format: \(newURL)")
                                    self.setupPreviewPlayer(videoURL: newURL)
                                    self.player?.play()
                                }
                                return
                            }
                        }
                        
                        // Auto-toggle streaming method if we haven't tried too many times
                        if self.streamAttempts < 3 {
                            print("üîÑ Auto-toggling streaming mode due to error")
                            self.cleanupPlayer()
                            
                            // Toggle HLS mode
                            self.playerManager.useHLS.toggle()
                            
                            // Retry with new streaming mode if still visible
                            if self.isVisible && self.isPreviewPlaying, let newURL = self.streamURL {
                                print("üîÑ Retrying with \(self.playerManager.useHLS ? "HLS" : "direct") streaming")
                                self.setupPreviewPlayer(videoURL: newURL)
                                self.player?.play()
                            }
                        } else {
                            // Skip showing streaming options to match SceneRow
                            print("‚ö†Ô∏è Too many streaming attempts, auto-retrying in background")
                            self.streamAttempts = 0
                            self.playerManager.useHLS.toggle()
                            
                            if let newURL = self.streamURL {
                                self.setupPreviewPlayer(videoURL: newURL)
                                self.player?.play()
                            }
                        }
                    }
                    
                case .unknown:
                    print("‚ö†Ô∏è Marker preview player status unknown")
                    
                @unknown default:
                    break
                }
            }
        }
        
        // Store observer to prevent it from being deallocated
        if playerItem.accessibilityElements == nil {
            playerItem.accessibilityElements = [statusObserver]
        } else if let elements = playerItem.accessibilityElements {
            playerItem.accessibilityElements = elements + [statusObserver]
        }
        
        // Add failure notification observer
        NotificationCenter.default.addObserver(
            forName: .AVPlayerItemFailedToPlayToEndTime,
            object: playerItem,
            queue: .main
        ) { notification in
            if let error = notification.userInfo?[AVPlayerItemFailedToPlayToEndTimeErrorKey] as? Error {
                print("‚ùå Player failed to play to end: \(error.localizedDescription)")
                
                DispatchQueue.main.async {
                    // Auto-toggle streaming method if we haven't tried too many times
                    if self.streamAttempts < 3 {
                        print("üîÑ Auto-toggling streaming mode due to playback failure")
                        self.cleanupPlayer()
                        
                        // Toggle HLS mode
                        self.playerManager.useHLS.toggle()
                        
                        // Retry with new streaming mode if still visible
                        if self.isVisible && self.isPreviewPlaying, let newURL = self.streamURL {
                            print("üîÑ Retrying with \(self.playerManager.useHLS ? "HLS" : "direct") streaming")
                            self.setupPreviewPlayer(videoURL: newURL)
                            self.player?.play()
                        }
                    }
                }
            }
        }
        
        // Add loop observer
        NotificationCenter.default.addObserver(
            forName: .AVPlayerItemDidPlayToEndTime,
            object: playerItem,
            queue: .main
        ) { _ in
            // Use a direct reference to player
            DispatchQueue.main.async {
                self.player?.seek(to: .zero)
                self.player?.play()
            }
        }
        
        // Add observers using standard KVO
        playerItem.addObserver(playerObserver, 
                              forKeyPath: "playbackLikelyToKeepUp", 
                              options: [.new, .initial],
                              context: UnsafeMutableRawPointer(bitPattern: 1))
        
        playerItem.addObserver(playerObserver,
                              forKeyPath: "playbackBufferEmpty",
                              options: [.new, .initial],
                              context: UnsafeMutableRawPointer(bitPattern: 2))
        
        // Store our tracking info that observers were added to this item
        // (We use accessibilityElements as a place to store references that need to be retained)
        if playerItem.accessibilityElements == nil {
            playerItem.accessibilityElements = [NSObject()] // Just need a non-nil marker
        }
    }
    
    private func cleanupPlayer() {
        // Safely access the player using a local copy to avoid race conditions
        guard let currentPlayer = player else {
            print("‚ÑπÔ∏è No player to clean up")
            return
        }
        
        // First pause and mute the player
        currentPlayer.pause()
        currentPlayer.isMuted = true
        currentPlayer.volume = 0
        
        // Use a local variable to indicate cleanup status
        var didCleanupObservers = false
        
        // Create a local reference to the playerItem to avoid it changing during cleanup
        if let playerItem = currentPlayer.currentItem {
            // Remove notification observers
            NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: playerItem)
            NotificationCenter.default.removeObserver(self, name: .AVPlayerItemFailedToPlayToEndTime, object: playerItem)
            
            // Track whether we've added observers to avoid removal errors
            let addedObservers = playerItem.accessibilityElements != nil
            
            // Only try to remove KVO observers if we've actually added them
            if addedObservers {
                didCleanupObservers = true
                
                // Use the playerObserver's safer method to remove KVO
                playerObserver.safelyRemoveObserver(from: playerItem, forKeyPath: "playbackLikelyToKeepUp")
                playerObserver.safelyRemoveObserver(from: playerItem, forKeyPath: "playbackBufferEmpty")
            } else {
                print("‚ÑπÔ∏è No observers were added to this player item")
            }
            
            // Clear out the accessibility elements to avoid future issues
            playerItem.accessibilityElements = nil
        }
        
        // Unregister from global manager - do this before nulling the player reference
        GlobalVideoManager.shared.unregisterPlayer(currentPlayer)
        
        // Set player item to nil to release all resources
        currentPlayer.replaceCurrentItem(with: nil)
        
        // Clear player reference - only do this at the very end
        DispatchQueue.main.async {
            // Use an async call to break potential retain cycles
            self.player = nil
            print("üßπ Player reference fully released")
        }
        
        print("üßπ Player resources cleaned up successfully (observers: \(didCleanupObservers ? "removed" : "none found"))")
    }
    
    // Method to play full scene
    private func playFullScene() {
        // Scene is not optional in this context
        let scene = marker.scene
        
        Task {
            isLoadingScene = true
            // Clean up preview player first
            cleanupPlayer()
            
            // Fetch the specific scene by ID
            print("üé¨ Fetching scene details for ID: \(scene.id)")
            do {
                if let fullScene = try await appModel.api.fetchScene(byID: scene.id) {
                    print("‚úÖ Found full scene details for ID: \(scene.id)")
                    
                    // Open the video player with the full scene and marker start time
                    await MainActor.run {
                        appModel.navigateToScene(fullScene, startSeconds: Double(marker.seconds))
                    }
                } else {
                    print("‚ùå Failed to find scene with ID: \(scene.id)")
                }
            } catch {
                print("‚ùå Error loading scene: \(error)")
            }
            
            isLoadingScene = false
        }
    }
    
    // Update the getAssociatedPerformer function with improved error handling
    private func getAssociatedPerformer() async -> StashScene.Performer? {
        // Only fetch if the view is still visible
        guard isVisible else { return nil }
        
        // Check if marker scene already has performers loaded from the updated query
        if let performers = marker.scene.performers, !performers.isEmpty {
            print("‚úÖ Using cached performer info for scene \(marker.scene.id)")
            return performers.first
        }
        
        print("üîç Fetching performer info for scene \(marker.scene.id)")
        
        // Get API key from app model
        let apiKey = appModel.api.apiKeyForURLs
        
        // Using a more complete query that includes all performer fields
        let query = """
        {"operationName":"FindScene","variables":{"id":"\(marker.scene.id)"},"query":"query FindScene($id: ID!) {\\n  findScene(id: $id) {\\n    id\\n    title\\n    performers {\\n      id\\n      name\\n      gender\\n      image_path\\n      scene_count\\n      favorite\\n      rating100\\n    }\\n  }\\n}"}
        """
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for fetching performers: \(serverAddress)/graphql")
            return nil
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.setValue("en-US,en;q=0.9", forHTTPHeaderField: "Accept-Language")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("\(serverAddress)/scenes/markers", forHTTPHeaderField: "Referer")
        
        // Set ApiKey header for authentication
        // apiKey is a non-optional String
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        
        // Set the request body
        let jsonData = query.data(using: .utf8)!
        request.setValue("\(jsonData.count)", forHTTPHeaderField: "Content-Length")
        request.httpBody = jsonData
        
        do {
            // Add a task check to prevent cancelled request errors
            try Task.checkCancellation()
            
            print("üåê Sending performer request for scene \(marker.scene.id)")
            let (data, response) = try await URLSession.shared.data(for: request)
            try Task.checkCancellation()
            
            // Log the HTTP response status
            if let httpResp = response as? HTTPURLResponse {
                print("üîç HTTP response status for performer fetch: \(httpResp.statusCode)")
                
                // Check for HTTP errors
                if httpResp.statusCode >= 400 {
                    print("‚ùå HTTP error: \(httpResp.statusCode)")
                    return nil
                }
            }
            
            // Define response structure with proper error handling
            struct SceneResponse: Decodable {
                struct DataResponse: Decodable {
                    struct SceneData: Decodable {
                        let id: String
                        let title: String?
                        let performers: [StashScene.Performer]
                    }
                    let findScene: SceneData
                }
                let data: DataResponse?
                
                struct GraphQLError: Decodable {
                    let message: String
                }
                let errors: [GraphQLError]?
            }
            
            // Attempt decoding with error handling
            do {
                let response = try JSONDecoder().decode(SceneResponse.self, from: data)
                
                // Check for GraphQL errors
                if let errors = response.errors, !errors.isEmpty {
                    let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                    print("‚ùå GraphQL errors in performer fetch: \(errorMessages)")
                    return nil
                }
                
                // Check for missing data
                guard let responseData = response.data else {
                    print("‚ùå Missing data field in response")
                    return nil
                }
                
                if responseData.findScene.performers.isEmpty {
                    print("‚ÑπÔ∏è No performers found for scene \(marker.scene.id)")
                    return nil
                }
                
                print("‚úÖ Successfully fetched \(responseData.findScene.performers.count) performers for scene \(marker.scene.id)")
                return responseData.findScene.performers.first
            } catch let decodingError {
                print("‚ùå JSON decoding error: \(decodingError)")
                return nil
            }
        } catch is CancellationError {
            // Ignore cancellation errors
            print("‚ÑπÔ∏è Performer fetch was cancelled")
            return nil
        } catch {
            print("‚ùå Error fetching performer for scene \(marker.scene.id): \(error)")
            return nil
        }
    }
}

================
File: stash/Views/Markers/MarkerView.swift
================
import SwiftUI
import AVKit

struct MarkerView: View {
    @EnvironmentObject var appModel: AppModel
    @StateObject private var viewModel = MarkerViewModel()
    
    // Optional parameters for filtered views
    var scene: StashScene?
    var performer: StashScene.Performer?
    
    // UI Configuration
    @State private var columnCount = 2
    @State private var filterMenuPresented = false
    @State private var sortOption: MarkerSortOption = .createdAtDesc
    @State private var selectedTagId: String? = nil
    
    // Dynamic grid column calculation
    private func gridItems(for width: CGFloat) -> [GridItem] {
        // Base on available width
        let baseWidth: CGFloat = 300
        let calculatedCount = max(1, Int(width / baseWidth))
        let columns = Array(repeating: GridItem(.flexible()), count: calculatedCount)
        return columns
    }
    
    private func getNavigationTitle() -> String {
        if let scene = scene {
            return "Markers: \(scene.title)"
        } else if let performer = performer {
            return "\(performer.name)'s Markers"
        } else {
            return "All Markers"
        }
    }
    
    // Loading view for initial load
    private var loadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle())
                .scaleEffect(1.5)
            
            Text("Loading markers...")
                .font(.headline)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .slideIn(from: .bottom)
    }
    
    // Empty state view
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "film")
                .font(.system(size: 60))
                .foregroundColor(.secondary)
                .padding()
            
            if let scene = scene {
                Text("No markers for \(scene.title)")
                    .font(.headline)
            } else if let performer = performer {
                Text("No markers for \(performer.name)")
                    .font(.headline)
            } else {
                Text("No markers found")
                    .font(.headline)
            }
            
            Text("Try changing your filters or adding new markers")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            if let error = viewModel.error {
                Text("Error: \(error)")
                    .font(.caption)
                    .foregroundColor(.red)
                    .padding()
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .slideIn(from: .bottom)
    }
    
    // Main content view with markers
    private var markersContentView: some View {
        GeometryReader { geo in
            let columns = gridItems(for: geo.size.width)
            
            ScrollView {
                LazyVGrid(columns: columns, spacing: 20) {
                    ForEach(viewModel.filteredMarkers) { marker in
                        MarkerCard(marker: marker)
                            .slideIn(from: .bottom, delay: 0.05 * Double(viewModel.filteredMarkers.firstIndex(of: marker) ?? 0), duration: 0.25)
                            .onAppear {
                                // Load more if needed
                                if marker.id == viewModel.filteredMarkers.last?.id && !viewModel.isLoadingMore && viewModel.hasMorePages {
                                    Task {
                                        await viewModel.loadMoreMarkers()
                                    }
                                }
                            }
                    }
                    
                    if viewModel.isLoadingMore {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .padding()
                            .gridCellColumns(columns.count)
                    }
                }
                .padding()
            }
        }
    }
    
    // Sorting and filtering menu
    private var sortFilterMenu: some View {
        Menu {
            Section("Sort by") {
                ForEach(MarkerSortOption.allCases) { option in
                    Button(option.label) {
                        viewModel.sortMarkers(by: option)
                        sortOption = option
                    }
                    .foregroundColor(sortOption == option ? .accentColor : .primary)
                }
            }
            
            if !viewModel.availableTags.isEmpty {
                Section("Filter by tag") {
                    Button("All Tags") {
                        selectedTagId = nil
                        viewModel.resetTagFilter()
                    }
                    .foregroundColor(selectedTagId == nil ? .accentColor : .primary)
                    
                    ForEach(viewModel.availableTags) { tag in
                        Button(tag.name) {
                            selectedTagId = tag.id
                            viewModel.filterMarkersByTag(tagId: tag.id)
                        }
                        .foregroundColor(selectedTagId == tag.id ? .accentColor : .primary)
                    }
                }
            }
        } label: {
            HStack {
                Image(systemName: "line.3.horizontal.decrease.circle")
                    .font(.system(size: 16, weight: .semibold))
                Text("Sort & Filter")
            }
        }
    }
    
    // Marker card component
    private struct MarkerCard: View {
        let marker: SceneMarker
        @EnvironmentObject var appModel: AppModel
        @State private var isShowingContextMenu = false
        
        var body: some View {
            VStack(alignment: .leading, spacing: 8) {
                // Thumbnail with play button overlay
                ZStack(alignment: .center) {
                    AsyncImage(url: URL(string: marker.screenshot ?? "")) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    } placeholder: {
                        Rectangle()
                            .fill(Color.gray.opacity(0.3))
                            .overlay(
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                            )
                    }
                    .frame(height: 160)
                    .cornerRadius(8)
                    .clipped()
                    
                    // Play button overlay
                    Circle()
                        .fill(Color.black.opacity(0.6))
                        .frame(width: 50, height: 50)
                        .overlay(
                            Image(systemName: "play.fill")
                                .font(.system(size: 22))
                                .foregroundColor(.white)
                        )
                }
                .onTapGesture {
                    // Play marker functionality
                    appModel.navigateToMarker(marker)
                }
                .applyHoverEffect()
                
                // Title and timestamp
                VStack(alignment: .leading, spacing: 4) {
                    Text(marker.title)
                        .font(.headline)
                        .lineLimit(1)
                    
                    HStack {
                        Label(formatTime(marker.seconds), systemImage: "clock")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                        
                        if let performer = marker.scene.performers?.first {
                            Text(performer.name)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                
                // Tags
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(marker.tags) { tag in
                            Button(action: {
                                // Handle tag selection
                                print("Selected tag: \(tag.name)")
                            }) {
                                Text(tag.name)
                                    .font(.caption)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.secondary.opacity(0.2))
                                    .cornerRadius(8)
                            }
                            .buttonStyle(ScaleButtonStyle())
                        }
                    }
                }
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.1), radius: 4, x: 0, y: 2)
            .contextMenu {
                Button {
                    appModel.navigateToMarker(marker)
                } label: {
                    Label("Play Marker", systemImage: "play.fill")
                }
                
                Button {
                    // View scene for this marker
                    if let scene = appModel.api.scenes.first(where: { $0.id == marker.scene.id }) {
                        appModel.currentScene = scene
                        appModel.navigationPath.append(scene)
                    }
                } label: {
                    Label("Go to Scene", systemImage: "film")
                }
                
                Button {
                    // TODO: Navigate to edit marker view
                } label: {
                    Label("Edit Marker", systemImage: "pencil")
                }
                
                Divider()
                
                Button(role: .destructive) {
                    // TODO: Add delete functionality
                } label: {
                    Label("Delete Marker", systemImage: "trash")
                }
            }
        }
        
        /// Format time in seconds to string format mm:ss
        private func formatTime(_ seconds: Float) -> String {
            let minutes = Int(seconds) / 60
            let seconds = Int(seconds) % 60
            return String(format: "%d:%02d", minutes, seconds)
        }
    }
    
    var body: some View {
        ZStack {
            if viewModel.isLoading && viewModel.markers.isEmpty {
                loadingView
            } else if viewModel.markers.isEmpty {
                emptyStateView
            } else {
                markersContentView
            }
        }
        .navigationTitle(getNavigationTitle())
        .overlay {
            // Overlay loading indicator for subsequent loads
            if viewModel.isLoading && !viewModel.markers.isEmpty {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(width: 60, height: 60)
                    .background(.ultraThinMaterial)
                    .cornerRadius(10)
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                sortFilterMenu
            }
        }
        .task {
            // Load markers when the view appears
            if let scene = scene {
                await viewModel.loadMarkers(for: scene, api: appModel.api)
            } else if let performer = performer {
                await viewModel.loadMarkers(for: performer, api: appModel.api)
            } else {
                await viewModel.loadAllMarkers(api: appModel.api)
            }
        }
    }
}

// MARK: - Using shared animation modifiers
// These are now defined in AnimationModifiers.swift

// MARK: - Preview
struct MarkerView_Previews: PreviewProvider {
    static var previews: some View {
        MarkerView()
            .environmentObject(AppModel())
    }
}

================
File: stash/Views/Markers/PerformerSelectionView.swift
================
import SwiftUI

struct PerformerSelectionView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appModel: AppModel
    @Binding var selectedPerformer: StashScene.Performer?
    @State private var searchText = ""
    @State private var performers: [StashScene.Performer] = []
    @State private var isLoading = false
    
    private let columns = [
        GridItem(.adaptive(minimum: 160, maximum: 200), spacing: 16)
    ]
    
    var body: some View {
        NavigationStack {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(performers) { performer in
                        Button(action: {
                            selectedPerformer = performer
                            dismiss()
                        }) {
                            PerformerRow(performer: performer)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding()
            }
            .searchable(text: $searchText)
            .onChange(of: searchText) { _, newValue in
                Task {
                    await searchPerformers(query: newValue)
                }
            }
            .navigationTitle("Select Performer")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
        .task {
            await loadPerformers()
        }
    }
    
    private func loadPerformers() async {
        isLoading = true
        await appModel.api.fetchPerformers(filter: .all, page: 1, appendResults: false, search: "", completion: { _ in })
        performers = appModel.api.performers
        isLoading = false
    }
    
    private func searchPerformers(query: String) async {
        guard !query.isEmpty else {
            await loadPerformers()
            return
        }
        
        // Implement performer search
        // This will be added in the next step
    }
}

================
File: stash/Views/Markers/SceneSelectionView.swift
================
import SwiftUI

struct SceneSelectionView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appModel: AppModel
    @Binding var selectedScene: StashScene?
    @State private var searchText = ""
    @State private var scenes: [StashScene] = []
    @State private var isLoading = false
    @State private var currentPage = 1
    @State private var hasMorePages = true
    
    private let columns = [
        GridItem(.adaptive(minimum: 300, maximum: 400), spacing: 16)
    ]
    
    var body: some View {
        NavigationStack {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(scenes) { scene in
                        Button(action: {
                            selectedScene = scene
                            dismiss()
                        }) {
                            SceneRow(
                                scene: scene,
                                onTagSelected: { _ in },
                                onPerformerSelected: { _ in },
                                onSceneUpdated: { _ in },
                                onSceneSelected: { _ in }
                            )
                        }
                        .buttonStyle(PlainButtonStyle())
                        .onAppear {
                            if scene == scenes.last && !isLoading && hasMorePages {
                                Task {
                                    await loadMoreScenes()
                                }
                            }
                        }
                    }
                    
                    if isLoading {
                        ProgressView()
                            .gridCellColumns(columns.count)
                            .padding()
                    }
                }
                .padding()
            }
            .searchable(text: $searchText)
            .onChange(of: searchText) { _, newValue in
                Task {
                    await searchScenes(query: newValue)
                }
            }
            .navigationTitle("Select Scene")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
        .task {
            await loadScenes()
        }
    }
    
    private func loadScenes() async {
        isLoading = true
        currentPage = 1

        // Use regular search with empty string to get all scenes
        let result = try? await appModel.api.searchScenes(query: "")
        if let foundScenes = result {
            scenes = foundScenes
        } else {
            scenes = []
        }

        isLoading = false
    }
    
    private func loadMoreScenes() async {
        guard !isLoading else { return }

        isLoading = true
        currentPage += 1

        // We'll simulate pagination for now
        // In a real implementation, you'd want to add page parameter to searchScenes
        let previousCount = scenes.count
        hasMorePages = false // For simplicity, disable pagination for now
        isLoading = false
    }
    
    private func searchScenes(query: String) async {
        guard !query.isEmpty else {
            await loadScenes()
            return
        }

        isLoading = true

        let result = try? await appModel.api.searchScenes(query: query)
        if let foundScenes = result {
            scenes = foundScenes
        } else {
            scenes = []
        }

        isLoading = false
    }
}

================
File: stash/Views/Performers/PerformerDetailView.swift
================
import SwiftUI

struct PerformerDetailView: View {
    let performer: StashScene.Performer
    @EnvironmentObject private var appModel: AppModel
    @State private var selectedTab = 0 // 0 for scenes, 1 for markers
    @State private var markerCount: Int = 0
    @State private var performerScenes: [StashScene] = [] // Local state for scenes

    init(performer: StashScene.Performer) {
        self.performer = performer
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Performer header
            PerformerHeaderView(performer: performer)

            // Tab picker
            Picker("View", selection: $selectedTab) {
                Text("Scenes").tag(0)
                Text("Markers").tag(1)
            }
            .pickerStyle(.segmented)
            .padding()

            TabView(selection: $selectedTab) {
                // Scenes Tab
                scenesContent
                    .tag(0)
                    .onAppear {
                        // Force scenes to load when tab is first shown
                        print("üí° SCENE TAB - Tab content appeared directly")
                        if performerScenes.isEmpty {
                            Task {
                                print("üí° SCENE TAB - Forcing scene load from tab content appear")
                                await loadScenes()
                            }
                        }
                    }

                // Markers Tab
                NavigationLink(destination: PerformerMarkersView(performer: performer)
                    .environmentObject(appModel)) {
                    markersContent
                }
                .buttonStyle(PlainButtonStyle())
                .tag(1)
                .onAppear {
                    // Force markers to load when tab is first shown
                    print("üí° MARKERS TAB - Tab content appeared directly")
                    if appModel.api.markers.isEmpty {
                        Task {
                            print("üí° MARKERS TAB - Forcing marker load from tab content appear")
                            await loadMarkers()
                        }
                    }
                }
            }
            .tabViewStyle(.page(indexDisplayMode: .never))
        }
        .navigationTitle(performer.name)
        .onDisappear {
            // Reset scenes to default when leaving this view
            // This fixes the issue of performer's scenes showing when navigating back
            print("üì± PerformerDetailView disappeared - resetting scenes")
            Task {
                await MainActor.run {
                    // Clear the performer-specific scenes
                    appModel.api.scenes = []
                    performerScenes = []
                    appModel.currentPerformer = nil
                }

                // Reload the default scenes for the main library view
                Task {
                    await appModel.api.fetchScenes(page: 1, sort: "date", direction: "DESC")
                }
            }
        }
        .onAppear {
            // Load content immediately on appearance
            print("üöÄ DETAIL - PerformerDetailView appeared for performer: \(performer.name) (ID: \(performer.id))")

            // Immediately set selected tab to 0 to ensure we start with scenes
            DispatchQueue.main.async {
                selectedTab = 0
            }

            Task(priority: .userInitiated) {
                print("üöÄ DETAIL - Preloading scenes aggressively")

                // This approach is more aggressive - we directly trigger the API call
                // rather than waiting for UI events to cascade

                // The direct approach - immediately make the query
                print("‚ö°Ô∏è DETAIL - Direct scenes query for \(performer.id) starting...")

                // Force clear any existing scenes
                await MainActor.run {
                    appModel.api.scenes = []
                    performerScenes = []
                    appModel.api.isLoading = true
                }

                // Execute direct query
                await appModel.api.fetchPerformerScenes(
                    performerId: performer.id,
                    page: 1,
                    perPage: 40,
                    sort: "date",
                    direction: "DESC",
                    appendResults: false
                )

                // Ensure local state is updated
                await MainActor.run {
                    performerScenes = appModel.api.scenes
                    appModel.api.isLoading = false
                    print("‚ö°Ô∏è DETAIL - Direct scenes query completed with \(performerScenes.count) scenes")
                }

                // Also load markers in the background
                Task.detached {
                    await self.loadMarkers()
                    await self.getMarkerCount()
                }

                print("‚úÖ DETAIL - Initial content loading completed")

                // The rest of this code is kept as a fallback but won't execute
                print("üöÄ DETAIL - Direct query process complete")

                // First, clear existing scenes to prevent showing incorrect data
                await MainActor.run {
                    print("üöÄ DETAIL - Clearing scenes array")
                    appModel.api.scenes = []
                    appModel.api.isLoading = true
                }

                print("üöÄ DETAIL - Using executeGraphQLQuery approach")

                do {
                    // Create a query using proper format
                    let query = """
                    {
                        "operationName": "FindScenes",
                        "variables": {
                            "filter": {
                                "page": 1,
                                "per_page": 100,
                                "sort": "date",
                                "direction": "DESC"
                            },
                            "scene_filter": {
                                "performers": {
                                    "value": ["\(performer.id)"],
                                    "modifier": "INCLUDES"
                                }
                            }
                        },
                        "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender scene_count } tags { id name } rating100 } } }"
                    }
                    """

                    print("üöÄ DETAIL - Executing query using StashAPI.executeGraphQLQuery")

                    // Use executeGraphQLQuery which handles authentication properly
                    let data = try await appModel.api.executeGraphQLQuery(query)

                    print("üöÄ DETAIL - Query executed successfully")

                    if let responseString = String(data: data, encoding: .utf8) {
                        print("üöÄ DETAIL - Response data preview:")
                        print(responseString.prefix(500))
                        if responseString.count > 500 {
                            print("... (truncated)")
                        }
                    }

                    struct DirectFindScenesResponse: Decodable {
                        struct Data: Decodable {
                            struct FindScenes: Decodable {
                                let count: Int
                                let scenes: [StashScene]
                            }
                            let findScenes: FindScenes
                        }
                        let data: Data
                        let errors: [GraphQLError]?
                    }

                    let directResponse = try JSONDecoder().decode(DirectFindScenesResponse.self, from: data)

                    if let errors = directResponse.errors, !errors.isEmpty {
                        let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                        print("üöÄ DETAIL - GraphQL errors in query: \(errorMessages)")
                        throw StashAPIError.graphQLError(errorMessages)
                    } else {
                        print("üöÄ DETAIL - Query successful!")
                        print("üöÄ DETAIL - Found \(directResponse.data.findScenes.scenes.count) scenes")
                        print("üöÄ DETAIL - Total count: \(directResponse.data.findScenes.count)")

                        if !directResponse.data.findScenes.scenes.isEmpty {
                            let scene = directResponse.data.findScenes.scenes[0]
                            print("üöÄ DETAIL - First scene: \(scene.title ?? "No title") (ID: \(scene.id))")

                            print("üöÄ DETAIL - Checking performers in first scene:")
                            for p in scene.performers {
                                print("üöÄ DETAIL - Scene has performer: \(p.name) (ID: \(p.id))")
                                if p.id == performer.id {
                                    print("üöÄ DETAIL - ‚úÖ MATCH: Scene has expected performer!")
                                }
                            }
                        }

                        await MainActor.run {
                            print("üîÑ DETAIL - About to update scenes array, current count: \(appModel.api.scenes.count)")
                            appModel.api.scenes = directResponse.data.findScenes.scenes

                            // IMPORTANT: Also update our local state - this fixes the view update issue
                            performerScenes = directResponse.data.findScenes.scenes

                            print("üîÑ DETAIL - Updated scenes array, new count: \(appModel.api.scenes.count)")
                            print("üîÑ DETAIL - Updated local performerScenes, new count: \(performerScenes.count)")
                            appModel.api.totalSceneCount = directResponse.data.findScenes.count
                            appModel.api.isLoading = false
                            print("‚úÖ DETAIL - Query loaded \(directResponse.data.findScenes.scenes.count) scenes!")

                            // Debug: Check first few scenes to verify content
                            for (index, scene) in performerScenes.prefix(3).enumerated() {
                                print("üîç DETAIL - Scene \(index): \(scene.title ?? "No title") (ID: \(scene.id))")
                                print("üîç DETAIL - Has \(scene.performers.count) performers")
                            }
                        }
                    }
                } catch {
                    print("‚ùå DETAIL - Query failed: \(error.localizedDescription)")
                    print("üöÄ DETAIL - Will fall back to standard method...")

                    // Fall back to standard methods
                    if selectedTab == 0 {
                        await loadScenes()
                        await getMarkerCount() // Load marker count in background
                    } else {
                        // Load both but prioritize markers
                        await loadMarkers()
                        await loadScenes() // Also load scenes for when user switches tabs
                    }
                }
            }
        }
        .onChange(of: selectedTab) { _, newValue in
            // Ensure the tab content is loaded when tab changes
            Task {
                print("üí´ Tab changed to: \(newValue)")

                // Always ensure both scenes and markers are loaded, just prioritize differently
                if newValue == 0 {
                    // Scenes tab selected
                    if performerScenes.isEmpty {
                        await loadScenes()
                    } else {
                        print("üí´ Not reloading scenes as we already have \(performerScenes.count) scenes")
                    }
                } else {
                    // Markers tab selected
                    if appModel.api.markers.isEmpty {
                        await loadMarkers()
                    } else {
                        print("üí´ Not reloading markers as we already have \(appModel.api.markers.count) markers")
                    }
                }
            }
        }
    }
    
    // Note: This method is now unused as we've improved the onAppear logic
    private func loadInitialContent() async {
        // Load marker count in the background
        Task {
            markerCount = await getMarkerCount()
        }

        // First load the scenes (most important)
        await loadScenes()

        // Then, if on markers tab, load markers
        if selectedTab == 1 {
            await loadMarkers()
        }
    }
    
    private var scenesContent: some View {
        ScrollView {
            // Add debug Text to show actual scenes count
            Text("Debug: \(performerScenes.count) local scenes / \(appModel.api.scenes.count) API scenes")
                .font(.caption)
                .foregroundColor(.gray)
                .padding(.top, 4)

            if performerScenes.isEmpty {
                // Show loading indicator if API is loading or force trigger a load
                VStack(spacing: 20) {
                    if appModel.api.isLoading {
                        ProgressView()
                            .padding()
                        Text("Loading scenes...")
                            .foregroundColor(.secondary)
                    } else {
                        Text("No scenes found")
                            .foregroundColor(.secondary)

                        // Add reload button
                        Button("Reload Scenes") {
                            Task {
                                print("üîÑ SCENES VIEW - Manual reload requested")
                                await MainActor.run {
                                    performerScenes = []
                                    appModel.api.scenes = []
                                }
                                await loadScenes()
                            }
                        }
                        .buttonStyle(.bordered)
                    }
                }
                .padding()
                .onAppear {
                    // Force load scenes immediately when this empty state appears
                    print("‚ö†Ô∏è SCENES VIEW - Empty state appeared, forcing load")
                    Task {
                        await loadScenes()
                    }
                }
            } else {
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 300))], spacing: 16) {
                    ForEach(performerScenes) { scene in
                        SceneRow(
                            scene: scene,
                            onTagSelected: { _ in },
                            onPerformerSelected: { performer in
                                appModel.navigateToPerformer(performer)
                            },
                            onSceneUpdated: { _ in },
                            onSceneSelected: { selectedScene in
                                appModel.navigateToScene(selectedScene)
                            }
                        )
                    }
                }
                .padding()
                .onAppear {
                    print("üåü SCENES GRID - LazyVGrid appeared with \(performerScenes.count) scenes")
                    // Debug the first few scenes
                    for (index, scene) in performerScenes.prefix(3).enumerated() {
                        print("üåü SCENES GRID - Scene \(index): \(scene.title ?? "No title") (ID: \(scene.id))")
                    }
                }
            }
        }
    }
    
    private var markersContent: some View {
        ScrollView {
            // Add debug Text to show actual markers count
            Text("Debug: \(appModel.api.markers.count) markers, \(markerCount) total")
                .font(.caption)
                .foregroundColor(.gray)
                .padding(.top, 4)

            if appModel.api.markers.isEmpty {
                // Show loading indicator if API is loading or force trigger a load
                VStack(spacing: 20) {
                    if appModel.api.isLoading {
                        ProgressView()
                            .padding()
                        Text("Loading markers...")
                            .foregroundColor(.secondary)
                    } else {
                        Text("No markers found")
                            .foregroundColor(.secondary)

                        // Add reload button
                        Button("Reload Markers") {
                            Task {
                                print("üîÑ MARKERS VIEW - Manual reload requested")
                                await MainActor.run {
                                    appModel.api.markers = []
                                }
                                await loadMarkers()
                            }
                        }
                        .buttonStyle(.bordered)
                    }
                }
                .padding()
                .onAppear {
                    // Force load markers immediately when this empty state appears
                    print("‚ö†Ô∏è MARKERS VIEW - Empty state appeared, forcing load")
                    Task {
                        await loadMarkers()
                    }
                }
            } else {
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 300))], spacing: 16) {
                    ForEach(appModel.api.markers) { marker in
                        MarkerRow(
                            marker: marker,
                            serverAddress: appModel.serverAddress,
                            onTitleTap: { marker in
                                appModel.navigateToMarker(marker)
                            },
                            onTagTap: { _ in }
                        )
                    }
                }
                .padding()
                .onAppear {
                    print("üåü MARKERS GRID - LazyVGrid appeared with \(appModel.api.markers.count) markers")
                }
            }
        }
    }
    
    private func loadScenes() async {
        print("üîç LOADSCENES - Starting load of scenes for performer: \(performer.name) (ID: \(performer.id))")

        // First, check if we already have scenes for this performer
        if !performerScenes.isEmpty {
            print("‚úÖ LOADSCENES - Already have \(performerScenes.count) scenes, skipping load")

            // If we already have scenes but the app doesn't know about them, update app state
            if appModel.api.scenes.isEmpty {
                await MainActor.run {
                    print("‚ö†Ô∏è LOADSCENES - App state missing scenes, syncing with local state")
                    appModel.api.scenes = performerScenes
                }
            }
            return
        }

        // Check if we're already loading
        if appModel.api.isLoading {
            print("‚è≥ LOADSCENES - API is already loading, waiting...")
            // Wait a moment to see if loading completes
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 second

            // If data loaded during wait, use it
            if !appModel.api.scenes.isEmpty {
                await MainActor.run {
                    print("‚úÖ LOADSCENES - Found scenes were loaded during wait, using them")
                    performerScenes = appModel.api.scenes
                }
                return
            }
        }

        // Clear existing scenes to prevent showing incorrect data
        await MainActor.run {
            print("üßπ LOADSCENES - Clearing scenes array, current count: \(appModel.api.scenes.count)")
            appModel.api.scenes = []
            // Also clear our local state
            performerScenes = []
            print("üßπ LOADSCENES - Cleared scenes array, new count: \(appModel.api.scenes.count)")
            print("üßπ LOADSCENES - Cleared local performerScenes, new count: \(performerScenes.count)")
            appModel.api.isLoading = true
        }

        // Use the dedicated performer scenes method with updated configuration
        print("üîÑ LOADSCENES - Calling fetchPerformerScenes for performer \(performer.id)")
        await appModel.api.fetchPerformerScenes(
            performerId: performer.id,
            page: 1,
            perPage: 40,
            sort: "date",
            direction: "DESC",
            appendResults: false
        )

        print("‚úÖ LOADSCENES - API call completed")
        print("‚úÖ LOADSCENES - Scenes array count: \(appModel.api.scenes.count)")

        // Update our local state with the results
        await MainActor.run {
            performerScenes = appModel.api.scenes
            print("‚úÖ LOADSCENES - Updated local performerScenes, count: \(performerScenes.count)")
        }

        print("‚úÖ LOADSCENES - Loaded \(performerScenes.count) scenes for performer: \(performer.name)")

        // Debug: Check first few scenes to verify content
        for (index, scene) in performerScenes.prefix(3).enumerated() {
            print("üîç LOADSCENES - Scene \(index): \(scene.title ?? "No title") (ID: \(scene.id))")
            print("üîç LOADSCENES - Has \(scene.performers.count) performers")
        }

        // Double-check - if somehow scenes are still empty but we have a valid performer,
        // try one more time with a different query strategy
        if appModel.api.scenes.isEmpty {
            print("‚ö†Ô∏è No scenes loaded for performer, trying alternative query...")

            // Try again with a slightly different approach - make sure to use proper JSON
            let query = """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": 1,
                        "per_page": 100,
                        "sort": "date",
                        "direction": "DESC"
                    },
                    "scene_filter": {
                        "performers": {
                            "value": ["\(performer.id)"],
                            "modifier": "INCLUDES"
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender scene_count } tags { id name } rating100 } } }"
            }
            """

            // Execute this query directly
            do {
                let data = try await appModel.api.executeGraphQLQuery(query)

                struct FindScenesResponse: Decodable {
                    struct Data: Decodable {
                        struct FindScenes: Decodable {
                            let count: Int
                            let scenes: [StashScene]
                        }
                        let findScenes: FindScenes
                    }
                    let data: Data
                }

                let response = try JSONDecoder().decode(FindScenesResponse.self, from: data)

                await MainActor.run {
                    appModel.api.scenes = response.data.findScenes.scenes
                    // Also update local state
                    performerScenes = response.data.findScenes.scenes
                    print("‚úÖ Loaded \(response.data.findScenes.scenes.count) scenes in backup query")
                    print("‚úÖ Updated local performerScenes, count: \(performerScenes.count)")
                }
            } catch {
                print("‚ùå Backup query also failed: \(error.localizedDescription)")
            }
        }
    }
    
    private func loadMarkers() async {
        print("üîç LOADMARKERS - Starting load of markers for performer: \(performer.name) (ID: \(performer.id))")

        // Check if we already have markers loaded
        if !appModel.api.markers.isEmpty {
            print("‚úÖ LOADMARKERS - Already have \(appModel.api.markers.count) markers, skipping load")
            return
        }

        // Clear existing markers first
        await MainActor.run {
            appModel.api.markers = []
            print("üßπ LOADMARKERS - Cleared markers array")
        }

        print("üîÑ LOADMARKERS - Calling fetchPerformerMarkers for performer \(performer.id)")
        await appModel.api.fetchPerformerMarkers(performerId: performer.id, page: 1, appendResults: false)
        print("‚úÖ LOADMARKERS - Loaded \(appModel.api.markers.count) markers for performer: \(performer.name)")
    }
    
    private func getMarkerCount() async -> Int {
        // Using the correct format and modifiers that match Vision Pro implementation
        let query = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "q": "",
                    "page": 1,
                    "per_page": 1,
                    "sort": "title",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    "performers": {
                        "value": ["\(performer.id)"],
                        "modifier": "INCLUDES"
                    }
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count } }"
        }
        """

        do {
            print("üìä Fetching marker count for performer: \(performer.name) (ID: \(performer.id))")
            // Use the executeGraphQLQuery method that we've enhanced with proper auth
            let data = try await appModel.api.executeGraphQLQuery(query)

            // Debug the response
            if let responseStr = String(data: data, encoding: .utf8) {
                print("üìä Marker count raw response: \(responseStr.prefix(100))...")
            }

            struct MarkerCountResponse: Decodable {
                let data: DataResponse

                struct DataResponse: Decodable {
                    let findSceneMarkers: MarkersResponse

                    struct MarkersResponse: Decodable {
                        let count: Int
                    }
                }
            }

            let response = try JSONDecoder().decode(MarkerCountResponse.self, from: data)
            print("‚úÖ Found \(response.data.findSceneMarkers.count) markers for performer \(performer.name)")
            return response.data.findSceneMarkers.count
        } catch {
            print("‚ùå Error fetching marker count: \(error)")
            // Provide detailed error info for debugging
            if let decodingError = error as? DecodingError {
                switch decodingError {
                case .keyNotFound(let key, let context):
                    print("Missing key: \(key) - \(context.debugDescription)")
                case .typeMismatch(let type, let context):
                    print("Type mismatch: \(type) - \(context.debugDescription)")
                case .valueNotFound(let type, let context):
                    print("Value not found: \(type) - \(context.debugDescription)")
                case .dataCorrupted(let context):
                    print("Data corrupted: \(context.debugDescription)")
                @unknown default:
                    print("Unknown decoding error")
                }
            }
            return 0
        }
    }
}

================
File: stash/Views/Performers/PerformerHeaderView.swift
================
import SwiftUI

struct PerformerHeaderView: View {
    let performer: StashScene.Performer
    
    var body: some View {
        VStack(spacing: 16) {
            if let imagePath = performer.image_path {
                AsyncImage(url: URL(string: imagePath)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Color.gray.opacity(0.2)
                }
                .frame(width: 200, height: 200)
                .clipShape(Circle())
            }
            
            VStack(spacing: 8) {
                Text(performer.name)
                    .font(.title)
                
                if let sceneCount = performer.scene_count {
                    Text("\(sceneCount) scenes")
                        .foregroundColor(.secondary)
                }
                
                if let rating = performer.rating100 {
                    HStack {
                        ForEach(0..<5) { index in
                            Image(systemName: index < rating/20 ? "star.fill" : "star")
                                .foregroundColor(.yellow)
                        }
                    }
                }
            }
        }
    }
}

================
File: stash/Views/Performers/PerformerMarkerDetailView.swift
================
import SwiftUI

struct PerformerMarkerDetailView: View {
    let performer: StashScene.Performer
    @EnvironmentObject private var appModel: AppModel
    @State private var currentPage = 1
    @State private var isLoadingMore = false
    @State private var hasMorePages = true
    @State private var selectedTag: StashScene.Tag?
    @State private var markerCount: Int = 0
    
    private let columns = [
        GridItem(.adaptive(minimum: 300, maximum: 400), spacing: 16)
    ]
    
    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                // Performer header
                PerformerHeaderView(performer: performer)
                
                // Show marker count
                Text("\(markerCount) markers")
                    .foregroundColor(.secondary)
                    .padding(.bottom)
                
                // Markers grid
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(appModel.api.markers) { marker in
                        MarkerRow(
                            marker: marker,
                            serverAddress: appModel.serverAddress,
                            onTitleTap: { _ in },
                            onTagTap: { tagName in
                                print("üîç Setting tag filter: \(tagName)")
                                // Handle tag selection if needed
                            }
                        )
                        .onAppear {
                            if marker == appModel.api.markers.last && !isLoadingMore && hasMorePages {
                                Task {
                                    await loadMoreMarkers()
                                }
                            }
                        }
                    }
                    
                    if isLoadingMore {
                        ProgressView()
                            .gridCellColumns(columns.count)
                            .padding()
                    }
                }
                .padding()
            }
        }
        .navigationTitle(performer.name)
        .task {
            // Load marker count
            markerCount = await getMarkerCount()
            // Load initial markers
            await loadInitialMarkers()
        }
        .sheet(item: $selectedTag) { tag in
            NavigationStack {
                TaggedScenesView(tag: tag)
            }
        }
    }
    
    private func getMarkerCount() async -> Int {
        let query = """
        {"operationName":"FindSceneMarkers","variables":{"filter":{"q":"","page":1,"per_page":1,"sort":"title","direction":"ASC"},"scene_marker_filter":{"performers":{"value":["\(performer.id)"],"modifier":"INCLUDES"}}},"query":"query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) {\\n  findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) {\\n    count\\n    __typename\\n  }\\n}"}
        """
        
        guard let url = URL(string: "\(appModel.serverAddress)/graphql") else { return 0 }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue(appModel.serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            struct MarkerCountResponse: Decodable {
                let data: DataResponse
                
                struct DataResponse: Decodable {
                    let findSceneMarkers: MarkersResponse
                    
                    struct MarkersResponse: Decodable {
                        let count: Int
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkerCountResponse.self, from: data)
            return response.data.findSceneMarkers.count
        } catch {
            print("‚ùå Error fetching marker count: \(error)")
            return 0
        }
    }
    
    private func loadInitialMarkers() async {
        currentPage = 1
        hasMorePages = true
        isLoadingMore = false
        await appModel.api.fetchPerformerMarkers(performerId: performer.id, page: currentPage, appendResults: false)
    }
    
    private func loadMoreMarkers() async {
        guard !isLoadingMore else { return }

        isLoadingMore = true
        currentPage += 1

        let previousCount = appModel.api.markers.count
        await appModel.api.fetchPerformerMarkers(performerId: performer.id, page: currentPage, appendResults: true)

        hasMorePages = appModel.api.markers.count > previousCount
        isLoadingMore = false
    }
}

================
File: stash/Views/Performers/PerformerMarkerRow.swift
================
import SwiftUI

struct PerformerMarkerRow: View {
    let performer: StashScene.Performer
    @EnvironmentObject private var appModel: AppModel
    @State private var markerCount: Int = 0
    
    init(performer: StashScene.Performer) {
        self.performer = performer
    }
    
    var body: some View {
        VStack(alignment: .center, spacing: 12) {
            // Image
            if let imagePath = performer.image_path {
                AsyncImage(url: URL(string: imagePath)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Color.gray
                }
                .frame(width: 120, height: 120)
                .clipShape(Circle())
            }
            
            // Info
            VStack(alignment: .center, spacing: 4) {
                Text(performer.name)
                    .font(.headline)
                    .lineLimit(1)
                
                Text("\(markerCount) markers")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .task {
            await fetchMarkerCount()
        }
    }
    
    private func fetchMarkerCount() async {
        let query = """
        {"operationName":"FindSceneMarkers","variables":{"filter":{"q":"","page":1,"per_page":1,"sort":"title","direction":"ASC"},"scene_marker_filter":{"performers":{"value":["\(performer.id)"],"modifier":"INCLUDES"}}},"query":"query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) {\\n  findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) {\\n    count\\n    __typename\\n  }\\n}"}
        """
        
        guard let url = URL(string: "\(appModel.serverAddress)/graphql") else { return }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue(appModel.serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            struct MarkerCountResponse: Decodable {
                let data: DataResponse
                
                struct DataResponse: Decodable {
                    let findSceneMarkers: MarkersResponse
                    
                    struct MarkersResponse: Decodable {
                        let count: Int
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkerCountResponse.self, from: data)
            await MainActor.run {
                self.markerCount = response.data.findSceneMarkers.count
            }
        } catch {
            print("‚ùå Error fetching marker count: \(error)")
        }
    }
}

================
File: stash/Views/Performers/PerformerMarkersView.swift
================
import SwiftUI
import Combine
import os.log

/// A view that displays markers for a specific performer
struct PerformerMarkersView: View {
    // MARK: - Environment
    @EnvironmentObject private var appModel: AppModel
    
    // MARK: - Properties
    @State private var performer: StashScene.Performer? // Optional for selection mode
    
    // MARK: - State
    @State private var currentPage = 1
    @State private var isLoadingMore = false
    @State private var hasMorePages = true
    @State private var isInitialLoad = true
    @State private var selectedTag: StashScene.Tag?
    @State private var searchText = ""
    @State private var showFilterMenu = false
    @State private var sortOption: MarkerSortOption = .timestamp
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var totalCount = 0
    @State private var performersWithMarkerCount: [PerformerWithMarkerCount] = []
    @State private var isSortingByMarkers = true
    
    // MARK: - Constants
    private static let logger = Logger(subsystem: "com.ck.test.stash", category: "PerformerMarkersView")
    
    private let columns = [
        GridItem(.adaptive(minimum: 300, maximum: 400), spacing: 16)
    ]
    
    private let performerColumns = [
        GridItem(.adaptive(minimum: 160, maximum: 200), spacing: 16)
    ]
    
    // MARK: - Types
    struct PerformerWithMarkerCount: Identifiable, Hashable {
        let id: String
        let performer: StashScene.Performer
        let markerCount: Int
    
        static func == (lhs: PerformerWithMarkerCount, rhs: PerformerWithMarkerCount) -> Bool {
            return lhs.id == rhs.id
        }

        func hash(into hasher: inout Hasher) {
            hasher.combine(id)
        }
    }
    
    // MARK: - Initialization
    init(performer: StashScene.Performer? = nil) {
        // Use _performer to initialize the @State property
        self._performer = State(initialValue: performer)
        print("üé≠ PerformerMarkersView init with performer: \(performer?.name ?? "nil")")
    }
    
    // MARK: - Computed Properties
    /// Returns filtered markers for the current performer
    private func filteredMarkersForPerformer() -> [SceneMarker] {
        // No need to filter again as the API already returns only markers for the selected performer
        var markers = appModel.api.markers
        
        // Apply search filter if text is provided
        if !searchText.isEmpty {
            Self.logger.debug("Filtering by search text: \(searchText)")
            markers = markers.filter { marker in
                marker.title.localizedCaseInsensitiveContains(searchText) ||
                marker.primary_tag.name.localizedCaseInsensitiveContains(searchText) ||
                marker.tags.contains { $0.name.localizedCaseInsensitiveContains(searchText) } ||
                marker.scene.title?.localizedCaseInsensitiveContains(searchText) ?? false
            }
            Self.logger.debug("After text search: \(markers.count) markers remain")
        }
        
        // Apply tag filter if a tag is selected
        if let selectedTag = selectedTag {
            Self.logger.debug("Filtering by tag: \(selectedTag.name) (ID: \(selectedTag.id))")
            markers = markers.filter { marker in
                marker.primary_tag.id == selectedTag.id ||
                marker.tags.contains { $0.id == selectedTag.id }
            }
            Self.logger.debug("After tag filter: \(markers.count) markers remain")
        }
        
        return markers
    }
    
    // MARK: - View Body
    var body: some View {
        ZStack {
            ScrollView {
                if isInitialLoad {
                    loadingView
                } else if performer == nil {
                    // Show selection view when no performer is provided
                    performerSelectionView
                } else if appModel.api.isLoading {
                    markerLoadingView
                } else if appModel.api.markers.isEmpty {
                    emptyMarkersView
                } else {
                    markerListView
                }
            }
            .refreshable {
                await refreshContent()
            }
            .navigationTitle(performer?.name ?? "Performer Markers")
            .onChange(of: searchText) { _, _ in
                // Log search changes
                Self.logger.debug("Search text changed: \(searchText)")
            }
            
            // Error alert
            if showError {
                VStack {
                    Spacer()
                    
                    HStack {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .foregroundColor(.orange)
                        
                        Text(errorMessage)
                            .font(.subheadline)
                            .foregroundColor(.primary)
                        
                        Spacer()
                        
                        Button(action: {
                            withAnimation {
                                showError = false
                            }
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(UIColor.systemBackground))
                    .cornerRadius(10)
                    .shadow(radius: 5)
                    .padding()
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                }
                .zIndex(1)
            }
        }
        .task {
            // Show loading indicator at initial load
            isInitialLoad = true
            
            // If performer is provided, load their markers directly
            if let performer = performer {
                print("üé≠ PerformerMarkersView task: Loading markers for specific performer: \(performer.name)")
                await loadPerformerMarkers(performer: performer)
                isInitialLoad = false
            } else {
                // Otherwise load the selection view
                print("üé≠ PerformerMarkersView task: Loading performer selection view")
                
                // Load initial performers if needed
                if appModel.api.performers.isEmpty {
                    await loadPerformers()
                }
                
                // Load performers with marker counts
                await loadPerformerCounts()
                
                isInitialLoad = false
            }
        }
        .toolbar {
            if performer != nil {
                ToolbarItem(placement: .navigationBarTrailing) {
                    filterMenu
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        // Pop back to previous view since performer was passed in
                        appModel.popNavigation()
                    }) {
                        Image(systemName: "arrow.left")
                            .foregroundColor(.blue)
                    }
                }
            }
        }
        .sheet(item: $selectedTag) { tag in
            NavigationStack {
                TaggedScenesView(tag: tag)
                    .environmentObject(appModel)
                    .toolbar {
                        ToolbarItem(placement: .navigationBarLeading) {
                            Button("Close") {
                                selectedTag = nil
                            }
                        }
                    }
            }
        }
    }
    
    // MARK: - Subviews
    
    /// Loading view for initial content load
    private var loadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle())
                .scaleEffect(1.5)
                .padding()
            
            Text("Loading performers and marker counts...")
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 100)
        .frame(maxWidth: .infinity)
    }
    
    /// View for selecting a performer
    private var performerSelectionView: some View {
        VStack {
            // Sort toggle and count indicator
            HStack {
                Toggle("Sort by marker count", isOn: $isSortingByMarkers)
                
                Spacer()
                
                Text("\(performersWithMarkerCount.count) performers found")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding()
            
            if performersWithMarkerCount.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "person.slash")
                        .font(.system(size: 50))
                        .foregroundColor(.secondary)
                        .padding()
                    
                    Text("No performers found")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Button(action: {
                        Task {
                            await loadPerformers()
                            await loadPerformerCounts()
                        }
                    }) {
                        Text("Refresh")
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                }
                .padding(.vertical, 100)
                .frame(maxWidth: .infinity)
            } else {
                // Performer selection grid with marker counts
                LazyVGrid(columns: performerColumns, spacing: 16) {
                    ForEach(performersWithMarkerCount.sorted { item1, item2 in
                        if isSortingByMarkers {
                            return item1.markerCount > item2.markerCount
                        } else {
                            return item1.performer.name < item2.performer.name
                        }
                    }) { item in
                        Button(action: {
                            // Set state first
                            self.performer = item.performer
                            
                            // Important - start loading immediately
                            Task {
                                if let performer = self.performer {
                                    print("üíæ Selected performer \(performer.name), loading markers")
                                    await loadPerformerMarkers(performer: performer)
                                }
                            }
                        }) {
                            VStack {
                                // Performer avatar or placeholder
                                if let imagePath = item.performer.image_path, !imagePath.isEmpty {
                                    AsyncImage(url: URL(string: "\(appModel.serverAddress)\(imagePath)")) { image in
                                        image
                                            .resizable()
                                            .aspectRatio(contentMode: .fill)
                                    } placeholder: {
                                        Rectangle()
                                            .fill(Color.gray.opacity(0.2))
                                    }
                                    .frame(width: 120, height: 120)
                                    .clipShape(Circle())
                                } else {
                                    Image(systemName: "person.circle.fill")
                                        .resizable()
                                        .aspectRatio(contentMode: .fit)
                                        .frame(width: 120, height: 120)
                                        .foregroundColor(.gray)
                                }
                                
                                // Performer name
                                Text(item.performer.name)
                                    .font(.headline)
                                    .lineLimit(1)
                                
                                // Marker count badge
                                Text("\(item.markerCount) markers")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.blue.opacity(0.1))
                                    .cornerRadius(8)
                            }
                            .padding()
                            .background(Color(UIColor.secondarySystemBackground))
                            .cornerRadius(12)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding()
            }
        }
    }
    
    /// Loading view for marker content
    private var markerLoadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle())
                .scaleEffect(1.5)
                .padding()

            Text("Loading markers for \(performer?.name ?? "performer")...")
                .foregroundColor(.secondary)
            
            // Add cancel button
            Button("Cancel") {
                // Cancel loading
                appModel.api.isLoading = false
                appModel.popNavigation()
            }
            .padding(.top, 16)
        }
        .padding(.vertical, 100)
        .frame(maxWidth: .infinity)
    }
    
    /// Empty state view for when no markers are found
    private var emptyMarkersView: some View {
        VStack(spacing: 16) {
            Image(systemName: "bookmark.slash")
                .font(.system(size: 50))
                .foregroundColor(.secondary)
                .padding()

            Text("No markers found for \(performer?.name ?? "performer")")
                .font(.headline)
                .foregroundColor(.secondary)

            if searchText.isNotEmpty {
                Text("Try clearing your search or filter")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            if let selectedTag = selectedTag {
                Text("Filter active: \(selectedTag.name)")
                    .font(.subheadline)
                    .foregroundColor(.blue)
                
                Button("Clear Tag Filter") {
                    withAnimation {
                        self.selectedTag = nil
                        Self.logger.debug("Tag filter cleared from empty state view")
                    }
                }
                .buttonStyle(.borderedProminent)
                .padding(.vertical, 4)
            }
            
            if let performer = performer {
                Text("ID: \(performer.id)")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            if let error = appModel.api.error {
                Text("Error: \(error.localizedDescription)")
                    .font(.caption)
                    .foregroundColor(.red)
                    .padding()
                
                Button("Retry") {
                    if let performer = performer {
                        Task {
                            await loadPerformerMarkers(performer: performer)
                        }
                    }
                }
                .buttonStyle(.bordered)
                .padding(.vertical, 4)
            }

            HStack(spacing: 16) {
                Button("Select Different Performer") {
                    // Pop navigation instead of setting state to nil
                    appModel.popNavigation()
                    appModel.api.markers = []
                    searchText = ""
                    selectedTag = nil
                }
                .buttonStyle(.bordered)
                
                if let performer = performer {
                    Button("Reload Markers") {
                        Task {
                            await loadPerformerMarkers(performer: performer)
                        }
                    }
                    .buttonStyle(.borderedProminent)
                }
            }
            .padding()
        }
        .padding()
    }
    
    /// View for displaying markers
    private var markerListView: some View {
        VStack(spacing: 16) {
            // Header with performer info, back button, and filter options
            HStack {
                Button(action: {
                    // Pop navigation instead of setting state to nil
                    appModel.popNavigation()
                    appModel.api.markers = []
                    searchText = ""
                    selectedTag = nil
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                        Text("Back")
                    }
                }
                Spacer()
                
                if let performer = performer {
                    Text("\(performer.name)'s Markers (\(filteredMarkersForPerformer().count))")
                        .font(.headline)
                }
                
                Spacer()
                
                // Search button
                if !searchText.isEmpty {
                    Button(action: {
                        searchText = ""
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding(.horizontal)
            
            // Search bar if there are markers
            if !appModel.api.markers.isEmpty {
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.secondary)
                    
                    TextField("Search markers", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    if !searchText.isEmpty {
                        Button(action: {
                            searchText = ""
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.secondary)
                        }
                    }
                }
                .padding(.horizontal)
                .padding(.bottom, 8)
            }
            
            // Filter chips for active filters
            if selectedTag != nil {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        if let tag = selectedTag {
                            HStack {
                                Text(tag.name)
                                    .font(.caption)
                                    .padding(.leading, 8)
                                    .padding(.trailing, 4)
                                    .padding(.vertical, 4)
                                
                                Button(action: {
                                    selectedTag = nil
                                }) {
                                    Image(systemName: "xmark.circle.fill")
                                        .font(.caption)
                                }
                                .padding(.trailing, 8)
                            }
                            .background(Color.blue.opacity(0.2))
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal)
                }
            }
            
            // Markers grid
            LazyVGrid(columns: columns, spacing: 16) {
                ForEach(filteredMarkersForPerformer()) { marker in
                    MarkerRow(
                        marker: marker,
                        serverAddress: appModel.serverAddress,
                        onTitleTap: { marker in
                            appModel.navigateToMarker(marker)
                        },
                        onTagTap: { tagName in
                            print("üîç Setting tag filter: \(tagName)")
                            // Find the tag from available tags with more robust search
                            if let tag = appModel.api.markers.flatMap({ [$0.primary_tag] + $0.tags }).first(where: { $0.name == tagName }) {
                                Self.logger.debug("Setting tag filter from tap: \(tagName) (ID: \(tag.id))")
                                
                                // Use withAnimation for smoother state transition
                                withAnimation {
                                    selectedTag = StashScene.Tag(id: tag.id, name: tag.name)
                                }
                                
                                // Log the active filter
                                Self.logger.debug("Active tag filter set to: \(tag.name)")
                            } else {
                                Self.logger.error("Could not find tag with name: \(tagName)")
                                
                                // Show error message to user
                                showErrorMessage("Could not set filter for tag: \(tagName)")
                            }
                        }
                    )
                    .contextMenu {
                        Button(action: {
                            appModel.navigateToMarker(marker)
                        }) {
                            Label("Play Marker", systemImage: "play.fill")
                        }
                        
                        Button(action: {
                            // Copy marker URL to clipboard
                            UIPasteboard.general.string = "\(appModel.serverAddress)/markers/\(marker.id)"
                        }) {
                            Label("Copy Link", systemImage: "link")
                        }
                        
                        if let scene = appModel.api.scenes.first(where: { $0.id == marker.scene.id }) {
                            Button(action: {
                                appModel.currentScene = scene
                                appModel.navigationPath.append(scene)
                            }) {
                                Label("Go to Scene", systemImage: "film")
                            }
                        }
                    }
                    .onAppear {
                        let filteredMarkers = filteredMarkersForPerformer()
                        if marker == filteredMarkers.last && !isLoadingMore && hasMorePages {
                            Task {
                                await loadMoreMarkers()
                            }
                        }
                    }
                }
                
                if isLoadingMore {
                    ProgressView()
                        .padding()
                }
            }
            .padding()
        }
    }
    
    /// Filter menu with sorting options and filter settings
    private var filterMenu: some View {
        Menu {
            Section("Sort By") {
                ForEach(MarkerSortOption.allCases) { option in
                    Button(action: {
                        sortOption = option
                        sortMarkers()
                    }) {
                        HStack {
                            Text(option.label)
                            if sortOption == option {
                                Image(systemName: "checkmark")
                            }
                        }
                    }
                }
            }
            
            if let performer = performer {
                Section("Tags") {
                    // Get unique tags from markers
                    let allTags = Array(Set(appModel.api.markers.flatMap { [$0.primary_tag] + $0.tags }))
                    let sortedTags = allTags.sorted { $0.name < $1.name }
                    
                    // Option to show all (clear filter)
                    Button(action: {
                        selectedTag = nil
                    }) {
                        HStack {
                            Text("All Tags")
                            if selectedTag == nil {
                                Image(systemName: "checkmark")
                            }
                        }
                    }
                    
                    // Tag options
                    ForEach(sortedTags) { tag in
                        Button(action: {
                            // Convert to StashScene.Tag with proper animation
                            withAnimation {
                                Self.logger.debug("Setting tag filter from menu: \(tag.name) (ID: \(tag.id))")
                                selectedTag = StashScene.Tag(id: tag.id, name: tag.name)
                            }
                        }) {
                            HStack {
                                Text(tag.name)
                                if selectedTag?.id == tag.id {
                                    Image(systemName: "checkmark")
                                }
                            }
                        }
                    }
                }
                
                // Refresh option
                Section {
                    Button(action: {
                        Task {
                            await loadPerformerMarkers(performer: performer)
                        }
                    }) {
                        Label("Refresh Markers", systemImage: "arrow.clockwise")
                    }
                }
            }
        } label: {
            Image(systemName: "line.3.horizontal.decrease.circle")
        }
    }
    
    // MARK: - Methods
    
    /// Load performers from the API
    private func loadPerformers() async {
        do {
            await appModel.api.fetchPerformers(completion: { result in
                switch result {
                case .success(let performers):
                    Self.logger.info("Successfully loaded \(performers.count) performers")
                case .failure(let error):
                    Self.logger.error("Error loading performers: \(error.localizedDescription)")
                    showErrorMessage("Failed to load performers: \(error.localizedDescription)")
                }
            })
        } catch {
            Self.logger.error("Error loading performers: \(error.localizedDescription)")
            showErrorMessage("Failed to load performers: \(error.localizedDescription)")
        }
    }
    
    /// Load performer marker counts
    private func loadPerformerCounts() async {
        Self.logger.info("Loading marker counts for \(appModel.api.performers.count) performers")
        performersWithMarkerCount = []
        
        // Use Batch API methods
        await withTaskGroup(of: PerformerWithMarkerCount?.self) { group in
            for performer in appModel.api.performers {
                group.addTask {
                    let count = await getMarkerCount(for: performer)
                    return PerformerWithMarkerCount(
                        id: performer.id,
                        performer: performer,
                        markerCount: count
                    )
                }
            }
            
            for await result in group {
                if let result = result {
                    await MainActor.run {
                        performersWithMarkerCount.append(result)
                    }
                }
            }
        }
        
        // Sort by marker count by default
        await MainActor.run {
            performersWithMarkerCount.sort { $0.markerCount > $1.markerCount }
        }
    }
    
    /// Get marker count for a performer
    private func getMarkerCount(for performer: StashScene.Performer) async -> Int {
        // Using the updated format that matches Vision Pro and fixed JSON format
        let query = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "q": "",
                    "page": 1,
                    "per_page": 1,
                    "sort": "title",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    "performers": {
                        "value": ["\(performer.id)"],
                        "modifier": "INCLUDES"
                    }
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count } }"
        }
        """

        // Use the StashAPI's executeGraphQLQuery method
        do {
            Self.logger.debug("Fetching marker count for performer: \(performer.name) (ID: \(performer.id))")
            let data = try await appModel.api.executeGraphQLQuery(query)

            struct MarkerCountResponse: Decodable {
                let data: DataResponse

                struct DataResponse: Decodable {
                    let findSceneMarkers: MarkersResponse

                    struct MarkersResponse: Decodable {
                        let count: Int
                    }
                }
            }

            let response = try JSONDecoder().decode(MarkerCountResponse.self, from: data)
            Self.logger.debug("Found \(response.data.findSceneMarkers.count) markers for performer \(performer.name)")
            return response.data.findSceneMarkers.count
        } catch {
            Self.logger.error("Error fetching marker count for \(performer.name): \(error.localizedDescription)")
            return 0
        }
    }
    
    /// Load markers for a performer
    private func loadPerformerMarkers(performer: StashScene.Performer) async {
        Self.logger.info("Loading markers for performer: \(performer.name) (ID: \(performer.id))")
        currentPage = 1
        hasMorePages = true
        isLoadingMore = false
        searchText = ""
        selectedTag = nil
        
        // Show loading state
        await MainActor.run {
            appModel.api.isLoading = true
            appModel.api.markers = []
            appModel.api.error = nil
        }

        do {
            print("üß© DEBUG MARKERVM: Using direct GraphQL query for performer markers")
            
            // Use the suggested GraphQL query directly with INCLUDES_ALL
            let randomSeed = "random_\(Int.random(in: 100000...999999))"
            
            let query = """
            {
              "operationName": "FindSceneMarkers",
              "variables": {
                "filter": {
                  "page": 1,
                  "per_page": 40,
                  "sort": "\(randomSeed)",
                  "direction": "ASC"
                },
                "scene_marker_filter": {
                  "performers": {
                    "value": ["\(performer.id)"],
                    "modifier": "INCLUDES_ALL"
                  }
                }
              },
              "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title files { width height path } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
            }
            """
            
            print("üß© DEBUG MARKERVM: Executing GraphQL query with INCLUDES_ALL modifier")
            let data = try await appModel.api.executeGraphQLQuery(query)
            
            // Define new response structure to match the different API response
            struct MarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindMarkers
                }
                let data: Data
            }
            
            let response = try JSONDecoder().decode(MarkersResponse.self, from: data)
            let loadedMarkers = response.data.findSceneMarkers.scene_markers
            
            await MainActor.run {
                // Update marker data
                appModel.api.markers = loadedMarkers
                appModel.api.isLoading = false
                
                // Track total and check for more pages
                totalCount = loadedMarkers.count
                hasMorePages = loadedMarkers.count >= 20 // Assuming default page size is 20
                
                // Apply sorting
                sortMarkers()
            }
            
            Self.logger.info("Successfully loaded \(loadedMarkers.count) markers for performer \(performer.name)")
        } catch {
            Self.logger.error("Error loading markers: \(error.localizedDescription)")
            await MainActor.run {
                appModel.api.error = error
                appModel.api.isLoading = false
                showErrorMessage("Failed to load markers: \(error.localizedDescription)")
            }
        }
    }
    
    /// Load more markers (pagination)
    private func loadMoreMarkers() async {
        guard !isLoadingMore, hasMorePages else { return }
        guard let performer = performer else { return }

        Self.logger.info("Loading more markers for performer: \(performer.name) (page \(currentPage + 1))")
        isLoadingMore = true
        currentPage += 1

        // Remember the previous count for comparison
        let previousCount = appModel.api.markers.count

        // Use the same GraphQL approach as loadPerformerMarkers but with updated page number
        do {
            let randomSeed = "random_\(Int.random(in: 100000...999999))"
            
            let query = """
            {
              "operationName": "FindSceneMarkers",
              "variables": {
                "filter": {
                  "page": \(currentPage),
                  "per_page": 40,
                  "sort": "\(randomSeed)",
                  "direction": "ASC"
                },
                "scene_marker_filter": {
                  "performers": {
                    "value": ["\(performer.id)"],
                    "modifier": "INCLUDES_ALL"
                  }
                }
              },
              "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title files { width height path } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
            }
            """
            
            let data = try await appModel.api.executeGraphQLQuery(query)
            
            struct MarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindMarkers
                }
                let data: Data
            }
            
            let response = try JSONDecoder().decode(MarkersResponse.self, from: data)
            let newMarkers = response.data.findSceneMarkers.scene_markers
            
            await MainActor.run {
                // Append new markers to existing ones, avoiding duplicates
                let uniqueNewMarkers = newMarkers.filter { newMarker in
                    !appModel.api.markers.contains { $0.id == newMarker.id }
                }
                appModel.api.markers.append(contentsOf: uniqueNewMarkers)
                
                // Update tracking for more pages
                hasMorePages = !newMarkers.isEmpty && newMarkers.count >= 20 // Assuming default page size is 20
                
                // Apply current sorting to keep consistency
                sortMarkers()
            }
            
            // Log results
            let newCount = appModel.api.markers.count
            let addedCount = newCount - previousCount
            Self.logger.info("Added \(addedCount) markers (total now: \(newCount))")
        } catch {
            Self.logger.error("Error loading more markers: \(error.localizedDescription)")
            await MainActor.run {
                appModel.api.error = error
                showErrorMessage("Failed to load more markers: \(error.localizedDescription)")
            }
        }

        // Update loading state
        hasMorePages = appModel.api.markers.count > previousCount
        isLoadingMore = false
    }
    
    /// Sort markers based on current sort option
    private func sortMarkers() {
        Self.logger.debug("Sorting markers using option: \(sortOption.rawValue)")
        
        // Sort markers array based on current sort option
        switch sortOption {
        case .timestamp:
            appModel.api.markers.sort { $0.seconds < $1.seconds }
        case .title:
            appModel.api.markers.sort { $0.title.localizedCaseInsensitiveCompare($1.title) == .orderedAscending }
        case .createdAtDesc:
            // Sort by ID as fallback for creation order
            appModel.api.markers.sort { $0.id > $1.id }
        case .createdAtAsc:
            // Sort by ID as fallback for creation order
            appModel.api.markers.sort { $0.id < $1.id }
        case .sceneTitleAsc:
            appModel.api.markers.sort { ($0.scene.title ?? "").localizedCaseInsensitiveCompare($1.scene.title ?? "") == .orderedAscending }
        case .sceneTitleDesc:
            appModel.api.markers.sort { ($0.scene.title ?? "").localizedCaseInsensitiveCompare($1.scene.title ?? "") == .orderedDescending }
        }
        
        Self.logger.debug("Sorted \(appModel.api.markers.count) markers")
    }
    
    /// Display error message
    private func showErrorMessage(_ message: String) {
        withAnimation {
            errorMessage = message
            showError = true
            
            // Auto-hide error after 5 seconds
            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                withAnimation {
                    if self.errorMessage == message {
                        self.showError = false
                    }
                }
            }
        }
    }
    
    /// Refresh content based on current view state
    private func refreshContent() async {
        if let performer = performer {
            await loadPerformerMarkers(performer: performer)
        } else {
            await loadPerformers()
            await loadPerformerCounts()
        }
    }
}

// MARK: - String Extensions
extension String {
    var isNotEmpty: Bool {
        !self.isEmpty
    }
}

// MARK: - Preview
struct PerformerMarkersView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            PerformerMarkersView()
                .environmentObject(AppModel())
        }
    }
}

================
File: stash/Views/Performers/PerformerRow.swift
================
import SwiftUI

struct PerformerRow: View {
    let performer: StashScene.Performer
    
    var body: some View {
        VStack(alignment: .center, spacing: 12) {
            // Image
            if let imagePath = performer.image_path {
                AsyncImage(url: URL(string: imagePath)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Color.gray
                }
                .frame(width: 120, height: 120)
                .clipShape(Circle())
            }
            
            // Info
            VStack(alignment: .center, spacing: 4) {
                Text(performer.name)
                    .font(.headline)
                    .lineLimit(1)
                
                if let count = performer.scene_count {
                    Text("\(count) scenes")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
    }
}

// MARK: - Preview Provider
struct PerformerRow_Previews: PreviewProvider {
    static var previews: some View {
        PerformerRow(performer: StashScene.Performer(
            id: "1",
            name: "Test Performer",
            gender: "FEMALE",
            image_path: nil,
            scene_count: 10,
            favorite: false,
            rating100: 80
        ))
        .previewLayout(.sizeThatFits)
        .padding()
    }
}

================
File: stash/Views/Performers/PerformerTabView.swift
================
import SwiftUI

struct PerformerTabView: View {
    let performer: StashScene.Performer
    @EnvironmentObject private var appModel: AppModel
    @State private var selectedTab = 0 // 0 for scenes, 1 for markers
    @State private var markerCount: Int = 0
    @State private var isLoadingMore = false
    @State private var hasMorePages = true
    @State private var currentPage = 1
    @State private var selectedTag: StashScene.Tag?
    
    private let columns = [
        GridItem(.adaptive(minimum: 300, maximum: 400), spacing: 16)
    ]
    
    init(performer: StashScene.Performer) {
        self.performer = performer
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 0) {
                // Performer header
                PerformerHeaderView(performer: performer)
                
                // Tab picker - use stronger typing and perform change immediately
                Picker("View", selection: Binding(
                    get: { self.selectedTab },
                    set: { newValue in
                        self.selectedTab = newValue
                        print("üí´ Tab changed to: \(newValue)")
                        
                        // Perform content loading immediately when tab changes
                        Task {
                            // Reset pagination when switching tabs
                            currentPage = 1
                            hasMorePages = true
                            isLoadingMore = false
                            
                            // Clear existing content for both tabs to avoid memory issues
                            appModel.api.scenes = []
                            appModel.api.markers = []
                            
                            // Load the appropriate content
                            if newValue == 0 {
                                print("üí´ Loading scenes for tab change")
                                await loadScenes()
                            } else {
                                print("üí´ FORCING marker reload with direct search")
                                // Force a fresh load of markers with our direct filtering approach
                                await loadMarkers()
                            }
                        }
                    }
                )) {
                    Text("Scenes").tag(0)
                    Text("Markers").tag(1)
                }
                .pickerStyle(.segmented)
                .padding()
                
                // Content based on selected tab
                if selectedTab == 0 {
                    scenesContent
                } else {
                    markersContent
                }
            }
        }
        .navigationTitle(performer.name)
        .task {
            // Reset state when view appears
            print("üöÄ TASK: PerformerTabView appeared, selectedTab: \(selectedTab)")
            currentPage = 1
            hasMorePages = true
            isLoadingMore = false
            appModel.api.scenes = []  // Clear existing content
            appModel.api.markers = []
            
            // Load initial content based on selected tab
            if selectedTab == 0 {
                print("üöÄ TASK: Loading scenes initially")
                await loadScenes()
            } else {
                print("üöÄ TASK: Loading markers initially")
                await loadMarkers()
            }
            
            // Get marker count
            markerCount = await getMarkerCount()
        }
        // Removed onChange handler since we're handling tab changes directly in the Picker's binding
        .sheet(item: $selectedTag) { tag in
            NavigationStack {
                TaggedScenesView(tag: tag)
            }
        }
    }
    
    private var scenesContent: some View {
        VStack {
            if appModel.api.scenes.isEmpty {
                Text("No scenes found")
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(appModel.api.scenes) { scene in
                        SceneRow(
                            scene: scene,
                            onTagSelected: { selectedTag = $0 },
                            onPerformerSelected: { _ in },  // Ignore performer selection in performer view
                            onSceneUpdated: { _ in },
                            onSceneSelected: { selectedScene in
                                if let url = URL(string: selectedScene.paths.stream) {
                                    if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                                       let window = windowScene.windows.first,
                                       let rootViewController = window.rootViewController {
                                        let controller = VideoPlayerUtility.createPlayerViewController(
                                            url: url,
                                            startTime: UserDefaults.standard.getVideoProgress(for: selectedScene.id),
                                            scenes: appModel.api.scenes,
                                            currentIndex: appModel.api.scenes.firstIndex(of: selectedScene) ?? 0,
                                            appModel: appModel
                                        )
                                        rootViewController.present(controller, animated: true)
                                    }
                                }
                            }
                        )
                        .onTapGesture {
                            if let url = URL(string: scene.paths.stream) {
                                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                                   let window = windowScene.windows.first,
                                   let rootViewController = window.rootViewController {
                                    let controller = VideoPlayerUtility.createPlayerViewController(
                                        url: url,
                                        startTime: UserDefaults.standard.getVideoProgress(for: scene.id),
                                        scenes: appModel.api.scenes,
                                        currentIndex: appModel.api.scenes.firstIndex(of: scene) ?? 0,
                                        appModel: appModel
                                    )
                                    rootViewController.present(controller, animated: true)
                                }
                            }
                        }
                        .onAppear {
                            if scene == appModel.api.scenes.last && !isLoadingMore && hasMorePages {
                                Task {
                                    await loadMoreScenes()
                                }
                            }
                        }
                    }
                    
                    if isLoadingMore {
                        ProgressView()
                            .gridCellColumns(columns.count)
                            .padding()
                    }
                }
                .padding()
            }
        }
    }
    
    private var markersContent: some View {
        VStack(spacing: 0) {
            // Force marker reload when this view appears
            Color.clear
                .frame(width: 0, height: 0)
                .onAppear {
                    print("üí° MARKERS TAB - Tab content appeared directly")
                    
                    // Always force marker reload, clearing any existing markers
                    print("üí´ FORCE-CLEARING any existing markers")
                    Task {
                        // Clear markers first
                        await MainActor.run {
                            appModel.api.markers = []
                        }
                        // Then load fresh filtered markers
                        print("üí´ FORCING fresh marker load from onAppear")
                        await loadMarkers()
                    }
                }
            // Status view for loading/empty state
            if appModel.api.markers.isEmpty {
                if appModel.api.isLoading {
                    VStack(spacing: 16) {
                        ProgressView()
                            .scaleEffect(1.5)
                            .padding()
                        
                        Text("Loading markers for \(performer.name)...")
                            .foregroundColor(.secondary)
                    }
                    .padding(.vertical, 60)
                    .frame(maxWidth: .infinity)
                } else {
                    VStack(spacing: 16) {
                        Image(systemName: "bookmark.slash")
                            .font(.system(size: 50))
                            .foregroundColor(.secondary)
                            .padding()
                        
                        Text("No markers found for \(performer.name)")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        
                        Button("Reload") {
                            Task {
                                currentPage = 1
                                await loadMarkers()
                            }
                        }
                        .buttonStyle(.borderedProminent)
                        .padding(.top, 8)
                    }
                    .padding(.vertical, 60)
                    .frame(maxWidth: .infinity)
                }
            } else {
                // VStack containing grid to allow onAppear modifier
                VStack {
                    // Color.clear for onAppear trigger - placed outside LazyVGrid
                    Color.clear
                        .frame(height: 0)
                        .onAppear {
                            // Force filtering of markers even if we didn't properly load them
                            let allMarkers = appModel.api.markers
                            print("üåü MARKERS GRID - LazyVGrid with \(allMarkers.count) raw markers")
                            
                            // Even if our main loading function failed, filter them here as a backup
                            if !allMarkers.isEmpty {
                                // Filter markers to only include those with this performer
                                let filteredMarkers = allMarkers.filter { marker in
                                    if let scenePerformers = marker.scene.performers {
                                        // Check if any performer matches our performer ID
                                        return scenePerformers.contains { $0.id == performer.id }
                                    }
                                    return false
                                }
                                
                                // If we have a different count after filtering, update the markers
                                if filteredMarkers.count != allMarkers.count {
                                    print("‚ö°Ô∏è EMERGENCY FILTER: Filtered \(allMarkers.count) markers to \(filteredMarkers.count) for performer \(performer.name)")
                                    
                                    // Schedule a task to update the markers
                                    Task { @MainActor in
                                        appModel.api.markers = filteredMarkers
                                    }
                                }
                            }
                        }
                    
                    // Grid with same styling as scenes tab
                    LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(appModel.api.markers) { marker in
                        // Custom compact marker row that matches the SceneRow style
                        VStack(alignment: .leading) {
                            // Thumbnail with timestamp
                            ZStack {
                                // Thumbnail
                                AsyncImage(url: URL(string: marker.screenshot)) { image in
                                    image
                                        .resizable()
                                        .aspectRatio(contentMode: .fill)
                                } placeholder: {
                                    Rectangle()
                                        .fill(Color.gray.opacity(0.2))
                                }
                                .frame(height: 180)
                                .clipped()
                                
                                // Timestamp overlay
                                HStack {
                                    Text(formatDuration(marker.seconds))
                                        .font(.caption)
                                        .padding(.horizontal, 8)
                                        .padding(.vertical, 4)
                                        .background(.ultraThinMaterial)
                                        .cornerRadius(4)
                                    
                                    Spacer()
                                    
                                    // Play button
                                    Button {
                                        appModel.navigateToMarker(marker)
                                    } label: {
                                        Image(systemName: "play.circle.fill")
                                            .font(.system(size: 32))
                                            .foregroundColor(.white)
                                            .shadow(color: .black.opacity(0.6), radius: 2)
                                    }
                                    .padding(8)
                                }
                                .padding(8)
                            }
                            
                            // Info section
                            VStack(alignment: .leading, spacing: 8) {
                                // Title
                                Text(marker.title)
                                    .font(.headline)
                                    .lineLimit(1)
                                
                                // Tags
                                ScrollView(.horizontal, showsIndicators: false) {
                                    HStack {
                                        Text(marker.primary_tag.name)
                                            .font(.caption)
                                            .padding(.horizontal, 8)
                                            .padding(.vertical, 4)
                                            .background(Color.blue.opacity(0.2))
                                            .cornerRadius(12)
                                        
                                        ForEach(marker.tags) { tag in
                                            Text(tag.name)
                                                .font(.caption)
                                                .padding(.horizontal, 8)
                                                .padding(.vertical, 4)
                                                .background(Color.secondary.opacity(0.15))
                                                .cornerRadius(12)
                                        }
                                    }
                                }
                                
                                // Scene info
                                Text("From: \(marker.scene.title ?? "Unknown Scene")")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .padding(12)
                        }
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)
                        .shadow(radius: 2)
                        .onTapGesture {
                            appModel.navigateToMarker(marker)
                        }
                        .contextMenu {
                            Button(action: {
                                appModel.navigateToMarker(marker)
                            }) {
                                Label("Play Marker", systemImage: "play.fill")
                            }
                            
                            Button(action: {
                                // Copy marker URL to clipboard
                                UIPasteboard.general.string = "\(appModel.serverAddress)/markers/\(marker.id)"
                            }) {
                                Label("Copy Link", systemImage: "link")
                            }
                            
                            if let scene = appModel.api.scenes.first(where: { $0.id == marker.scene.id }) {
                                Button(action: {
                                    appModel.currentScene = scene
                                    appModel.navigationPath.append(scene)
                                }) {
                                    Label("Go to Scene", systemImage: "film")
                                }
                            }
                        }
                        .onAppear {
                            // Trigger pagination when nearing the end of the list
                            if marker.id == appModel.api.markers.last?.id, 
                               !isLoadingMore && hasMorePages {
                                print("üîÑ Last marker appeared - loading more markers")
                                Task {
                                    await loadMoreMarkers()
                                }
                            }
                        }
                    }
                    
                    // Loading indicator for pagination
                    if isLoadingMore {
                        ProgressView()
                            .scaleEffect(1.2)
                            .gridCellColumns(columns.count)
                            .padding(.vertical, 30)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 16)
                
                // Footer with stats
                if !appModel.api.markers.isEmpty {
                    HStack {
                        Spacer()
                        Text("\(appModel.api.markers.count) markers loaded")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.vertical, 8)
                }
                } // End of VStack
            }
        }
        .animation(.easeInOut(duration: 0.3), value: appModel.api.markers.count)
        .animation(.easeInOut(duration: 0.3), value: isLoadingMore)
        .animation(.easeInOut(duration: 0.3), value: appModel.api.isLoading)
    }
    
    private func loadScenes() async {
        print("üé≠ Loading scenes for performer: \(performer.name) with ID: \(performer.id)")
        await appModel.api.fetchPerformerScenes(
            performerId: performer.id,
            page: currentPage,
            sort: "date",
            direction: "DESC",
            appendResults: currentPage > 1
        )
    }
    
    private func loadMoreScenes() async {
        guard !isLoadingMore else { return }
        
        isLoadingMore = true
        currentPage += 1
        
        let previousCount = appModel.api.scenes.count
        await loadScenes()
        
        hasMorePages = appModel.api.scenes.count > previousCount
        isLoadingMore = false
    }
    
    private func loadMarkers() async {
        print("üîç Loading markers for performer: \(performer.name) (ID: \(performer.id))")
        
        // Set loading state
        await MainActor.run {
            appModel.api.isLoading = true
            appModel.api.markers = [] // Clear markers immediately
        }
        
        do {
            // COMPLETELY NEW APPROACH - Based on the email instructions
            // First, fetch all scenes for this performer
            print("üé¨ First fetching all scenes for this performer")
            
            // We'll use a query that gets scenes with their markers
            let query = """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "per_page": 40
                    },
                    "scene_filter": {
                        "performers": {
                            "value": ["\(performer.id)"],
                            "modifier": "INCLUDES"
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { scenes { id title scene_markers { id title seconds primary_tag { id name } tags { id name } stream preview screenshot } } } }"
            }
            """
            
            print("üì§ Executing GraphQL query to get scenes with markers")
            let data = try await appModel.api.executeGraphQLQuery(query)
            
            // Parse the response - structure based on the query
            struct SceneWithMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindScenes: Decodable {
                        struct Scene: Decodable {
                            let id: String
                            let title: String
                            let scene_markers: [SceneMarker]?
                        }
                        let scenes: [Scene]
                    }
                    let findScenes: FindScenes
                }
                let data: Data
            }
            
            let response = try JSONDecoder().decode(SceneWithMarkersResponse.self, from: data)
            
            // Extract all markers from all scenes
            var allMarkers: [SceneMarker] = []
            
            for scene in response.data.findScenes.scenes {
                if let markers = scene.scene_markers {
                    for marker in markers {
                        // Create a complete SceneMarker with scene info
                        // We need to do this since the API response doesn't include all required fields
                        let markerScene = SceneMarker.MarkerScene(
                            id: scene.id,
                            title: scene.title,
                            paths: SceneMarker.MarkerScene.ScenePaths(
                                screenshot: marker.screenshot,
                                preview: marker.preview,
                                stream: marker.stream
                            ),
                            performers: [performer] // We know this scene has this performer
                        )
                        
                        let completeMarker = SceneMarker(
                            id: marker.id,
                            title: marker.title,
                            seconds: marker.seconds,
                            end_seconds: nil, // No end_seconds available in this context
                            stream: marker.stream,
                            preview: marker.preview,
                            screenshot: marker.screenshot,
                            scene: markerScene,
                            primary_tag: marker.primary_tag,
                            tags: marker.tags
                        )
                        
                        allMarkers.append(completeMarker)
                    }
                }
            }
            
            print("‚úÖ Found \(allMarkers.count) markers across \(response.data.findScenes.scenes.count) scenes for performer \(performer.name)")
            
            await MainActor.run {
                // Set the markers
                appModel.api.markers = allMarkers
                
                if !allMarkers.isEmpty {
                    // Show details of the first few markers for verification
                    for (index, marker) in allMarkers.prefix(3).enumerated() {
                        print("  [\(index)] Marker: \(marker.title)")
                        print("      Scene: \(marker.scene.title ?? "Unknown")")
                        print("      Seconds: \(marker.seconds)")
                    }
                }
                
                // Clear loading states
                hasMorePages = false // Pagination not needed with this approach
                appModel.api.isLoading = false
                isLoadingMore = false
            }
        } catch {
            print("‚ùå Error loading markers: \(error.localizedDescription)")
            await MainActor.run {
                hasMorePages = false
                appModel.api.isLoading = false
                isLoadingMore = false
                appModel.api.error = error
            }
        }
    }
    
    private func loadMoreMarkers() async {
        guard !isLoadingMore, hasMorePages else { 
            print("‚ö†Ô∏è Skipping loadMoreMarkers - isLoadingMore: \(isLoadingMore), hasMorePages: \(hasMorePages)")
            return 
        }
        
        print("üîÑ Loading more markers is disabled with the local filtering approach")
        // With our local filtering approach, we don't need pagination since we load and filter
        // all markers at once. This function is kept for API compatibility but doesn't do anything.
    }
    
    private func getMarkerCount() async -> Int {
        print("üìä Getting marker count for performer: \(performer.name) (ID: \(performer.id))")
        
        // Use direct query just like in loadMarkers
        do {
            // First make sure authentication is working
            try? await appModel.api.checkServerConnection()
            
            // Query for just the count
            let query = """
            {
                "operationName": "FindSceneMarkers",
                "variables": {
                    "filter": {
                        "page": 1,
                        "per_page": 1
                    }
                },
                "query": "query FindSceneMarkers($filter: FindFilterType) { findSceneMarkers(filter: $filter) { count } }"
            }
            """
            
            let data = try await appModel.api.executeGraphQLQuery(query)
            
            struct CountResponse: Decodable {
                let data: DataField
                
                struct DataField: Decodable {
                    let findSceneMarkers: CountField
                    
                    struct CountField: Decodable {
                        let count: Int
                    }
                }
            }
            
            let response = try JSONDecoder().decode(CountResponse.self, from: data)
            let totalCount = response.data.findSceneMarkers.count
            
            // If we already have markers loaded, we can get the count from those
            if !appModel.api.markers.isEmpty {
                let filteredCount = appModel.api.markers.count
                print("üìä Using loaded markers count: \(filteredCount)")
                return filteredCount
            }
            
            // Return a reasonable estimate (we can't know the exact count without loading all markers)
            print("üìä Using total marker count: \(totalCount)")
            return min(50, totalCount) // Reasonable estimate
        } catch {
            print("‚ùå Error getting marker count: \(error)")
            return 0
        }
    }
    
    /// Format duration into mm:ss or hh:mm:ss format
    private func formatDuration(_ seconds: Float) -> String {
        let hours = Int(seconds) / 3600
        let minutes = Int(seconds) / 60 % 60
        let secs = Int(seconds) % 60
        
        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, secs)
        } else {
            return String(format: "%d:%02d", minutes, secs)
        }
    }
    
    private func getResumeTime(for sceneId: String) async -> Double? {
        let query = """
        {
            "operationName": "FindScene",
            "variables": {
                "id": "\(sceneId)"
            },
            "query": "query FindScene($id: ID!) { findScene(id: $id) { resume_time } }"
        }
        """

        print("‚è±Ô∏è Fetching resume time for scene: \(sceneId)")
        do {
            // Use the app model's enhanced executeGraphQLQuery method for consistent auth
            let data = try await appModel.api.executeGraphQLQuery(query)

            struct ResumeResponse: Decodable {
                let data: DataResponse
                struct DataResponse: Decodable {
                    let findScene: SceneData
                    struct SceneData: Decodable {
                        let resume_time: Double?
                    }
                }
            }

            let response = try JSONDecoder().decode(ResumeResponse.self, from: data)
            if let resumeTime = response.data.findScene.resume_time {
                print("‚è±Ô∏è Found resume time: \(resumeTime) seconds for scene \(sceneId)")
            } else {
                print("‚è±Ô∏è No resume time found for scene \(sceneId)")
            }
            return response.data.findScene.resume_time
        } catch {
            print("‚ùå Error fetching resume time: \(error)")
            return nil
        }
    }
}

================
File: stash/Views/Performers/PerformerTabView.swift-e
================
import SwiftUI

struct PerformerTabView: View {
    let performer: StashScene.Performer
    @EnvironmentObject private var appModel: AppModel
    @State private var selectedTab = 0 // 0 for scenes, 1 for markers
    @State private var markerCount: Int = 0
    @State private var isLoadingMore = false
    @State private var hasMorePages = true
    @State private var currentPage = 1
    @State private var selectedTag: StashScene.Tag?
    
    private let columns = [
        GridItem(.adaptive(minimum: 300, maximum: 400), spacing: 16)
    ]
    
    init(performer: StashScene.Performer) {
        self.performer = performer
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 0) {
                // Performer header
                PerformerHeaderView(performer: performer)
                
                // Tab picker
                Picker("View", selection: $selectedTab) {
                    Text("Scenes").tag(0)
                    Text("Markers").tag(1)
                }
                .pickerStyle(.segmented)
                .padding()
                
                // Content based on selected tab
                if selectedTab == 0 {
                    scenesContent
                } else {
                    markersContent
                }
            }
        }
        .navigationTitle(performer.name)
        .task {
            // Reset state when view appears
            currentPage = 1
            hasMorePages = true
            isLoadingMore = false
            appModel.api.scenes = []  // Clear existing content
            appModel.api.markers = []
            
            // Load initial content based on selected tab
            if selectedTab == 0 {
                await loadScenes()
            } else {
                await loadMarkers()
            }
            
            // Get marker count
            markerCount = await getMarkerCount()
        }
        .onChange(of: selectedTab) { _, newValue in
            Task {
                // Reset pagination when switching tabs
                currentPage = 1
                hasMorePages = true
                isLoadingMore = false
                appModel.api.scenes = []  // Clear existing content
                appModel.api.markers = []
                
                if newValue == 0 {
                    await loadScenes()
                } else {
                    await loadMarkers()
                }
            }
        }
        .sheet(item: $selectedTag) { tag in
            NavigationStack {
                TaggedScenesView(tag: tag)
            }
        }
    }
    
    private var scenesContent: some View {
        VStack {
            if appModel.api.scenes.isEmpty {
                Text("No scenes found")
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(appModel.api.scenes) { scene in
                        SceneRow(
                            scene: scene,
                            onTagSelected: { selectedTag = $0 },
                            onPerformerSelected: { _ in },  // Ignore performer selection in performer view
                            onSceneUpdated: { _ in }
                        )
                        .onTapGesture {
                            if let url = URL(string: scene.paths.stream) {
                                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                                   let window = windowScene.windows.first,
                                   let rootViewController = window.rootViewController {
                                    let controller = VideoPlayerUtility.createPlayerViewController(
                                        url: url,
                                        startTime: UserDefaults.standard.getVideoProgress(for: scene.id),
                                        scenes: appModel.api.scenes,
                                        currentIndex: appModel.api.scenes.firstIndex(of: scene) ?? 0
                                    )
                                    rootViewController.present(controller, animated: true)
                                }
                            }
                        }
                        .onAppear {
                            if scene == appModel.api.scenes.last && !isLoadingMore && hasMorePages {
                                Task {
                                    await loadMoreScenes()
                                }
                            }
                        }
                    }
                    
                    if isLoadingMore {
                        ProgressView()
                            .gridCellColumns(columns.count)
                            .padding()
                    }
                }
                .padding()
            }
        }
    }
    
    private var markersContent: some View {
        VStack {
            if appModel.api.markers.isEmpty {
                Text("No markers found")
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(appModel.api.markers) { marker in
                        MarkerRow(
                            marker: marker,
                            serverAddress: appModel.serverAddress,
                            onTitleTap: { _ in },
                            onTagTap: { tagName in
                                print("üîç Setting tag filter: \(tagName)")
                            }
                        )
                        .onAppear {
                            if marker == appModel.api.markers.last && !isLoadingMore && hasMorePages {
                                Task {
                                    await loadMoreMarkers()
                                }
                            }
                        }
                    }
                    
                    if isLoadingMore {
                        ProgressView()
                            .gridCellColumns(columns.count)
                            .padding()
                    }
                }
                .padding()
            }
        }
    }
    
    private func loadScenes() async {
        print("üé≠ Loading scenes for performer: \(performer.name)")
        let query = """
        {"operationName":"FindScenes","variables":{"filter":{"page":\(currentPage),"per_page":20,"sort":"date","direction":"DESC"},"scene_filter":{"performers":{"value":["\(performer.id)"],"modifier":"INCLUDES"}}},"query":"query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name } tags { id name } rating100 } } }"}
        """
        
        guard let url = URL(string: "\(appModel.serverAddress)/graphql") else { return }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue(api.serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            let response = try JSONDecoder().decode(GraphQLResponse<ScenesResponse>.self, from: data)
            
            await MainActor.run {
                if currentPage == 1 {
                    appModel.api.scenes = response.data.findScenes.scenes
                } else {
                    appModel.api.scenes.append(contentsOf: response.data.findScenes.scenes)
                }
                print("üé≠ Loaded \(appModel.api.scenes.count) scenes for performer")
            }
        } catch {
            print("‚ùå Error loading scenes: \(error)")
        }
    }
    
    private func loadMoreScenes() async {
        guard !isLoadingMore else { return }
        
        isLoadingMore = true
        currentPage += 1
        
        let previousCount = appModel.api.scenes.count
        await loadScenes()
        
        hasMorePages = appModel.api.scenes.count > previousCount
        isLoadingMore = false
    }
    
    private func loadMarkers() async {
        await appModel.api.fetchPerformerMarkers(performerId: performer.id, page: currentPage, appendResults: currentPage > 1)
    }
    
    private func loadMoreMarkers() async {
        guard !isLoadingMore else { return }
        
        isLoadingMore = true
        currentPage += 1
        
        let previousCount = appModel.api.markers.count
        await appModel.api.fetchPerformerMarkers(performerId: performer.id, page: currentPage, appendResults: true)
        
        hasMorePages = appModel.api.markers.count > previousCount
        isLoadingMore = false
    }
    
    private func getMarkerCount() async -> Int {
        let query = """
        {"operationName":"FindSceneMarkers","variables":{"filter":{"q":"","page":1,"per_page":1,"sort":"title","direction":"ASC"},"scene_marker_filter":{"performers":{"value":["\(performer.id)"],"excludes":[],"modifier":"INCLUDES_ALL"}}},"query":"query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) {\\n  findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) {\\n    count\\n    __typename\\n  }\\n}"}
        """
        
        guard let url = URL(string: "\(appModel.serverAddress)/graphql") else { return 0 }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue(api.serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            struct MarkerCountResponse: Decodable {
                let data: DataResponse
                
                struct DataResponse: Decodable {
                    let findSceneMarkers: MarkersResponse
                    
                    struct MarkersResponse: Decodable {
                        let count: Int
                    }
                }
            }
            
            let response = try JSONDecoder().decode(MarkerCountResponse.self, from: data)
            return response.data.findSceneMarkers.count
        } catch {
            print("‚ùå Error fetching marker count: \(error)")
            return 0
        }
    }
    
    private func getResumeTime(for sceneId: String) async -> Double? {
        let query = """
        {
            "operationName": "FindScene",
            "variables": {
                "id": "\(sceneId)"
            },
            "query": "query FindScene($id: ID!) { findScene(id: $id) { resume_time } }"
        }
        """
        
        guard let url = URL(string: "\(appModel.serverAddress)/graphql") else { return nil }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            struct ResumeResponse: Decodable {
                let data: DataResponse
                struct DataResponse: Decodable {
                    let findScene: SceneData
                    struct SceneData: Decodable {
                        let resume_time: Double?
                    }
                }
            }
            
            let response = try JSONDecoder().decode(ResumeResponse.self, from: data)
            return response.data.findScene.resume_time
        } catch {
            print("‚ùå Error fetching resume time: \(error)")
            return nil
        }
    }
}

================
File: stash/Views/Player/CustomVideoPlayer.swift
================
import AVKit
import UIKit
import SwiftUI

class CustomVideoPlayer: AVPlayerViewController {
    // MARK: - Properties
    private var scenes: [StashScene] = []
    private var currentIndex: Int = 0
    private var currentSceneID: String = ""
    private var appModel: AppModel
    
    // MARK: - Custom Buttons
    private var randomJumpButton: UIButton!
    private var performerJumpButton: UIButton!
    private var shuffleButton: UIButton!
    
    // MARK: - Initialization
    init(scenes: [StashScene], currentIndex: Int, sceneID: String, appModel: AppModel) {
        self.scenes = scenes
        self.currentIndex = currentIndex
        self.currentSceneID = sceneID
        self.appModel = appModel
        super.init(nibName: nil, bundle: nil)
        setupCustomControls()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Setup
    private func setupCustomControls() {
        // Create custom buttons
        randomJumpButton = UIButton(type: .system)
        randomJumpButton.setImage(UIImage(systemName: "arrow.triangle.2.circlepath"), for: .normal)
        randomJumpButton.tintColor = .white
        randomJumpButton.addTarget(self, action: #selector(handleRandomJumpButtonTapped), for: .touchUpInside)
        
        performerJumpButton = UIButton(type: .system)
        performerJumpButton.setImage(UIImage(systemName: "person.crop.circle"), for: .normal)
        performerJumpButton.tintColor = .white
        performerJumpButton.addTarget(self, action: #selector(handlePerformerJumpButtonTapped), for: .touchUpInside)
        
        shuffleButton = UIButton(type: .system)
        shuffleButton.setImage(UIImage(systemName: "shuffle"), for: .normal)
        shuffleButton.tintColor = .white
        shuffleButton.addTarget(self, action: #selector(handleShuffleButtonTapped), for: .touchUpInside)
        
        // Buttons will be added in viewDidAppear
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        // Find the transport controls container view
        if let contentOverlayView = self.contentOverlayView {
            // Configure buttons
            configureButton(randomJumpButton, inView: contentOverlayView, position: .left)
            configureButton(performerJumpButton, inView: contentOverlayView, position: .center)
            configureButton(shuffleButton, inView: contentOverlayView, position: .right)
            
            // Start with buttons visible
            randomJumpButton.alpha = 1.0
            performerJumpButton.alpha = 1.0
            shuffleButton.alpha = 1.0

            // Hide buttons on video start with a 5-second delay
            player?.addObserver(self, forKeyPath: "timeControlStatus", options: [.new], context: nil)
            
            // Add tap gesture to show/hide buttons
            let tapGesture = UITapGestureRecognizer(target: self, action: #selector(toggleButtonVisibility))
            contentOverlayView.addGestureRecognizer(tapGesture)
        }
        
        // Start playback automatically
        player?.play()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        if player != nil {
            player?.removeObserver(self, forKeyPath: "timeControlStatus")
        }
    }

    // Monitor player status to auto-hide buttons when playback starts
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "timeControlStatus", let player = object as? AVPlayer {
            if player.timeControlStatus == .playing {
                // Hide buttons 5 seconds after playback starts
                DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) { [weak self] in
                    guard let self = self else { return }
                    // Only hide if they're currently visible
                    if self.randomJumpButton.alpha > 0 {
                        UIView.animate(withDuration: 0.3) {
                            self.randomJumpButton.alpha = 0.0
                            self.performerJumpButton.alpha = 0.0
                            self.shuffleButton.alpha = 0.0
                        }
                    }
                }
            }
        }
    }
    
    @objc private func toggleButtonVisibility() {
        let buttonsVisible = randomJumpButton.alpha > 0
        
        UIView.animate(withDuration: 0.3) {
            self.randomJumpButton.alpha = buttonsVisible ? 0.0 : 1.0
            self.performerJumpButton.alpha = buttonsVisible ? 0.0 : 1.0
            self.shuffleButton.alpha = buttonsVisible ? 0.0 : 1.0
        }
        
        // If we're showing buttons, hide them after a delay
        if !buttonsVisible {
            DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) { [weak self] in
                guard let self = self else { return }
                
                // Only hide if they're currently visible
                if self.randomJumpButton.alpha > 0 {
                    UIView.animate(withDuration: 0.3) {
                        self.randomJumpButton.alpha = 0.0
                        self.performerJumpButton.alpha = 0.0
                        self.shuffleButton.alpha = 0.0
                    }
                }
            }
        }
    }
    
    private enum ButtonPosition {
        case left, center, right
    }
    
    private func configureButton(_ button: UIButton, inView contentView: UIView, position: ButtonPosition) {
        // Configure button appearance
        button.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(button)
        
        // Position button - adjust size for iPads
        let isIpad = UIDevice.current.userInterfaceIdiom == .pad
        let padding: CGFloat = isIpad ? 60 : 30 // Increased padding to avoid conflict with controls
        let size: CGFloat = isIpad ? 60 : 44
        // Move buttons higher up to avoid conflict with native controls
        let yOffset: CGFloat = isIpad ? 200 : 140 // Increased distance from bottom
        
        NSLayoutConstraint.activate([
            button.widthAnchor.constraint(equalToConstant: size),
            button.heightAnchor.constraint(equalToConstant: size),
            button.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -yOffset)
        ])
        
        // Set horizontal position based on position enum
        switch position {
        case .left:
            NSLayoutConstraint.activate([
                button.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: padding)
            ])
        case .center:
            NSLayoutConstraint.activate([
                button.centerXAnchor.constraint(equalTo: contentView.centerXAnchor)
            ])
        case .right:
            NSLayoutConstraint.activate([
                button.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -padding)
            ])
        }
        
        // Add background for better visibility
        button.backgroundColor = UIColor.black.withAlphaComponent(0.5)
        button.layer.cornerRadius = size / 2
        
        // Configure tap animation
        button.showsTouchWhenHighlighted = true
        
        // Make the button larger for image
        button.contentEdgeInsets = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
        
        // Configure button font size
        let imageConfig = UIImage.SymbolConfiguration(pointSize: isIpad ? 24 : 18, weight: .semibold)
        button.setPreferredSymbolConfiguration(imageConfig, forImageIn: .normal)
    }
    
    // MARK: - Button Handlers
    
    @objc private func handleRandomJumpButtonTapped() {
        // Detailed logging for debugging
        print("üé≤ RANDOM JUMP: Button tapped")

        guard let currentPlayer = player else {
            print("‚ùå RANDOM JUMP: Player is nil!")
            return
        }

        guard let currentItem = currentPlayer.currentItem else {
            print("‚ùå RANDOM JUMP: Current item is nil!")
            return
        }

        let duration = currentItem.duration.seconds
        print("üé≤ RANDOM JUMP: Current duration = \(duration) seconds")

        guard duration.isFinite && duration > 10 else {
            print("‚ùå RANDOM JUMP: Invalid duration: \(duration)")
            return
        }

        // Current time for logging
        let currentSeconds = currentItem.currentTime().seconds
        print("üé≤ RANDOM JUMP: Current position = \(currentSeconds) seconds")

        // Generate a random position between 10% and 90% of the video duration
        // Using a wider range than before (10-90% instead of 5-95%)
        let minPosition = max(5, duration * 0.1) // Ensure at least 5 seconds from start
        let maxPosition = min(duration - 10, duration * 0.9) // Ensure at least 10 seconds from end

        // Generate and log random position with more precision
        let randomPosition = Double.random(in: minPosition...maxPosition)
        let minutes = Int(randomPosition / 60)
        let seconds = Int(randomPosition) % 60

        print("üé≤ RANDOM JUMP: Generated position - \(randomPosition) seconds (\(minutes):\(String(format: "%02d", seconds)))")
        print("üé≤ RANDOM JUMP: Acceptable range was \(minPosition) to \(maxPosition) seconds")

        // Create time with higher precision timescale (was 600, now 1000)
        let time = CMTime(seconds: randomPosition, preferredTimescale: 1000)

        // Set tolerances to ensure more precise seeking
        let toleranceBefore = CMTime(seconds: 0.5, preferredTimescale: 1000)
        let toleranceAfter = CMTime(seconds: 0.5, preferredTimescale: 1000)

        print("üé≤ RANDOM JUMP: Attempting to seek to position...")

        // Use the more precise seek method with tolerances
        currentPlayer.seek(to: time, toleranceBefore: toleranceBefore, toleranceAfter: toleranceAfter) { success in
            if success {
                print("‚úÖ RANDOM JUMP: Successfully jumped to \(minutes):\(String(format: "%02d", seconds))")

                // Provide haptic feedback when jump succeeds
                let generator = UIImpactFeedbackGenerator(style: .medium)
                generator.impactOccurred()

                // Force the player to resume playback after seeking
                if currentPlayer.timeControlStatus != .playing {
                    print("‚ñ∂Ô∏è RANDOM JUMP: Resuming playback after jump")
                    currentPlayer.play()
                }
            } else {
                print("‚ùå RANDOM JUMP: Seek operation failed")
            }
        }
    }
    
    @objc private func handlePerformerJumpButtonTapped() {
        // Find current scene and get its performers
        guard let currentScene = scenes.first(where: { $0.id == currentSceneID }),
              !currentScene.performers.isEmpty else {
            print("‚ö†Ô∏è No performers found for current scene")
            return
        }
        
        // Get the first performer from the scene
        if let performer = currentScene.performers.first {
            // Directly jump to a random scene with the same performer
            jumpToPerformerScenes(performer: performer)
            
            // Provide haptic feedback
            let generator = UIImpactFeedbackGenerator(style: .medium)
            generator.impactOccurred()
        }
    }
    
    private func jumpToPerformerScenes(performer: StashScene.Performer) {
        // Navigate to a different scene with the selected performer
        // Filter scenes that contain this performer
        let performerScenes = scenes.filter { scene in
            scene.performers.contains { $0.id == performer.id }
        }
        
        if performerScenes.isEmpty {
            print("‚ö†Ô∏è No other scenes found with performer \(performer.name)")
            return
        }
        
        // Get a random scene with this performer (excluding current scene)
        let otherScenes = performerScenes.filter { $0.id != currentSceneID }
        guard let randomScene = otherScenes.randomElement() ?? performerScenes.first else { return }
        
        if let nextUrl = URL(string: randomScene.paths.stream) {
            // Create a new player item for the next scene
            let playerItem = AVPlayerItem(url: nextUrl)
            
            // Replace the current item with the new one
            if let currentPlayer = player {
                // Save progress for current scene before switching
                if let currentTime = currentPlayer.currentItem?.currentTime().seconds {
                    UserDefaults.standard.setVideoProgress(currentTime, for: currentSceneID)
                }
                
                // Update current scene ID
                currentSceneID = randomScene.id
                
                // Update player with new content
                currentPlayer.replaceCurrentItem(with: playerItem)
                currentPlayer.play()
                
                print("üîÑ Switched to scene: \(randomScene.title ?? "Untitled") with performer: \(performer.name)")
            } else {
                // Fallback if player is nil - create and present a new player
                dismiss(animated: true) {
                    if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                       let window = windowScene.windows.first,
                       let rootViewController = window.rootViewController {
                        
                        let nextIndex = self.scenes.firstIndex(where: { $0.id == randomScene.id }) ?? 0
                        let nextPlayer = CustomVideoPlayer(
                            scenes: self.scenes,
                            currentIndex: nextIndex,
                            sceneID: randomScene.id,
                            appModel: self.appModel
                        )
                        nextPlayer.player = AVPlayer(url: nextUrl)
                        rootViewController.present(nextPlayer, animated: true)
                    }
                }
            }
        }
    }
    
    @objc private func handleShuffleButtonTapped() {
        // Play a random scene from the entire collection
        guard !scenes.isEmpty else { return }
        
        // Get a random scene (excluding current scene)
        let otherScenes = scenes.filter { $0.id != currentSceneID }
        guard let randomScene = otherScenes.randomElement() ?? scenes.first else { return }
        
        if let nextUrl = URL(string: randomScene.paths.stream) {
            // Create a new player item for the next scene
            let playerItem = AVPlayerItem(url: nextUrl)
            
            // Replace the current item with the new one
            if let currentPlayer = player {
                // Save progress for current scene before switching
                if let currentTime = currentPlayer.currentItem?.currentTime().seconds {
                    UserDefaults.standard.setVideoProgress(currentTime, for: currentSceneID)
                }
                
                // Update current scene ID
                currentSceneID = randomScene.id
                
                // Update player with new content
                currentPlayer.replaceCurrentItem(with: playerItem)
                currentPlayer.play()
                
                // Provide haptic feedback
                let generator = UIImpactFeedbackGenerator(style: .medium)
                generator.impactOccurred()
                
                print("üîÑ Shuffled to scene: \(randomScene.title ?? "Untitled")")
            } else {
                // Fallback if player is nil - create and present a new player
                dismiss(animated: true) {
                    if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                       let window = windowScene.windows.first,
                       let rootViewController = window.rootViewController {
                        
                        let nextIndex = self.scenes.firstIndex(where: { $0.id == randomScene.id }) ?? 0
                        let nextPlayer = CustomVideoPlayer(
                            scenes: self.scenes,
                            currentIndex: nextIndex,
                            sceneID: randomScene.id,
                            appModel: self.appModel
                        )
                        nextPlayer.player = AVPlayer(url: nextUrl)
                        rootViewController.present(nextPlayer, animated: true)
                    }
                }
            }
        }
    }
}

================
File: stash/Views/Scenes/SceneFilterView.swift
================
import SwiftUI

struct SceneFilterView: View {
    let scene: StashScene
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appModel: AppModel
    @State private var currentFilter: String = "default"
    
    var body: some View {
        VStack(spacing: 20) {
            // Title
            Text("Sort Media Library")
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            // Filter options
            VStack(spacing: 16) {
                filterButton("Default Sort", systemImage: "rectangle.grid.2x2", filter: "default") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "file_mod_time", direction: "DESC")
                        dismiss()
                    }
                }
                
                filterButton("Newest Videos", systemImage: "clock", filter: "newest") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "date", direction: "DESC")
                        dismiss()
                    }
                }
                
                filterButton("Most Played", systemImage: "number.circle", filter: "o_counter") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "o_counter", direction: "DESC")
                        dismiss()
                    }
                }
                
                filterButton("Random Order", systemImage: "shuffle", filter: "random") {
                    Task {
                        await appModel.api.fetchScenes(page: 1, sort: "random", direction: "DESC")
                        dismiss()
                    }
                }
                
                if scene.tags.count > 0 {
                    Divider()
                    
                    Text("Filter by Tags")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 10) {
                            ForEach(scene.tags) { tag in
                                Button {
                                    navigateToTag(tag)
                                } label: {
                                    Text(tag.name)
                                        .font(.subheadline)
                                        .padding(.horizontal, 12)
                                        .padding(.vertical, 6)
                                        .background(Color.blue.opacity(0.1))
                                        .cornerRadius(12)
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                    }
                }
                
                if scene.performers.count > 0 {
                    Divider()
                    
                    Text("Filter by Performers")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 10) {
                            ForEach(scene.performers) { performer in
                                Button {
                                    navigateToPerformer(performer)
                                } label: {
                                    Text(performer.name)
                                        .font(.subheadline)
                                        .padding(.horizontal, 12)
                                        .padding(.vertical, 6)
                                        .background(Color.purple.opacity(0.1))
                                        .cornerRadius(12)
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                    }
                }
            }
            .padding(.vertical, 8)
            
            Spacer()
            
            // Advanced filter button
            Button {
                // Cancel this sheet and show advanced filters
                dismiss()
                // The actual implementation would depend on how you handle advanced filters in your app
                NotificationCenter.default.post(name: Notification.Name("ShowAdvancedFilters"), object: nil)
            } label: {
                HStack {
                    Image(systemName: "slider.horizontal.3")
                    Text("Advanced Filters")
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
            }
        }
        .padding()
    }
    
    private func filterButton(_ title: String, systemImage: String, filter: String, action: @escaping () -> Void) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: systemImage)
                    .frame(width: 24, height: 24)
                
                Text(title)
                    .font(.body)
                
                Spacer()
                
                if currentFilter == filter {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .padding(.vertical, 8)
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    private func navigateToTag(_ tag: StashScene.Tag) {
        dismiss()
        appModel.navigateToTag(tag)
    }
    
    private func navigateToPerformer(_ performer: StashScene.Performer) {
        dismiss()
        appModel.navigateToPerformer(performer)
    }
}

// Preview
struct SceneFilterView_Previews: PreviewProvider {
    static var previews: some View {
        let mockScene = StashScene(
            id: "1",
            title: "Test Scene",
            details: "Details",
            paths: StashScene.ScenePaths(
                screenshot: "",
                preview: "",
                stream: ""
            ),
            files: [
                StashScene.SceneFile(
                    size: 1000000,
                    duration: 300,
                    video_codec: "h264",
                    width: 1920,
                    height: 1080
                )
            ],
            performers: [
                StashScene.Performer(
                    id: "1",
                    name: "Performer 1",
                    gender: nil,
                    image_path: nil,
                    scene_count: 5,
                    favorite: true,
                    rating100: 80
                ),
                StashScene.Performer(
                    id: "2",
                    name: "Performer 2",
                    gender: nil,
                    image_path: nil,
                    scene_count: 10,
                    favorite: false,
                    rating100: 90
                )
            ],
            tags: [
                StashScene.Tag(id: "1", name: "Tag 1"),
                StashScene.Tag(id: "2", name: "Tag 2")
            ],
            rating100: 80,
            o_counter: 5
        )
        
        SceneFilterView(scene: mockScene)
            .environmentObject(AppModel())
    }
}

================
File: stash/Views/Scenes/SceneRow.swift
================
import SwiftUI
import AVKit
import Foundation

struct SceneRow: View {
    let scene: StashScene
    let onTagSelected: (StashScene.Tag) -> Void
    let onPerformerSelected: (StashScene.Performer) -> Void
    @State private var isVisible = false
    @State private var isMuted = true
    @State private var showingTagEditor = false
    @StateObject private var previewPlayer = VideoPlayerViewModel()
    var onSceneUpdated: (StashScene) -> Void
    var onSceneSelected: (StashScene) -> Void
    
    var body: some View {
        // Log scene info for debugging
        let _ = print("üì± SCENE ROW: Rendering scene: \(scene.id), title: \(scene.title ?? "missing title")")
        let titleValue = scene.title ?? "Untitled" // Cache title for consistent use

        return VStack(alignment: .leading) {
            // Thumbnail with preview
            GeometryReader { geometry in
                ZStack {
                    // Thumbnail
                    AsyncImage(url: URL(string: scene.paths.screenshot)) { image in
                        image
                            .resizable()
                            .aspectRatio(16/9, contentMode: .fill)
                    } placeholder: {
                        Rectangle()
                            .fill(Color.gray.opacity(0.2))
                    }

                    // Video preview
                    if isVisible, let previewURL = scene.paths.preview {
                        VideoPlayer(player: previewPlayer.player)
                            .onAppear {
                                previewPlayer.player.isMuted = isMuted
                            }
                    }

                    // Duration and mute overlay
                    HStack {
                        if let firstFile = scene.files.first {
                            Text(formatDuration(firstFile.duration))
                                .font(.caption)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(.ultraThinMaterial)
                                .cornerRadius(4)
                        }

                        Spacer()

                        if isVisible {
                            Button(action: {
                                isMuted.toggle()
                                previewPlayer.player.isMuted = isMuted
                            }) {
                                Image(systemName: isMuted ? "speaker.slash.fill" : "speaker.wave.2.fill")
                                    .foregroundColor(.white)
                                    .padding(8)
                                    .background(.ultraThinMaterial)
                                    .clipShape(Circle())
                            }
                        }
                    }
                    .padding(8)

                    // Random jump button positioned at the top-right
                    VStack {
                        HStack {
                            Spacer()

                            // Random Jump button at top-right
                            Button {
                                print("üì± SCENEROW: Random Jump button tapped for scene: \(scene.id), title: \(scene.title ?? "unknown")")
                                playRandomPositionInScene(scene)
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.purple.opacity(0.8))
                                        .frame(width: 50, height: 50)
                                        .shadow(color: .black.opacity(0.5), radius: 3, x: 0, y: 2)

                                    // Icon
                                    Image(systemName: "arrow.triangle.2.circlepath")
                                        .font(.system(size: 22, weight: .bold))
                                        .foregroundColor(.white)

                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 50, height: 50)
                                }
                            }
                            .padding(12)
                        }
                        Spacer()
                    }
                }
                .task {
                    // Check visibility on task creation
                    let frame = geometry.frame(in: .global)
                    let isNowVisible = frame.minY > 0 && frame.maxY < UIScreen.main.bounds.height

                    if isNowVisible && !isVisible {
                        print("üì± SCENEROW: Task - Scene \(scene.id) is visible, starting preview")
                        await MainActor.run {
                            isVisible = true
                            startPreview()
                        }
                    }
                }
                .onChange(of: geometry.frame(in: .global).minY) { _, newValue in
                    let frame = geometry.frame(in: .global)
                    let isNowVisible = frame.minY > 0 && frame.maxY < UIScreen.main.bounds.height

                    if isNowVisible != isVisible {
                        print("üì± SCENEROW: Visibility changed for scene \(scene.id) to \(isNowVisible)")
                        isVisible = isNowVisible
                        if isNowVisible {
                            startPreview()
                        } else {
                            stopPreview()
                        }
                    }
                }
                .onAppear {
                    // When the row appears, check if it's visible in the viewport
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        let frame = geometry.frame(in: .global)
                        let isNowVisible = frame.minY > 0 && frame.maxY < UIScreen.main.bounds.height

                        if isNowVisible && !isVisible {
                            isVisible = true
                            startPreview()
                        }
                    }
                }
            }
            .frame(height: 200)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            
            // Info section with higher priority for title
            VStack(alignment: .leading, spacing: 8) {
                // Title section gets higher layout priority to ensure it's always visible
                VStack(alignment: .leading) {
                    // Title in separate stack with better contrast
                    HStack {
                        Text(titleValue)
                            .font(.headline)
                            .fontWeight(.bold)
                            .lineLimit(2) // Allow up to 2 lines for longer titles
                            .fixedSize(horizontal: false, vertical: true) // Ensure text doesn't get cut off
                            .padding(.vertical, 4) // Add padding above and below title
                            .foregroundColor(.primary) // Ensure high contrast
                            .layoutPriority(100) // Give title highest layout priority
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)

                    // Controls in separate row
                    HStack {
                        // Scene ID for debugging
                        Text("ID: \(scene.id)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                            .opacity(0.7)

                        Spacer()

                        Button(action: { showingTagEditor = true }) {
                            Image(systemName: "tag")
                                .foregroundColor(.blue)
                        }

                        // Show ratings and o_counter information
                        HStack(spacing: 12) {
                            if let rating = scene.rating100 {
                                HStack(spacing: 2) {
                                    Image(systemName: "star.fill")
                                        .foregroundColor(.yellow)
                                    Text("\(rating/20)")
                                        .foregroundColor(.secondary)
                                }
                                .font(.subheadline)
                            }

                            // Display o_counter when available (like Vision Pro implementation)
                            if let oCounter = scene.o_counter, oCounter > 0 {
                                HStack(spacing: 2) {
                                    Image(systemName: "number.circle.fill")
                                        .foregroundColor(.green)
                                    Text("\(oCounter)")
                                        .foregroundColor(.secondary)
                                }
                                .font(.subheadline)
                            }
                        }
                    }
                }
                
                // Performers
                if !scene.performers.isEmpty {
                    HStack {
                        ForEach(scene.performers) { performer in
                            Button(action: {
                                onPerformerSelected(performer)
                            }) {
                                Text(performer.name)
                                    .font(.subheadline)
                                    .foregroundColor(.blue)
                            }
                            
                            if performer != scene.performers.last {
                                Text("¬∑")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                                    .padding(.horizontal, 2)
                            }
                        }
                    }
                    .lineLimit(1)
                }
                
                // Tags
                if !scene.tags.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack {
                            ForEach(scene.tags) { tag in
                                TagView(tag: tag, onTagSelected: onTagSelected)
                            }
                        }
                    }
                }
                
                // File info
                if let firstFile = scene.files.first {
                    HStack(spacing: 12) {
                        Label(firstFile.formattedSize, systemImage: "folder")
                        if let height = firstFile.height {
                            Label("\(height)p", systemImage: "rectangle.on.rectangle")
                        }
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)
                }
            }
            .padding(12)
        }
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
        .scaleEffect(isVisible ? 1.0 : 0.98)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isVisible)
        .onDisappear {
            stopPreview()
        }
        .sheet(isPresented: $showingTagEditor) {
            NavigationStack {
                TagEditorView(scene: scene) { updatedScene in
                    onSceneUpdated(updatedScene)
                }
            }
        }
    }
    
    private func formatDuration(_ duration: Float) -> String {
        let hours = Int(duration) / 3600
        let minutes = Int(duration) / 60 % 60
        let seconds = Int(duration) % 60
        
        if hours > 0 {
            return String(format: "%.2d:%.2d:%.2d", hours, minutes, seconds)
        } else {
            return String(format: "%.2d:%.2d", minutes, seconds)
        }
    }
    
    private func startPreview() {
        if let previewURL = scene.paths.preview,
           let url = URL(string: previewURL) {
            print("üî• Starting preview for scene: \(scene.title ?? "")")
            
            var request = URLRequest(url: url)
            request.setValue("*/*", forHTTPHeaderField: "Accept")
            request.setValue("identity", forHTTPHeaderField: "Accept-Encoding")
            request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
            request.setValue("bytes=0-1146540", forHTTPHeaderField: "Range")
            
            let asset = AVURLAsset(url: url)
            let playerItem = AVPlayerItem(asset: asset)
            previewPlayer.player.replaceCurrentItem(with: playerItem)
            previewPlayer.player.isMuted = isMuted
            previewPlayer.player.play()
        }
    }
    
    private func stopPreview() {
        print("üî• Stopping preview for scene: \(scene.title ?? "")")
        previewPlayer.cleanup()
        isVisible = false
    }

    /// Plays the scene from a random position
    private func playRandomPositionInScene(_ scene: StashScene) {
        print("üé≤ SCENEROW: Playing scene from random position")

        // First pass the scene to the parent to handle navigation and display
        onSceneSelected(scene)

        // Give more time for the player to initialize and load the video
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
            // Look for the player from the registry in VideoPlayerView
            if let player = VideoPlayerRegistry.shared.currentPlayer {
                print("üé≤ SCENEROW: Got player from registry, attempting to jump to random position")

                // Check if the player is ready
                if let currentItem = player.currentItem, currentItem.status == .readyToPlay {
                    print("üé≤ SCENEROW: Player is ready, jumping to random position")
                    VideoPlayerUtility.jumpToRandomPosition(in: player)
                } else {
                    print("üé≤ SCENEROW: Player not ready yet, will retry in 1.5 seconds")

                    // Retry after another delay
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                        if let player = VideoPlayerRegistry.shared.currentPlayer,
                           let currentItem = player.currentItem,
                           currentItem.status == .readyToPlay {
                            print("üé≤ SCENEROW: Player is now ready (retry), jumping to random position")
                            VideoPlayerUtility.jumpToRandomPosition(in: player)
                        } else {
                            print("üé≤ SCENEROW: Player still not ready after retry")

                            // One final attempt with a longer delay
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                if let player = VideoPlayerRegistry.shared.currentPlayer {
                                    print("üé≤ SCENEROW: Final attempt to jump to random position")
                                    // Force the jump even if not fully ready
                                    VideoPlayerUtility.jumpToRandomPosition(in: player)
                                }
                            }
                        }
                    }
                }
            } else {
                print("‚ö†Ô∏è SCENEROW: Failed to get player from registry")
            }
        }
    }
}

struct TagView: View {
    let tag: StashScene.Tag
    let onTagSelected: (StashScene.Tag) -> Void
    @State private var isHovering = false
    
    var body: some View {
        Button(action: { onTagSelected(tag) }) {
            Text(tag.name)
                .font(.caption)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                    isHovering ? 
                        Color.blue.opacity(0.2) : 
                        Color.secondary.opacity(0.2)
                )
                .cornerRadius(12)
                .scaleEffect(isHovering ? 1.1 : 1.0)
                .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isHovering)
        }
        .onHover { hovering in
            isHovering = hovering
        }
    }
}

================
File: stash/Views/Scenes/ScenesGrid.swift
================
import SwiftUI
import AVKit
import Foundation

struct ScenesGrid: View {
    let scenes: [StashScene]
    let columns: [GridItem]
    let onSceneSelected: (StashScene) -> Void
    let onTagSelected: (StashScene.Tag) -> Void
    let onPerformerSelected: (StashScene.Performer) -> Void
    let onSceneAppear: (StashScene) -> Void
    let onSceneUpdated: (StashScene) -> Void
    let isLoadingMore: Bool
    @State private var currentIndex = 0
    
    var body: some View {
        LazyVGrid(columns: columns, spacing: 16) {
            ForEach(Array(scenes.enumerated()), id: \.element.id) { index, scene in
                SceneRow(
                    scene: scene,
                    onTagSelected: onTagSelected,
                    onPerformerSelected: onPerformerSelected,
                    onSceneUpdated: onSceneUpdated,
                    onSceneSelected: onSceneSelected
                )
                .slideIn(from: .bottom, delay: Double(index) * 0.05, duration: 0.4)
                .applyHoverEffect()
                .onTapGesture {
                    onSceneSelected(scene)
                }
                .onAppear {
                    onSceneAppear(scene)
                }
            }
            
            if isLoadingMore {
                ProgressView()
                    .gridCellColumns(columns.count)
                    .padding()
            }
        }
        .padding()
    }
}

extension UIView {
    func centerYConstraint(to other: UIView) -> NSLayoutConstraint {
        return centerYAnchor.constraint(equalTo: other.centerYAnchor)
    }
}

================
File: stash/Views/Settings/SettingsView.swift
================
import SwiftUI

struct SettingsView: View {
    @EnvironmentObject private var appModel: AppModel
    @Environment(\.dismiss) private var dismiss
    @State private var defaultPerPage = 20
    @State private var autoplayPreviews = true
    @State private var mutePreviews = true
    @State private var preferHLSStreaming = true
    @State private var showConfirmation = false
    
    var body: some View {
        NavigationStack {
            Form {
                Section("Server") {
                    HStack {
                        Text("Address")
                        Spacer()
                        Text(appModel.serverAddress)
                            .foregroundColor(.secondary)
                    }
                    
                    Button("Disconnect") {
                        showConfirmation = true
                    }
                    .foregroundColor(.red)
                }
                
                Section("Display") {
                    Stepper("Items per page: \(defaultPerPage)", value: $defaultPerPage, in: 10...50, step: 5)
                    
                    Toggle("Dark mode", isOn: .constant(true))
                }
                
                Section("Playback") {
                    Toggle("Autoplay previews", isOn: $autoplayPreviews)
                        .onChange(of: autoplayPreviews) { _, newValue in
                            UserDefaults.standard.set(newValue, forKey: "autoplayPreviews")
                        }
                    
                    Toggle("Mute previews by default", isOn: $mutePreviews)
                        .onChange(of: mutePreviews) { _, newValue in
                            UserDefaults.standard.set(newValue, forKey: "mutePreviews")
                        }
                    
                    Toggle("Prefer HLS streaming", isOn: $preferHLSStreaming)
                        .onChange(of: preferHLSStreaming) { _, newValue in
                            UserDefaults.standard.set(newValue, forKey: "preferHLSStreaming")
                        }
                }
                
                Section("About") {
                    HStack {
                        Text("Version")
                        Spacer()
                        Text("2.0.0")
                            .foregroundColor(.secondary)
                    }
                }
            }
            .navigationTitle("Settings")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .alert("Disconnect from Server?", isPresented: $showConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button("Disconnect", role: .destructive) {
                    appModel.disconnect()
                }
            } message: {
                Text("You will need to reconnect to access your media library.")
            }
            .onAppear {
                // Load user defaults
                defaultPerPage = UserDefaults.standard.integer(forKey: "defaultPerPage")
                if defaultPerPage == 0 {
                    defaultPerPage = 20
                    UserDefaults.standard.set(defaultPerPage, forKey: "defaultPerPage")
                }
                
                autoplayPreviews = UserDefaults.standard.bool(forKey: "autoplayPreviews")
                if !UserDefaults.standard.contains(key: "autoplayPreviews") {
                    autoplayPreviews = true
                    UserDefaults.standard.set(true, forKey: "autoplayPreviews")
                }
                
                mutePreviews = UserDefaults.standard.bool(forKey: "mutePreviews")
                if !UserDefaults.standard.contains(key: "mutePreviews") {
                    mutePreviews = true
                    UserDefaults.standard.set(true, forKey: "mutePreviews")
                }
                
                preferHLSStreaming = UserDefaults.standard.bool(forKey: "preferHLSStreaming")
                if !UserDefaults.standard.contains(key: "preferHLSStreaming") {
                    preferHLSStreaming = true
                    UserDefaults.standard.set(true, forKey: "preferHLSStreaming")
                }
            }
        }
    }
}

// Extension to check if a key exists in UserDefaults
extension UserDefaults {
    func contains(key: String) -> Bool {
        return object(forKey: key) != nil
    }
}

#Preview {
    SettingsView()
        .environmentObject(AppModel())
}

================
File: stash/Views/Tags/TagEditorView.swift
================
import SwiftUI

struct TagEditorView: View {
    let scene: StashScene
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appModel: AppModel
    @State private var selectedTags: Set<String>
    @State private var newTagName = ""
    @State private var showingNewTagAlert = false
    @State private var isLoading = false
    @State private var currentTags: [StashScene.Tag]
    @State private var searchText = ""
    @State private var searchResults: [StashScene.Tag] = []
    @State private var errorMessage: String?
    @State private var showingError = false
    var onTagsUpdated: (StashScene) -> Void
    
    init(scene: StashScene, onTagsUpdated: @escaping (StashScene) -> Void = { _ in }) {
        self.scene = scene
        self.onTagsUpdated = onTagsUpdated
        _selectedTags = State(initialValue: Set(scene.tags.map { $0.id }))
        _currentTags = State(initialValue: scene.tags)
    }
    
    var body: some View {
        NavigationView {
            ZStack {
                Color.black.edgesIgnoringSafeArea(.all)
                
                VStack(spacing: 0) {
                    // Search bar
                    HStack {
                        Image(systemName: "magnifyingglass")
                            .foregroundColor(.gray)
                        TextField("Search", text: $searchText)
                            .textFieldStyle(.plain)
                            .foregroundColor(.white)
                        if !searchText.isEmpty {
                            Button(action: { searchText = "" }) {
                                Image(systemName: "xmark.circle.fill")
                                    .foregroundColor(.gray)
                            }
                        }
                    }
                    .padding(10)
                    .background(Color(UIColor.systemGray6))
                    
                    // Content
                    List {
                        if !currentTags.isEmpty {
                            Section(header: Text("CURRENT TAGS").foregroundColor(.gray)) {
                                ForEach(currentTags) { tag in
                                    HStack {
                                        Text(tag.name)
                                            .foregroundColor(.white)
                                        Spacer()
                                        Image(systemName: "checkmark")
                                            .foregroundColor(.blue)
                                    }
                                }
                                .onDelete { indexSet in
                                    for index in indexSet {
                                        let tag = currentTags[index]
                                        selectedTags.remove(tag.id)
                                        currentTags.remove(at: index)
                                    }
                                }
                            }
                        }
                        
                        if !searchResults.isEmpty {
                            Section(header: Text("AVAILABLE TAGS").foregroundColor(.gray)) {
                                ForEach(searchResults) { tag in
                                    HStack {
                                        Text(tag.name)
                                            .foregroundColor(.white)
                                        Spacer()
                                        if selectedTags.contains(tag.id) {
                                            Image(systemName: "checkmark")
                                                .foregroundColor(.blue)
                                        }
                                    }
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        toggleTag(tag)
                                    }
                                }
                            }
                        }
                        
                        Section {
                            Button(action: { showingNewTagAlert = true }) {
                                HStack {
                                    Image(systemName: "plus.circle.fill")
                                    Text("Add New Tag")
                                }
                                .foregroundColor(.blue)
                            }
                        }
                    }
                    .listStyle(.insetGrouped)
                    .scrollContentBackground(.hidden)
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Edit Tags")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        Task {
                            isLoading = true
                            do {
                                let updatedScene = try await appModel.api.updateSceneTags(sceneID: scene.id, tagIDs: Array(selectedTags))
                                isLoading = false
                                onTagsUpdated(updatedScene)
                                dismiss()
                            } catch {
                                print("Error updating tags: \(error)")
                                isLoading = false
                            }
                        }
                    }
                    .disabled(isLoading)
                }
            }
        }
        .onChange(of: searchText) { _, newValue in
            searchTags(query: newValue)
        }
        .alert("Add New Tag", isPresented: $showingNewTagAlert) {
            TextField("Tag Name", text: $newTagName)
            Button("Cancel", role: .cancel) { }
            Button("Add") {
                Task {
                    do {
                        let newTag = try await appModel.api.createTag(name: newTagName)
                        selectedTags.insert(newTag.id)
                        currentTags.append(newTag)
                        newTagName = ""
                    } catch {
                        print("Error creating tag: \(error)")
                    }
                }
            }
        }
    }
    
    private func searchTags(query: String) {
        Task {
            if !query.isEmpty {
                do {
                    searchResults = try await appModel.api.searchTags(query: query)
                } catch {
                    print("Error searching tags: \(error)")
                }
            } else {
                searchResults = []
            }
        }
    }
    
    private func toggleTag(_ tag: StashScene.Tag) {
        if selectedTags.contains(tag.id) {
            selectedTags.remove(tag.id)
            currentTags.removeAll { $0.id == tag.id }
        } else {
            selectedTags.insert(tag.id)
            currentTags.append(tag)
        }
    }
}

================
File: stash/Views/Tags/TagSelectionView.swift
================
import SwiftUI

struct TagSelectionView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.colorScheme) private var colorScheme
    @EnvironmentObject private var appModel: AppModel
    @Binding var selectedTagId: String
    @Binding var selectedTagName: String
    @State private var searchText = ""
    @State private var tags: [StashScene.Tag] = []
    @State private var recentTags: [StashScene.Tag] = []
    @State private var isLoading = false
    var onTagSelected: (String, String) -> Void = { _, _ in }
    
    var body: some View {
        List {
            if !recentTags.isEmpty && searchText.isEmpty {
                Section("Recent Tags") {
                    ForEach(recentTags) { tag in
                        Button(action: {
                            selectTag(tag)
                        }) {
                            Text(tag.name)
                                .foregroundColor(colorScheme == .dark ? .white : .black)
                        }
                        .swipeActions(edge: .trailing) {
                            Button(role: .destructive) {
                                removeFromRecents(tag)
                            } label: {
                                Label("Remove", systemImage: "trash")
                            }
                        }
                    }
                }
            }
            
            Section(searchText.isEmpty ? "All Tags" : "Search Results") {
                ForEach(tags) { tag in
                    Button(action: {
                        selectTag(tag)
                    }) {
                        Text(tag.name)
                            .foregroundColor(colorScheme == .dark ? .white : .black)
                    }
                }
            }
        }
        .preferredColorScheme(colorScheme)
        .searchable(text: $searchText)
        .onChange(of: searchText) { _, newValue in
            Task {
                await searchTags(query: newValue)
            }
        }
        .navigationTitle("Select Tag")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") {
                    dismiss()
                }
            }
        }
        .task {
            print("üè∑Ô∏è Initial load of TagSelectionView")
            await loadRecentTags()
            await searchTags(query: "")
        }
    }
    
    private func selectTag(_ tag: StashScene.Tag) {
        print("üè∑Ô∏è Selected tag: \(tag.name) (\(tag.id))")
        selectedTagId = tag.id
        selectedTagName = tag.name
        onTagSelected(tag.id, tag.name)
        
        // Save to recent tags and increment usage
        var tagUsage = UserDefaults.standard.dictionary(forKey: "tagUsageCounts") as? [String: Int] ?? [:]
        let currentCount = (tagUsage[tag.id] ?? 0) + 1
        tagUsage[tag.id] = currentCount
        UserDefaults.standard.set(tagUsage, forKey: "tagUsageCounts")
        print("üè∑Ô∏è Updated usage count for \(tag.name) to \(currentCount)")
        
        // Save to recent tags if used 2+ times
        if currentCount >= 2 {
            print("üè∑Ô∏è Adding \(tag.name) to recent tags (used \(currentCount) times)")
            saveRecentTagSync(tag)
        } else {
            print("üè∑Ô∏è Not adding \(tag.name) to recent tags yet (only used \(currentCount) time(s))")
        }
        
        dismiss()
    }
    
    private func saveRecentTagSync(_ tag: StashScene.Tag) {
        var recentTagIds = UserDefaults.standard.array(forKey: "recentTags") as? [String] ?? []
        print("üè∑Ô∏è Current recent tags: \(recentTagIds)")
        
        // Remove if already exists
        recentTagIds.removeAll { $0 == tag.id }
        
        // Add to front
        recentTagIds.insert(tag.id, at: 0)
        
        // Keep only last 5 tags
        if recentTagIds.count > 5 {
            recentTagIds = Array(recentTagIds.prefix(5))
        }
        
        UserDefaults.standard.set(recentTagIds, forKey: "recentTags")
        print("üè∑Ô∏è Saved recent tags: \(recentTagIds)")
        
        // Update the view immediately with what we have
        recentTags = recentTagIds.compactMap { tagId in
            tags.first { $0.id == tagId }
        }
    }
    
    private func loadRecentTags() async {
        let tagUsage = UserDefaults.standard.dictionary(forKey: "tagUsageCounts") as? [String: Int] ?? [:]
        let recentTagIds = UserDefaults.standard.array(forKey: "recentTags") as? [String] ?? []

        print("üè∑Ô∏è Found \(recentTagIds.count) recent tag IDs: \(recentTagIds)")
        print("üè∑Ô∏è Tag usage counts: \(tagUsage)")

        // Fetch any missing recent tags
        let missingTagIds = recentTagIds.filter { tagId in
            !tags.contains { $0.id == tagId }
        }

        if !missingTagIds.isEmpty {
            print("üè∑Ô∏è Fetching \(missingTagIds.count) missing tags")
            do {
                for tagId in missingTagIds {
                    try await appModel.api.findTag(id: tagId) { result in
                        if case .success(let tag) = result {
                            self.tags.append(tag)
                        }
                    }
                }
            } catch {
                print("‚ùå Error fetching missing tags: \(error)")
            }
        }
        
        print("üè∑Ô∏è Available tags: \(tags.map { "\($0.name) (\($0.id))" }.joined(separator: ", "))")
        
        // Only show tags used 2+ times
        recentTags = recentTagIds.compactMap { tagId in
            if let usageCount = tagUsage[tagId], usageCount >= 2 {
                if let tag = tags.first(where: { $0.id == tagId }) {
                    print("üè∑Ô∏è Including recent tag: \(tag.name) (ID: \(tag.id), used \(usageCount) times)")
                    return tag
                } else {
                    print("üè∑Ô∏è Could not find tag with ID: \(tagId) in available tags")
                }
            } else {
                print("üè∑Ô∏è Tag \(tagId) has insufficient usage count: \(tagUsage[tagId] ?? 0)")
            }
            return nil
        }
        
        print("üè∑Ô∏è Final recent tags: \(recentTags.map { "\($0.name) (\($0.id))" }.joined(separator: ", "))")
    }
    
    private func searchTags(query: String) async {
        do {
            try await appModel.api.searchTags(query: query) { result in
                switch result {
                case .success(let foundTags):
                    self.tags = foundTags
                    print("üè∑Ô∏è Loaded \(self.tags.count) tags from search")
                    Task {
                        await self.loadRecentTags()
                    }
                case .failure(let error):
                    print("‚ùå Error searching tags: \(error)")
                }
            }
        } catch {
            print("‚ùå Error searching tags: \(error)")
        }
    }
    
    private func removeFromRecents(_ tag: StashScene.Tag) {
        print("üè∑Ô∏è Removing \(tag.name) from recent tags")
        
        // Remove from UserDefaults
        var recentTagIds = UserDefaults.standard.array(forKey: "recentTags") as? [String] ?? []
        recentTagIds.removeAll { $0 == tag.id }
        UserDefaults.standard.set(recentTagIds, forKey: "recentTags")
        
        // Remove from usage counts
        var tagUsage = UserDefaults.standard.dictionary(forKey: "tagUsageCounts") as? [String: Int] ?? [:]
        tagUsage.removeValue(forKey: tag.id)
        UserDefaults.standard.set(tagUsage, forKey: "tagUsageCounts")
        
        // Update the view
        recentTags.removeAll { $0.id == tag.id }
    }
}

================
File: stash/Views/MarkersView.swift
================
import SwiftUI
import Foundation

// Preference key to get width without affecting layout
private struct WidthPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

struct MarkersView: View {
    // Dependencies
    @EnvironmentObject private var appModel: AppModel

    // State for loading
    @State private var currentPage = 1
    @State private var isLoadingMore = false
    @State private var hasMorePages = true
    @State private var allMarkers: [SceneMarker] = []
    @State private var isLoading = false

    // State for filtering and UI
    @State private var selectedTagId: String? = nil
    @State private var showingCreateMarker = false
    @State private var availableWidth: CGFloat = 1200 // Default width estimate
    @State private var visibleMarkers: Set<String> = []
    @State private var displayedMarkers: [SceneMarker] = []

    // Always return 3 columns for markers view to match scenes grid
    private func getColumnCount(for width: CGFloat) -> Int {
        return 3 // Fixed 3 columns for consistency with scenes view
    }

    // Tag filter helpers
    private func shouldIncludeMarker(_ marker: SceneMarker, tagId: String) -> Bool {
        return marker.primary_tag.id == tagId ||
        marker.tags.contains(where: { $0.id == tagId })
    }

    private func updateDisplayedMarkers() {
        if let tagId = selectedTagId {
            // Filter markers by selected tag
            displayedMarkers = allMarkers.filter { marker in
                shouldIncludeMarker(marker, tagId: tagId)
            }
        } else {
            // Show all markers
            displayedMarkers = allMarkers
        }
    }

    private func clearFilter() {
        selectedTagId = nil
        Task {
            currentPage = 1
            await initialLoad()
        }
    }

    private func handleTagSelection(_ tag: SceneMarker.Tag) {
        print("üîç Setting tag filter: \(tag.name) (ID: \(tag.id))")
        selectedTagId = tag.id
        currentPage = 1
        Task {
            await loadMarkersForTag(tag.id)
        }
    }

    private var filterHeader: some View {
        Group {
            if let selectedTagId = selectedTagId,
               let marker = displayedMarkers.first(where: {
                   $0.primary_tag.id == selectedTagId ||
                   $0.tags.contains(where: { $0.id == selectedTagId })
               }),
               let tagName = (marker.primary_tag.id == selectedTagId ?
                            marker.primary_tag.name :
                            marker.tags.first(where: { $0.id == selectedTagId })?.name) {
                HStack {
                    Text("Filtered by tag: ")
                        .foregroundColor(.secondary)
                        .fontWeight(.medium)

                    Text(tagName)
                        .foregroundColor(.primary)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.blue.opacity(0.2))
                        .cornerRadius(12)
                        .fontWeight(.semibold)

                    Spacer()

                    Button(action: clearFilter) {
                        HStack(spacing: 4) {
                            Text("Clear Filter")
                                .font(.subheadline)
                            Image(systemName: "xmark.circle.fill")
                        }
                        .foregroundColor(.white)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.blue)
                        .cornerRadius(8)
                    }
                }
                .padding(.horizontal)
                .padding(.vertical, 10)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(8)
                .padding(.horizontal)
                .padding(.top)
            }
        }
    }

    private var markerGrid: some View {
        // Fixed 3-column grid to match scenes view
        let columns = [
            GridItem(.flexible()),
            GridItem(.flexible()),
            GridItem(.flexible())
        ]

        return LazyVGrid(columns: columns, spacing: 16) {
            ForEach(displayedMarkers) { marker in
                // Custom compact marker row that matches the SceneRow style
                VStack(alignment: .leading) {
                    // Thumbnail with timestamp
                    ZStack {
                        // Thumbnail
                        AsyncImage(url: URL(string: marker.screenshot)) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            Rectangle()
                                .fill(Color.gray.opacity(0.2))
                        }
                        .frame(height: 180)
                        .clipped()
                        
                        // Timestamp overlay
                        HStack {
                            Text(formatDuration(marker.seconds))
                                .font(.caption)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(.ultraThinMaterial)
                                .cornerRadius(4)
                            
                            Spacer()
                            
                            // Play button
                            Button {
                                appModel.navigateToMarker(marker)
                            } label: {
                                Image(systemName: "play.circle.fill")
                                    .font(.system(size: 32))
                                    .foregroundColor(.white)
                                    .shadow(color: .black.opacity(0.6), radius: 2)
                            }
                            .padding(8)
                        }
                        .padding(8)
                    }
                    
                    // Info section
                    VStack(alignment: .leading, spacing: 8) {
                        // Title
                        Text(marker.title)
                            .font(.headline)
                            .lineLimit(1)
                        
                        // Tags
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack {
                                Button(action: { 
                                    handleTagSelection(marker.primary_tag)
                                }) {
                                    Text(marker.primary_tag.name)
                                        .font(.caption)
                                        .padding(.horizontal, 8)
                                        .padding(.vertical, 4)
                                        .background(Color.blue.opacity(0.2))
                                        .cornerRadius(12)
                                }
                                
                                ForEach(marker.tags) { tag in
                                    Button(action: {
                                        handleTagSelection(tag)
                                    }) {
                                        Text(tag.name)
                                            .font(.caption)
                                            .padding(.horizontal, 8)
                                            .padding(.vertical, 4)
                                            .background(Color.secondary.opacity(0.15))
                                            .cornerRadius(12)
                                    }
                                }
                            }
                        }
                        
                        // Scene info
                        Text("From: \(marker.scene.title ?? "Unknown Scene")")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(12)
                }
                .background(Color(UIColor.secondarySystemBackground))
                .cornerRadius(12)
                .shadow(radius: 2)
                .onTapGesture {
                    appModel.navigateToMarker(marker)
                }
                .contextMenu {
                    Button(action: {
                        appModel.navigateToMarker(marker)
                    }) {
                        Label("Play Marker", systemImage: "play.fill")
                    }
                    
                    Button(action: {
                        // Copy marker URL to clipboard
                        UIPasteboard.general.string = "\(appModel.serverAddress)/markers/\(marker.id)"
                    }) {
                        Label("Copy Link", systemImage: "link")
                    }
                    
                    if let scene = appModel.api.scenes.first(where: { $0.id == marker.scene.id }) {
                        Button(action: {
                            appModel.currentScene = scene
                            appModel.navigationPath.append(scene)
                        }) {
                            Label("Go to Scene", systemImage: "film")
                        }
                    }
                }
                .environmentObject(appModel)
                // Add animations to match SceneRow
                .slideIn(from: .bottom, delay: Double(displayedMarkers.firstIndex(where: { $0.id == marker.id }) ?? 0) * 0.05, duration: 0.4)
                .applyHoverEffect()
                .onAppear {
                    visibleMarkers.insert(marker.id)

                    // Check if this is near the end of the list
                    checkLoadMore(marker)
                }
                .onDisappear {
                    visibleMarkers.remove(marker.id)
                }
            }

            if isLoadingMore {
                ProgressView()
                    .gridCellColumns(3) // Fixed to 3 columns
                    .frame(height: 50)
                    .padding()
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 8)
    }

    private func checkLoadMore(_ marker: SceneMarker) {
        // Check if this is one of the last few markers displayed
        let visibleIndex = displayedMarkers.firstIndex(where: { $0.id == marker.id }) ?? 0
        let threshold = max(0, displayedMarkers.count - 5) // Load more when we're 5 items from the end

        if visibleIndex >= threshold && !isLoadingMore && hasMorePages {
            print("Loading more markers at index \(visibleIndex) of \(displayedMarkers.count)")
            Task {
                if !appModel.searchQuery.isEmpty {
                    await loadMoreSearchResults()
                } else if let tagId = selectedTagId {
                    await loadMoreMarkersForTag(tagId)
                } else {
                    await loadMoreMarkers()
                }
            }
        }
    }

    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                // Filter header if applicable
                filterHeader

                if isLoading && allMarkers.isEmpty {
                    // Initial loading state
                    VStack(spacing: 20) {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(1.5)

                        Text("Loading markers...")
                            .foregroundColor(.secondary)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .padding(.top, 100)
                } else if displayedMarkers.isEmpty {
                    // Empty state with refresh button
                    VStack(spacing: 20) {
                        Image(systemName: "bookmark.slash")
                            .font(.system(size: 50))
                            .foregroundColor(.secondary)

                        Text(appModel.searchQuery.isEmpty ? "No markers found" : "No results found")
                            .font(.title2)
                            .foregroundColor(.secondary)

                        if !appModel.searchQuery.isEmpty {
                            Text("Try a different search")
                                .foregroundColor(.secondary)
                        } else {
                            Button(action: {
                                Task {
                                    await initialLoad()
                                }
                            }) {
                                Label("Refresh", systemImage: "arrow.clockwise")
                                    .padding(.horizontal, 20)
                                    .padding(.vertical, 10)
                                    .background(Color.blue)
                                    .foregroundColor(.white)
                                    .cornerRadius(8)
                            }
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .padding(.top, 100)
                } else {
                    // Markers grid with scrolling
                    ScrollView(.vertical, showsIndicators: true) {
                        // Gets the width without affecting layout
                        GeometryReader { geo in
                            Color.clear
                                .preference(key: WidthPreferenceKey.self, value: geo.size.width)
                        }
                        .frame(height: 1) // Minimal height so it doesn't affect layout

                        markerGrid
                            .padding(.bottom, 40) // Add extra padding at bottom for safe scrolling
                    }
                    .onPreferenceChange(WidthPreferenceKey.self) { width in
                        if abs(availableWidth - width) > 50 {
                            // Only update on significant changes
                            availableWidth = width
                        }
                    }
                    .contentShape(Rectangle()) // Make sure the whole area is tappable
                    .onTapGesture {
                        // Stop all playing videos when tapping the background
                        GlobalVideoManager.shared.stopAllPreviews()
                    }
                }
            }

            // Overlay loading indicator for subsequent loads
            if isLoading && !allMarkers.isEmpty {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(width: 60, height: 60)
                    .background(.ultraThinMaterial)
                    .cornerRadius(10)
            }
        }
        .navigationTitle("Markers")
        .searchable(text: $appModel.searchQuery, prompt: "Search markers...")
        .onChange(of: appModel.searchQuery) { _, newValue in
            Task {
                if !newValue.isEmpty {
                    print("üîç Search text changed to: '\(newValue)'")
                    appModel.isSearching = true
                    await searchMarkers(query: newValue)
                    updateDisplayedMarkers()
                } else {
                    print("üîç Search cleared, restoring original markers")
                    appModel.isSearching = false
                    await initialLoad()
                    updateDisplayedMarkers()
                }
            }
        }
        .sheet(isPresented: $showingCreateMarker) {
            CreateMarkerView(initialSeconds: "", sceneID: "")
                .environmentObject(appModel)
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: {
                    showingCreateMarker = true
                }) {
                    Label("Create Marker", systemImage: "plus")
                }
            }
        }
        .task {
            print("üîç Initial load of markers - View appeared")
            if allMarkers.isEmpty {
                print("üîç Initial load of markers - No existing markers, fetching")
                await initialLoad()
                updateDisplayedMarkers() // Update after loading
            }
        }
        .refreshable {
            await initialLoad()
            updateDisplayedMarkers() // Update after refreshing
        }
    }

    private func searchMarkers(query: String) async {
        print("üîç Searching markers with query: '\(query)'")
        isLoading = true

        // Store original markers if this is our first search
        if !appModel.isSearching {
            print("üîç Storing original markers for filtering")
            let originalMarkers = appModel.api.markers

            // Reset search state
            currentPage = 1
            hasMorePages = true
            allMarkers = []

            // Perform local search on original markers
            let filteredMarkers = originalMarkers.filter { marker in
                let titleMatch = marker.title.localizedCaseInsensitiveContains(query)
                let tagMatch = marker.primary_tag.name.localizedCaseInsensitiveContains(query)
                let otherTagsMatch = marker.tags.contains { tag in
                    tag.name.localizedCaseInsensitiveContains(query)
                }

                return titleMatch || tagMatch || otherTagsMatch
            }

            print("üîç Found \(filteredMarkers.count) matching markers")
            allMarkers = filteredMarkers
        } else {
            // If already searching, use API search
            print("üîç Using API search for query: '\(query)'")
            // Non-throwing method that updates internal state
            await appModel.api.updateMarkersFromSearch(query: query)
            allMarkers = appModel.api.markers
        }

        isLoading = false
    }

    private func loadMoreSearchResults() async {
        guard !isLoadingMore else { return }

        isLoadingMore = true
        currentPage += 1

        let previousCount = allMarkers.count
        await appModel.api.updateMarkersFromSearch(query: appModel.searchQuery)

        // Add new markers without duplicates
        let newMarkers = appModel.api.markers.filter { marker in
            !allMarkers.contains(where: { $0.id == marker.id })
        }
        allMarkers.append(contentsOf: newMarkers)

        hasMorePages = !newMarkers.isEmpty
        isLoadingMore = false

        updateDisplayedMarkers() // Update displayed markers after loading more
    }

    private func initialLoad() async {
        print("üìä MarkersView initialLoad started")
        isLoading = true
        currentPage = 1
        hasMorePages = true
        allMarkers = []
        visibleMarkers.removeAll()
        selectedTagId = nil

        // Debug: Print server connection information
        print("üìä MarkersView server address: \(appModel.serverAddress)")
        print("üìä MarkersView auth status: \(appModel.api.isAuthenticated ? "Authenticated" : "Not authenticated")")
        print("üìä MarkersView connection status: \(appModel.api.connectionStatusMessage)")
        print("üìä MarkersView API key: \(appModel.api.apiKeyForURLs.prefix(5))...")

        // Force reconnection to ensure auth is current
        if !appModel.api.isAuthenticated {
            print("üìä Forcing authentication before fetching markers")
            do {
                try await appModel.api.checkServerConnection()
                print("üìä Connection status after check: \(appModel.api.connectionStatusMessage)")
            } catch {
                print("‚ùå Failed to authenticate: \(error)")
            }
        }

        // Try to fetch markers with more detailed logging
        print("üìä MarkersView attempting to fetch markers...")
        await appModel.api.fetchMarkers(page: currentPage, appendResults: false)
        print("üìä MarkersView markers fetch completed, received: \(appModel.api.markers.count)")

        // Print first marker details if available for debugging
        if let firstMarker = appModel.api.markers.first {
            print("üìä First marker details:")
            print("  ID: \(firstMarker.id)")
            print("  Title: \(firstMarker.title)")
            print("  Scene ID: \(firstMarker.scene.id)")
            print("  Primary tag: \(firstMarker.primary_tag.name)")

            if let performers = firstMarker.scene.performers, !performers.isEmpty {
                print("  Has performers: Yes (\(performers.count))")
                print("  First performer: \(performers[0].name)")
            } else {
                print("  Has performers: No")
            }

            print("  Screenshot URL: \(firstMarker.screenshot)")
            print("  Stream URL: \(firstMarker.stream)")
        } else {
            print("‚ùå No markers returned from API")

            // Additional debug if markers are empty
            print("üìä Checking API error state: \(appModel.api.error?.localizedDescription ?? "No error")")
            print("üìä Is API loading: \(appModel.api.isLoading ? "Yes" : "No")")
        }

        await MainActor.run {
            // Update on the main thread to avoid UI issues
            allMarkers = appModel.api.markers
            updateDisplayedMarkers() // Update displayed markers after loading
            isLoading = false
            print("üìä MarkersView allMarkers updated with \(allMarkers.count) items")
        }

        // Preload the next page in the background for smoother scrolling
        if hasMorePages {
            Task {
                try? await Task.sleep(nanoseconds: 500_000_000) // Wait 0.5 seconds before pre-fetching
                await preloadNextPage()
            }
        }
    }

    private func preloadNextPage() async {
        guard !isLoadingMore && hasMorePages else { return }

        print("Preloading next page of markers")
        let tempLoadingFlag = isLoadingMore
        isLoadingMore = true

        let nextPage = currentPage + 1
        let previousCount = allMarkers.count

        if let tagId = selectedTagId {
            await appModel.api.fetchMarkersByTag(tagId: tagId, page: nextPage, appendResults: true)
        } else {
            await appModel.api.fetchMarkers(page: nextPage, appendResults: true)
        }

        // Add new markers without duplicates
        let newMarkers = appModel.api.markers.filter { marker in
            !allMarkers.contains(where: { $0.id == marker.id })
        }

        if !newMarkers.isEmpty {
            allMarkers.append(contentsOf: newMarkers)
            updateDisplayedMarkers()
            print("Preloaded \(newMarkers.count) markers for smooth scrolling")

            // Only update current page if we successfully preloaded data
            currentPage = nextPage
            hasMorePages = true
        } else {
            hasMorePages = false
        }

        isLoadingMore = tempLoadingFlag
    }

    private func loadMoreMarkers() async {
        guard !isLoadingMore else { return }

        isLoadingMore = true
        currentPage += 1

        print("üî• Loading more markers (page \(currentPage))")
        let previousCount = allMarkers.count
        await appModel.api.fetchMarkers(page: currentPage, appendResults: true)

        // Add new markers without duplicates
        let newMarkers = appModel.api.markers.filter { marker in
            !allMarkers.contains(where: { $0.id == marker.id })
        }
        allMarkers.append(contentsOf: newMarkers)

        hasMorePages = !newMarkers.isEmpty
        isLoadingMore = false

        updateDisplayedMarkers() // Update displayed markers after loading more
    }

    private func loadMarkersForTag(_ tagId: String) async {
        isLoading = true
        currentPage = 1
        hasMorePages = true
        allMarkers = []
        visibleMarkers.removeAll()

        print("üè∑Ô∏è Loading markers for tag ID: \(tagId)")
        await appModel.api.fetchMarkersByTag(tagId: tagId, page: currentPage, appendResults: false)

        await MainActor.run {
            allMarkers = appModel.api.markers
            updateDisplayedMarkers()

            // Sort markers by newest first (assuming IDs are sequential)
            displayedMarkers.sort { marker1, marker2 in
                // For equal titles, sort by id (most recent first)
                return marker1.id > marker2.id
            }

            print("üè∑Ô∏è Displaying \(displayedMarkers.count) markers with tag ID: \(tagId)")
            isLoading = false
        }
    }

    /// Format duration into mm:ss or hh:mm:ss format
    private func formatDuration(_ seconds: Float) -> String {
        let hours = Int(seconds) / 3600
        let minutes = Int(seconds) / 60 % 60
        let secs = Int(seconds) % 60
        
        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, secs)
        } else {
            return String(format: "%d:%02d", minutes, secs)
        }
    }
    
    private func loadMoreMarkersForTag(_ tagId: String) async {
        guard !isLoadingMore else { return }

        isLoadingMore = true
        currentPage += 1

        print("üè∑Ô∏è Loading more markers for tag ID: \(tagId) (page \(currentPage))")
        await appModel.api.fetchMarkersByTag(tagId: tagId, page: currentPage, appendResults: true)

        // Filter results to avoid duplicates
        let newMarkers = appModel.api.markers.filter { marker in
            !allMarkers.contains(where: { $0.id == marker.id })
        }

        print("üè∑Ô∏è Retrieved \(newMarkers.count) new markers for tag ID: \(tagId)")

        await MainActor.run {
            if !newMarkers.isEmpty {
                // Add new markers
                allMarkers.append(contentsOf: newMarkers)
                updateDisplayedMarkers()

                // Re-sort with newest first
                displayedMarkers.sort { marker1, marker2 in
                    return marker1.id > marker2.id
                }

                print("üè∑Ô∏è Added \(newMarkers.count) new markers (total: \(displayedMarkers.count))")
            }

            // If we got any new results, there might be more pages
            hasMorePages = !newMarkers.isEmpty
            isLoadingMore = false
        }
    }
}

================
File: stash/Views/MediaLibraryView.swift
================
import SwiftUI
import AVKit
import Foundation

struct MediaLibraryToolbar: View {
    let onShowFilters: () -> Void
    let onRefresh: () -> Void
    
    var body: some View {
        Menu {
            Button(action: onShowFilters) {
                Label("Filters", systemImage: "line.3.horizontal.decrease.circle")
            }
            
            Button(action: onRefresh) {
                Label("Refresh", systemImage: "arrow.clockwise")
            }
        } label: {
            Image(systemName: "ellipsis.circle")
        }
    }
}

struct MediaLibraryView: View {
    @EnvironmentObject private var appModel: AppModel
    @State private var selectedScene: StashScene?
    @State private var showingFilters = false
    @State private var currentPage = 1
    @State private var isLoadingMore = false
    @State private var hasMorePages = true
    @State private var selectedTag: StashScene.Tag?
    @State private var selectedPerformer: StashScene.Performer?
    @State private var filterOptions = FilterOptions()
    @State private var currentFilter: String = "default"
    
    private var columns: [GridItem] {
        // Use different column sizes on iPad vs iPhone
        if UIDevice.current.userInterfaceIdiom == .pad {
            return [
                GridItem(.adaptive(minimum: 350, maximum: 450), spacing: 20)
            ]
        } else {
            return [
                GridItem(.adaptive(minimum: 300, maximum: 400), spacing: 16)
            ]
        }
    }
    
    var body: some View {
        Group {
            if appModel.api.isLoading && currentPage == 1 {
                VStack {
                    ProgressView("Loading media...")
                        .scaleEffect(1.2)

                    Text("Loading your media library...")
                        .foregroundColor(.secondary)
                        .padding(.top)
                }
            } else {
                scenesContent
            }
        }
        .sheet(item: $selectedTag) { tag in
            NavigationStack {
                TaggedScenesView(tag: tag)
                    .environmentObject(appModel)
            }
        }
        .sheet(isPresented: $showingFilters) {
            FilterOptionsView(
                filterOptions: $filterOptions,
                onApply: {
                    Task {
                        currentFilter = "custom"
                        await appModel.api.fetchScenes(page: 1, filterOptions: filterOptions)
                    }
                }
            )
        }
        .onReceive(NotificationCenter.default.publisher(for: Notification.Name("ShowAdvancedFilters"))) { _ in
            showingFilters = true
        }
    }
    
    private var scenesContent: some View {
        ScrollView {
            if appModel.api.scenes.isEmpty && !appModel.api.isLoading {
                VStack(spacing: 20) {
                    Image(systemName: "film")
                        .font(.system(size: 60))
                        .foregroundColor(.secondary)
                        .padding(.top, 40)
                    
                    Text("No media found")
                        .font(.title2)
                    
                    Text("Try refreshing or check your connection")
                        .foregroundColor(.secondary)
                    
                    Button("Refresh") {
                        Task {
                            await resetAndReload()
                        }
                    }
                    .buttonStyle(.borderedProminent)
                    .padding(.top, 10)
                }
                .padding(.top, 40)
            } else {
                ScenesGrid(
                    scenes: appModel.api.scenes,
                    columns: columns,
                    onSceneSelected: { scene in
                        appModel.navigateToScene(scene)
                    },
                    onTagSelected: { selectedTag = $0 },
                    onPerformerSelected: { performer in
                        appModel.navigateToPerformer(performer)
                    },
                    onSceneAppear: { scene in
                        if scene == appModel.api.scenes.last && !isLoadingMore && hasMorePages {
                            Task {
                                await loadMoreScenes()
                            }
                        }
                    },
                    onSceneUpdated: { updatedScene in
                        if let index = appModel.api.scenes.firstIndex(where: { $0.id == updatedScene.id }) {
                            appModel.api.scenes[index] = updatedScene
                        }
                    },
                    isLoadingMore: isLoadingMore
                )
            }
        }
        .searchable(text: $appModel.searchQuery)
        .onChange(of: appModel.searchQuery) { _, newValue in
            Task {
                // Debounce search
                try? await Task.sleep(for: .milliseconds(500))
                
                if !Task.isCancelled {
                    if !newValue.isEmpty {
                        try? await appModel.api.searchScenes(query: newValue)
                    } else {
                        await resetAndReload()
                    }
                }
            }
        }
        .refreshable {
            await resetAndReload()
        }
        .navigationTitle("Media Library")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                HStack {
                    Button {
                        Task {
                            await resetAndReload()
                        }
                    } label: {
                        Image(systemName: "shuffle")
                    }
                    .simultaneousGesture(
                        LongPressGesture(minimumDuration: 0.5)
                            .onEnded { _ in
                                playRandomScene()
                            }
                    )
                    .contextMenu {
                        Button {
                            Task {
                                await resetAndReload()
                            }
                        } label: {
                            Label("Shuffle List", systemImage: "shuffle")
                        }
                        
                        Button {
                            playRandomScene()
                        } label: {
                            Label("Shuffle Play", systemImage: "play.fill")
                        }
                    }
                    
                    FilterMenuView(
                        currentFilter: $currentFilter,
                        onDefaultSelected: {
                            Task {
                                await resetAndReload()
                            }
                        },
                        onNewestSelected: {
                            Task {
                                await appModel.api.fetchScenes(page: 1, sort: "date", direction: "DESC")
                            }
                        },
                        onOCounterSelected: {
                            Task {
                                await appModel.api.fetchScenes(page: 1, sort: "o_counter", direction: "DESC")
                            }
                        },
                        onRandomSelected: {
                            Task {
                                await appModel.api.fetchScenes(page: 1, sort: "random", direction: "DESC")
                            }
                        },
                        onAdvancedFilters: {
                            showingFilters = true
                        },
                        onReload: {
                            Task {
                                await resetAndReload()
                            }
                        }
                    )
                }
            }
        }
        .task {
            // Always attempt to load on appearance
            if appModel.api.scenes.isEmpty {
                Task {
                    await initialLoad()
                    print("üîÑ Loaded scenes in MediaLibraryView: \(appModel.api.scenes.count)")
                }
            }
        }
    }
    
    private func initialLoad() async {
        currentPage = 1
        hasMorePages = true
        appModel.api.scenes = []
        await loadScenes()
    }
    
    private func resetAndReload() async {
        await initialLoad()
    }
    
    private func loadScenes() async {
        // Use different sorting based on the current filter
        switch currentFilter {
        case "newest":
            await appModel.api.fetchScenes(page: currentPage, sort: "date", direction: "DESC", appendResults: false)
        case "o_counter":
            await appModel.api.fetchScenes(page: currentPage, sort: "o_counter", direction: "DESC", appendResults: false)
        case "random":
            await appModel.api.fetchScenes(page: currentPage, sort: "random", direction: "DESC", appendResults: false)
        case "custom":
            await appModel.api.fetchScenes(page: currentPage, sort: "date", direction: "DESC", appendResults: false, filterOptions: filterOptions)
        default:
            await appModel.api.fetchScenes(page: currentPage, sort: "random", direction: "DESC", appendResults: false)
        }
    }
    
    private func loadMoreScenes() async {
        guard hasMorePages && !isLoadingMore else { return }

        isLoadingMore = true
        currentPage += 1

        print("üî• Loading more scenes (page \(currentPage))")
        let previousCount = appModel.api.scenes.count

        // Use different sorting based on the current filter for loading more
        switch currentFilter {
        case "newest":
            await appModel.api.fetchScenes(page: currentPage, sort: "date", direction: "DESC", appendResults: true)
        case "o_counter":
            await appModel.api.fetchScenes(page: currentPage, sort: "o_counter", direction: "DESC", appendResults: true)
        case "random":
            await appModel.api.fetchScenes(page: currentPage, sort: "random", direction: "DESC", appendResults: true)
        case "custom":
            await appModel.api.fetchScenes(page: currentPage, sort: "date", direction: "DESC", appendResults: true, filterOptions: filterOptions)
        default:
            await appModel.api.fetchScenes(page: currentPage, sort: "random", direction: "DESC", appendResults: true)
        }

        hasMorePages = appModel.api.scenes.count > previousCount
        isLoadingMore = false
    }
    
    private func playRandomScene() {
        guard let randomScene = appModel.api.scenes.randomElement() else { return }
        appModel.navigateToScene(randomScene)
    }
}

================
File: stash/Views/PerformersView.swift
================
import SwiftUI

struct PerformersView: View {
    @EnvironmentObject private var appModel: AppModel
    @State private var searchText = ""
    @State private var isLoading = false
    
    private let columns = [
        GridItem(.adaptive(minimum: 160, maximum: 200), spacing: 16)
    ]
    
    var filteredPerformers: [StashScene.Performer] {
        if searchText.isEmpty {
            return appModel.api.performers
        } else {
            return appModel.api.performers.filter { performer in
                performer.name.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        performersContent
            .navigationTitle("Performers")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        Task {
                            await loadPerformers()
                        }
                    }) {
                        Image(systemName: "arrow.clockwise")
                    }
                }
            }
            .task {
                // Load performers immediately when view appears
                if appModel.api.performers.isEmpty && !isLoading {
                    print("üì± Initial view task triggered - loading performers")
                    await loadPerformers()
                }
            }
    }
    
    private var performersContent: some View {
        VStack {
            // Search bar
            TextField("Search performers", text: $searchText)
                .padding(10)
                .background(Color(.systemGray6))
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.top, 8)

            ScrollView {
                if appModel.api.performers.isEmpty || isLoading {
                    VStack {
                        LoadingRow()
                            .padding(.top, 40)
                        Text("Loading performers...")
                            .foregroundColor(.secondary)
                            .padding(.top, 8)
                    }
                } else if filteredPerformers.isEmpty {
                    VStack(spacing: 12) {
                        Image(systemName: "person.slash")
                            .font(.system(size: 36))
                            .foregroundColor(.secondary)
                            .scaleIn(from: 0.5, duration: 0.7)
                        Text("No performers found")
                            .font(.headline)
                            .fadeIn(delay: 0.3)
                        if searchText.isEmpty {
                            Text("No female performers with over 2 scenes available")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .fadeIn(delay: 0.6)
                        } else {
                            Text("Try a different search term")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .fadeIn(delay: 0.6)
                        }
                    }
                    .padding(.top, 40)
                } else {
                    LazyVGrid(columns: columns, spacing: 16) {
                        ForEach(Array(filteredPerformers.enumerated()), id: \.element.id) { index, performer in
                            Button(action: {
                                appModel.navigateToPerformer(performer)
                            }) {
                                PerformerRow(performer: performer)
                                    .scaleIn(from: 0.9, delay: Double(index % 10) * 0.05, duration: 0.4)
                                    .applyHoverEffect(scale: 1.03, shadowRadius: 6)
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                    .padding(16)
                }
            }
        }
        .onAppear {
            print("üì± PerformersContent onAppear called")
            print("üì± Current performer count: \(appModel.api.performers.count)")
            print("üì± Is loading: \(isLoading)")
            
            // Immediate loading without task - this is important for first view appearance
            if appModel.api.performers.isEmpty && !isLoading {
                print("üì± Loading performers from content onAppear - DIRECT CALL")
                // Use immediate loading instead of task to ensure it happens right away
                isLoading = true
                appModel.api.fetchPerformers(
                    filter: .twoOrMore,
                    page: 1,
                    appendResults: false,
                    search: ""
                ) { result in
                    DispatchQueue.main.async {
                        self.isLoading = false
                        print("üì± Direct loading completed with \(result)")
                    }
                }
            }
        }
        .refreshable {
            await loadPerformers()
        }
    }
    
    private func loadPerformers() async {
        print("üì± loadPerformers called, setting isLoading = true")
        isLoading = true

        // Since we're using filter .twoOrMore and it already sets to > 2 scenes
        await appModel.api.fetchPerformers(
            filter: .twoOrMore,
            page: 1,
            appendResults: false,
            search: ""
        ) { result in
            print("üì± fetchPerformers completed with result: \(result)")

            // Always update UI on main thread
            DispatchQueue.main.async {
                self.isLoading = false

                switch result {
                case .success(let performers):
                    print("üì± Successfully loaded \(performers.count) performers")
                    // No need to set appModel.api.performers as it's already set in the API

                case .failure(let error):
                    print("‚ùå Error loading performers: \(error)")
                }
            }
        }

        print("üì± loadPerformers: API call initiated")
    }
}


struct LoadingRow: View {
    var body: some View {
        HStack {
            Spacer()
            ProgressView()
                .scaleEffect(1.3)
                .pulse(duration: 1.2, minScale: 0.8, maxScale: 1.2)
            Spacer()
        }
        .padding()
        .listRowSeparator(.hidden)
    }
}

================
File: stash/Views/SplashScreen.swift
================
import SwiftUI
import Foundation

struct SplashScreen: View {
    @State private var isActive = false
    @State private var scale: CGFloat = 0.8
    @State private var opacity: Double = 0
    @StateObject private var appModel = AppModel()
    
    var body: some View {
        if isActive {
            ContentView()
                .environmentObject(appModel)
        } else {
            ZStack {
                LinearGradient(
                    gradient: Gradient(colors: [Color.black, Color(UIColor.systemBlue)]),
                    startPoint: .top,
                    endPoint: .bottom
                )
                .ignoresSafeArea()
                
                VStack(spacing: 20) {
                    Image(systemName: "play.rectangle.fill")
                        .font(.system(size: 100))
                        .foregroundStyle(.linearGradient(
                            colors: [.white, .blue],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                        .symbolEffect(.pulse)
                    
                    Text("Stash")
                        .font(.system(size: 50, weight: .bold, design: .rounded))
                        .foregroundColor(.white)
                    
                    Text("Media Manager")
                        .font(.title2)
                        .fontWeight(.light)
                        .foregroundColor(.white.opacity(0.8))
                }
                .scaleEffect(scale)
                .opacity(opacity)
                .onAppear {
                    // Initialize app state
                    initializeAppState()
                    
                    withAnimation(.easeInOut(duration: 1.2)) {
                        scale = 1.0
                        opacity = 1.0
                    }
                    
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                        withAnimation {
                            self.isActive = true
                        }
                    }
                }
            }
        }
    }
    
    private func initializeAppState() {
        print("üöÄ Initializing app state in SplashScreen")
        
        // Check for saved server connection
        if let savedAddress = UserDefaults.standard.string(forKey: "serverAddress"), !savedAddress.isEmpty {
            appModel.serverAddress = savedAddress
            appModel.isConnected = true
            
            // Pre-load data while showing splash screen
            Task {
                do {
                    // Add a slight delay to ensure networking is fully initialized
                    try await Task.sleep(for: .milliseconds(800))
                    
                    // Check connection first
                    try await appModel.api.checkServerConnection()

                    // Prefetch some initial data to improve user experience
                    if appModel.api.connectionStatus == .connected {
                        print("üîÑ Prefetching initial data...")

                        // Fetch scenes
                        await appModel.api.fetchScenes(page: 1, sort: "random", direction: "DESC", appendResults: false)
                        print("‚úÖ Prefetched \(appModel.api.scenes.count) scenes while in splash screen")

                        // Also prefetch some performers
                        if !appModel.api.scenes.isEmpty {
                            await appModel.api.fetchPerformers(filter: .twoOrMore, page: 1, appendResults: false, search: "") { result in
                                if case .success(let performers) = result {
                                    print("‚úÖ Prefetched \(performers.count) performers while in splash screen")
                                }
                            }
                        }
                    } else {
                        print("‚ö†Ô∏è Connection check failed: \(appModel.api.connectionStatus)")
                    }
                } catch {
                    print("‚ö†Ô∏è Error during app initialization: \(error)")
                }
            }
        }
    }
}

#Preview {
    SplashScreen()
}

================
File: stash/Views/TaggedScenesView.swift
================
import SwiftUI

struct TaggedScenesView: View {
    let tag: StashScene.Tag
    @EnvironmentObject private var appModel: AppModel
    @State private var selectedTag: StashScene.Tag?
    
    init(tag: StashScene.Tag) {
        self.tag = tag
    }
    
    private func fetchTaggedScenes() async {
        let query = """
        {
            "operationName": "FindScenes",
            "variables": {
                "filter": {
                    "page": 1,
                    "per_page": 40,
                    "sort": "date",
                    "direction": "DESC"
                },
                "scene_filter": {
                    "tags": {
                        "value": ["\(tag.id)"],
                        "modifier": "INCLUDES"
                    }
                }
            },
            "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name } tags { id name } rating100 } } }"
        }
        """

        guard let url = URL(string: "\(appModel.serverAddress)/graphql") else { return }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue(appModel.serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.setValue("\(appModel.serverAddress)/scenes?c=(\"type\":\"tags\",\"value\":[\"\(tag.id)\"],\"modifier\":\"INCLUDES\")&sortby=date", forHTTPHeaderField: "Referer")
        request.setValue("en-US,en;q=0.9", forHTTPHeaderField: "Accept-Language")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.httpBody = query.data(using: .utf8)

        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            let response = try JSONDecoder().decode(GraphQLResponse<ScenesResponseData>.self, from: data)

            await MainActor.run {
                self.appModel.api.scenes = response.data.findScenes.scenes
            }
        } catch {
            print("üî• Error loading tagged scenes: \(error)")
        }
    }
    
    var body: some View {
        ScrollView {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 300))], spacing: 16) {
                ForEach(appModel.api.scenes) { scene in
                    SceneRow(
                        scene: scene,
                        onTagSelected: { tag in
                            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                               let window = windowScene.windows.first,
                               let rootViewController = window.rootViewController {
                                let hostingController = UIHostingController(rootView: NavigationStack {
                                    TaggedScenesView(tag: tag)
                                })
                                rootViewController.present(hostingController, animated: true)
                            }
                        },
                        onPerformerSelected: { performer in
                            appModel.navigateToPerformer(performer)
                        },
                        onSceneUpdated: { updatedScene in
                            Task {
                                await fetchTaggedScenes()
                            }
                        },
                        onSceneSelected: { scene in
                            appModel.navigateToScene(scene)
                        }
                    )
                    .onTapGesture {
                        appModel.navigateToScene(scene)
                    }
                }
            }
            .padding()
        }
        .navigationTitle("Tag: \(tag.name)")
        .task {
            await fetchTaggedScenes()
        }
        .sheet(item: $selectedTag) { tag in
            NavigationStack {
                TaggedScenesView(tag: tag)
                    .environmentObject(appModel)
            }
        }
    }
}

================
File: stash/Views/VideoPlayerView.swift
================
import SwiftUI
import AVKit
import UIKit
import Combine


struct VideoPlayerView: View {
    let scene: StashScene
    var startTime: Double?
    @EnvironmentObject private var appModel: AppModel
    @Environment(\.dismiss) private var dismiss
    @State private var showVideoPlayer = false
    @State private var showControls = false
    @State private var hideControlsTask: Task<Void, Never>?
    @State private var currentScene: StashScene
    @State private var effectiveStartTime: Double?
    // Store the original performer for the performer button
    @State private var originalPerformer: StashScene.Performer?
    
    init(scene: StashScene, startTime: Double? = nil) {
        self.scene = scene
        self.startTime = startTime
        _currentScene = State(initialValue: scene)

        // Log important parameters for debugging
        print("üì± VideoPlayerView init - scene: \(scene.id), startTime: \(String(describing: startTime))")
        
        // Set effective start time directly in init if provided
        if let startTime = startTime {
            _effectiveStartTime = State(initialValue: startTime)
            print("‚è± Setting effectiveStartTime directly to \(startTime) in init")
        }

        // Initialize the original performer if available
        if let firstPerformer = scene.performers.first {
            print("üì± Initializing original performer to: \(firstPerformer.name) (ID: \(firstPerformer.id))")
            _originalPerformer = State(initialValue: firstPerformer)
        }
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background color
                Color.black.ignoresSafeArea()

                // Full screen video player
                FullScreenVideoPlayer(
                    url: URL(string: currentScene.paths.stream)!,  // This will be converted to HLS URL in createPlayerViewController
                    startTime: effectiveStartTime,
                    scenes: appModel.api.scenes,
                    currentIndex: appModel.api.scenes.firstIndex(of: currentScene) ?? 0,
                    appModel: appModel
                )
                .ignoresSafeArea()
                .onAppear {
                    print("üì± FullScreenVideoPlayer appeared with startTime: \(String(describing: effectiveStartTime))")
                    
                    // Verify that seeking will happen if startTime is provided
                    if let startTime = effectiveStartTime, startTime > 0 {
                        print("‚è± FullScreenVideoPlayer will seek to \(startTime) seconds")
                    }
                }

                // This transparent layer captures taps across the entire view
                Color.clear
                    .contentShape(Rectangle())
                    .onTapGesture {
                        print("üëÜ Tap detected - toggling controls")
                        withAnimation(.easeInOut(duration: 0.3)) {
                            showControls.toggle()
                        }

                        // Schedule auto-hide when controls are shown
                        if showControls {
                            Task {
                                await scheduleControlsHide()
                            }
                        }
                    }

                // Control overlay - only show when showControls is true
                if showControls {
                    VStack {
                        // Close button at top
                        HStack {
                            Spacer()

                            Button(action: {
                                print("üîÑ Close button tapped")
                                dismiss()
                                appModel.currentScene = nil
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .font(.title)
                                    .foregroundColor(.white.opacity(0.8))
                                    .padding()
                                    .shadow(radius: 2)
                            }
                        }
                        .padding(.top, 10)

                        Spacer()

                        // Playback control buttons at bottom
                        HStack(spacing: 15) {
                            Spacer()

                            // Seek backward 30 seconds button
                            Button {
                                print("‚è™ Seek backward 30 seconds")
                                seekVideo(by: -30)
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.gray.opacity(0.7))
                                        .frame(width: 50, height: 50)
                                        .shadow(color: .black, radius: 4)

                                    // Icon
                                    Image(systemName: "gobackward.30")
                                        .font(.system(size: 20, weight: .bold))
                                        .foregroundColor(.white)

                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 50, height: 50)
                                }
                            }

                            // Button 1: Library Random - Play a completely random scene from library
                            Button {
                                print("üîÑ Library random button tapped")
                                handlePureRandomVideo()
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.blue.opacity(0.7))
                                        .frame(width: 60, height: 60)
                                        .shadow(color: .black, radius: 4)

                                    // Icon
                                    Image(systemName: "shuffle")
                                        .font(.system(size: 24, weight: .bold))
                                        .foregroundColor(.white)

                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 60, height: 60)
                                }
                            }
                            .simultaneousGesture(
                                LongPressGesture(minimumDuration: 0.5)
                                    .onEnded { _ in
                                        let generator = UIImpactFeedbackGenerator(style: .medium)
                                        generator.impactOccurred()
                                        // Show info about what this button does
                                        print("Showing button info: Random Scene")
                                    }
                            )

                            // Button 2: Random Position - Jump to random position in current video
                            Button {
                                print("üé≤ Random position button tapped")
                                handleRandomVideo() // Uses playNextScene() which jumps within current video
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.purple.opacity(0.8))
                                        .frame(width: 60, height: 60)
                                        .shadow(color: .black, radius: 4)

                                    // Icon
                                    Image(systemName: "arrow.triangle.2.circlepath")
                                        .font(.system(size: 24, weight: .bold))
                                        .foregroundColor(.white)

                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 60, height: 60)
                                }
                            }
                            .simultaneousGesture(
                                LongPressGesture(minimumDuration: 0.5)
                                    .onEnded { _ in
                                        let generator = UIImpactFeedbackGenerator(style: .medium)
                                        generator.impactOccurred()
                                        // Show info about what this button does
                                        print("Showing button info: Jump to Random Position")
                                    }
                            )

                            // Button 3: Performer Jump - Play a different scene with the same performer
                            Button {
                                print("üë§ Performer random scene button tapped")
                                handlePerformerRandomVideo()
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.purple.opacity(0.8))
                                        .frame(width: 60, height: 60)
                                        .shadow(color: .black, radius: 4)

                                    // Icon - using a simpler icon and making it larger and more visible
                                    Image(systemName: "person.fill.and.arrow.left.and.arrow.right")
                                        .font(.system(size: 24, weight: .bold))
                                        .foregroundColor(.white)

                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 60, height: 60)
                                }
                            }
                            .simultaneousGesture(
                                LongPressGesture(minimumDuration: 0.5)
                                    .onEnded { _ in
                                        let generator = UIImpactFeedbackGenerator(style: .medium)
                                        generator.impactOccurred()
                                        // Show info about what this button does
                                        print("Showing button info: Play Different Scene with Same Performer")
                                    }
                            )

                            // Seek forward 30 seconds button
                            Button {
                                print("‚è© Seek forward 30 seconds")
                                seekVideo(by: 30)
                            } label: {
                                ZStack {
                                    // Background circle
                                    Circle()
                                        .fill(Color.gray.opacity(0.7))
                                        .frame(width: 50, height: 50)
                                        .shadow(color: .black, radius: 4)

                                    // Icon
                                    Image(systemName: "goforward.30")
                                        .font(.system(size: 20, weight: .bold))
                                        .foregroundColor(.white)

                                    // Outer border
                                    Circle()
                                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 50, height: 50)
                                }
                            }
                        }
                        .padding(.bottom, 30)
                        .padding(.trailing, 20)
                    }
                    .transition(.opacity)
                    .animation(.easeInOut(duration: 0.3), value: showControls)
                }
            }
            .navigationBarHidden(true) // Hide the navigation bar completely
            .statusBarHidden(true)     // Hide the status bar for full immersion
            .onAppear {
                print("üì± VideoPlayerView appeared")
                appModel.currentScene = scene

                // Get direct startTime parameter value as priority
                if let startTime = startTime {
                    print("üì± Using provided startTime parameter: \(startTime)")
                    effectiveStartTime = startTime
                }

                // Set the original performer when the view first appears
                // This will be the consistent performer for the performer button
                if let firstPerformer = scene.performers.first {
                    print("üì± Setting original performer to: \(firstPerformer.name) (ID: \(firstPerformer.id))")
                    originalPerformer = firstPerformer
                }

                // Show controls initially, then hide after delay
                showControls = true
                Task {
                    await scheduleControlsHide()
                }
            }
            .onDisappear {
                print("üì± VideoPlayerView disappeared")
                appModel.currentScene = nil
                // Cancel any pending hide task when view disappears
                hideControlsTask?.cancel()
            }
        }
    }
    
    // Function to hide controls after a delay
    private func scheduleControlsHide() async {
        // Cancel any existing hide task
        hideControlsTask?.cancel()

        // Create a new task to hide controls after delay
        hideControlsTask = Task {
            do {
                // Wait 5 seconds before hiding controls
                try await Task.sleep(nanoseconds: 5_000_000_000)

                // Check if task was cancelled
                if !Task.isCancelled {
                    // Add a small delay for animation
                    try await Task.sleep(nanoseconds: UInt64(0.3 * 1_000_000_000))

                    // Check again if task was cancelled
                    if !Task.isCancelled {
                        // Update UI on main thread
                        await MainActor.run {
                            withAnimation(.easeInOut(duration: 0.3)) {
                                showControls = false
                            }
                        }
                    }
                }
            } catch {
                // Task was cancelled, do nothing
            }
        }
    }
    
    private func handlePureRandomVideo() {
        withAnimation(.easeOut(duration: 0.2)) {
            showControls = false
        }
        
        playPureRandomVideo()
    }
    
    private func handlePerformerRandomVideo() {
        withAnimation(.easeOut(duration: 0.2)) {
            showControls = false
        }
        
        playPerformerRandomVideo()
    }
    
    private func handleRandomVideo() {
        withAnimation(.easeOut(duration: 0.2)) {
            showControls = false
        }
        
        playNextScene()
    }
}

// MARK: - Video Controls
extension VideoPlayerView {
    /// Seeks the video forward or backward by the specified number of seconds
    private func seekVideo(by seconds: Double) {
        // Get the current player
        guard let player = getCurrentPlayer() else {
            print("‚ö†Ô∏è Cannot seek - player not found")
            return
        }

        print("‚è± Seeking video by \(seconds) seconds")

        // Get current time
        guard let currentItem = player.currentItem else {
            print("‚ö†Ô∏è Cannot seek - no current item")
            return
        }

        let currentTime = currentItem.currentTime()
        let targetTime = CMTimeAdd(currentTime, CMTime(seconds: seconds, preferredTimescale: 1000))

        // Make sure we don't seek past beginning or end
        let duration = currentItem.duration
        let zeroTime = CMTime.zero

        // Only apply limits if we have valid duration
        if duration.isValid && !duration.seconds.isNaN {
            if targetTime.seconds < 0 {
                // Don't seek before beginning
                player.seek(to: zeroTime, toleranceBefore: .zero, toleranceAfter: .zero)
                print("‚è± Seeking to beginning of video")
                return
            } else if targetTime.seconds > duration.seconds {
                // Don't seek past end
                player.seek(to: duration, toleranceBefore: .zero, toleranceAfter: .zero)
                print("‚è± Seeking to end of video")
                return
            }
        }

        // Perform the normal seek
        print("‚è± Seeking to \(targetTime.seconds) seconds")
        player.seek(to: targetTime, toleranceBefore: .zero, toleranceAfter: .zero) { success in
            if success {
                print("‚úÖ Successfully seeked by \(seconds) seconds")

                // Provide haptic feedback
                let generator = UIImpactFeedbackGenerator(style: .light)
                generator.impactOccurred()

                // Make sure playback continues
                if player.timeControlStatus != .playing {
                    player.play()
                }
            } else {
                print("‚ùå Seek operation failed")
            }
        }
    }

    /// Plays a random scene from the media library directly in the current player
    private func playPureRandomVideo() {
        Task {
            print("üîÑ Starting random video selection")
            // Show loading state if needed

            // Fetch a random scene using the API's random sort
            await appModel.api.fetchScenes(page: 1, sort: "random", direction: "DESC")

            // The API now filters out VR tags automatically, but let's double-check
            let filteredScenes = appModel.api.scenes.filter { scene in
                // Check if any of the scene's tags has the name "vr"
                !scene.tags.contains { tag in
                    tag.name.lowercased() == "vr"
                }
            }

            print("üîÑ Additional VR scene check: \(appModel.api.scenes.count - filteredScenes.count) VR scenes would be removed")

            if let randomScene = filteredScenes.randomElement() {
                print("‚úÖ Selected random scene: \(randomScene.title ?? "Untitled")")

                // Update the current scene reference
                await MainActor.run {
                    print("üîÑ Updating current scene reference")
                    currentScene = randomScene
                    appModel.currentScene = randomScene

                    // When shuffling to a new scene, update the original performer
                    if let newPerformer = randomScene.performers.first {
                        print("üîÑ Updating original performer to: \(newPerformer.name) (ID: \(newPerformer.id))")
                        originalPerformer = newPerformer
                    } else {
                        print("‚ö†Ô∏è No performers in new scene, clearing original performer")
                        originalPerformer = nil
                    }
                }

                // Get the player from the current view controller
                if let player = getCurrentPlayer() {
                    print("‚úÖ Got player reference, preparing to play new content")

                    // Create a new player item for the random scene using HLS streaming
                    let directURL = URL(string: randomScene.paths.stream)!
                    let hlsURL = VideoPlayerUtility.getHLSStreamURL(from: directURL) ?? directURL
                    print("üîÑ Created HLS URL for random scene: \(hlsURL.absoluteString)")
                    let playerItem = AVPlayerItem(url: hlsURL)

                    print("üîÑ Creating new player item with URL: \(hlsURL.absoluteString)")

                    // Replace the current item in the player
                    player.replaceCurrentItem(with: playerItem)
                    player.play()

                    print("‚ñ∂Ô∏è Started playing random scene: \(randomScene.title ?? "Untitled")")

                    // Add observer for playback progress
                    let interval = CMTime(seconds: 5, preferredTimescale: 1)
                    player.addPeriodicTimeObserver(forInterval: interval, queue: .main) { time in
                        let seconds = CMTimeGetSeconds(time)
                        if seconds > 0 {
                            UserDefaults.standard.setVideoProgress(seconds, for: randomScene.id)
                        }
                    }

                    // Reset the controls visibility
                    await MainActor.run {
                        showControls = true
                        Task {
                            await scheduleControlsHide()
                        }
                    }
                } else {
                    print("‚ö†Ô∏è Failed to get player reference")
                }
            } else {
                print("‚ö†Ô∏è No scenes available to play")
            }
        }
    }
    
    /// Plays a different scene featuring the same performer from current scene
    private func playPerformerRandomVideo() {
        print("üéØ PERFORMER BUTTON: Starting performer random video function")

        print("üéØ PERFORMER BUTTON: Current scene: \(currentScene.title ?? "Untitled") (ID: \(currentScene.id))")
        if let originalPerf = originalPerformer {
            print("üéØ PERFORMER BUTTON: Original performer is: \(originalPerf.name) (ID: \(originalPerf.id))")
        } else {
            print("üéØ PERFORMER BUTTON: Original performer is nil")
        }

        // Use the stored original performer instead of the current scene's performers
        guard let selectedPerformer = originalPerformer else {
            print("‚ö†Ô∏è PERFORMER BUTTON: No original performer stored, falling back to shuffle")
            playPureRandomVideo()
            return
        }

        print("üéØ PERFORMER BUTTON: Selected first performer: \(selectedPerformer.name) (ID: \(selectedPerformer.id))")
        print("üéØ PERFORMER BUTTON: Current scene ID: \(currentScene.id), title: \(currentScene.title ?? "Untitled")")

        // Start a task to find and play another scene with this performer
        Task {
            print("üéØ PERFORMER BUTTON: Fetching scenes with performer ID: \(selectedPerformer.id)")

            // Use direct API method to find scenes with this performer
            let query = """
            {
                "operationName": "FindScenes",
                "variables": {
                    "filter": {
                        "page": 1,
                        "per_page": 100,
                        "sort": "date",
                        "direction": "DESC"
                    },
                    "scene_filter": {
                        "performers": {
                            "value": ["\(selectedPerformer.id)"],
                            "modifier": "INCLUDES"
                        }
                    }
                },
                "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender scene_count } tags { id name } rating100 } } }"
            }
            """

            do {
                print("üéØ PERFORMER BUTTON: Executing GraphQL query for performer scenes")
                let data = try await appModel.api.executeGraphQLQuery(query)

                struct FindScenesResponse: Decodable {
                    struct Data: Decodable {
                        struct FindScenes: Decodable {
                            let count: Int
                            let scenes: [StashScene]
                        }
                        let findScenes: FindScenes
                    }
                    let data: Data
                }

                let response = try JSONDecoder().decode(FindScenesResponse.self, from: data)
                let performerScenes = response.data.findScenes.scenes

                print("üéØ PERFORMER BUTTON: Found \(performerScenes.count) scenes with performer \(selectedPerformer.name)")

                // Filter out the current scene and VR scenes (API should already filter VR, but double-check)
                let otherScenes = performerScenes.filter { scene in
                    // Filter out the current scene
                    if scene.id == currentScene.id {
                        return false
                    }

                    // Double-check for VR tag filtering
                    if scene.tags.contains(where: { $0.name.lowercased() == "vr" }) {
                        print("‚ö†Ô∏è PERFORMER BUTTON: Found VR scene despite filtering: \(scene.id)")
                        return false
                    }

                    return true
                }

                print("üéØ PERFORMER BUTTON: Current scene and VR filtering: \(performerScenes.count - otherScenes.count) scenes excluded")
                print("üéØ PERFORMER BUTTON: After filtering current scene, found \(otherScenes.count) other scenes")

                // Get a random scene from this performer's scenes
                if let randomScene = otherScenes.randomElement() ?? (performerScenes.count > 0 ? performerScenes[0] : nil) {
                    print("üéØ PERFORMER BUTTON: Selected scene: \(randomScene.title ?? "Untitled") (ID: \(randomScene.id))")

                    // Update the current scene reference
                    await MainActor.run {
                        print("üéØ PERFORMER BUTTON: Updating current scene reference")
                        currentScene = randomScene
                        appModel.currentScene = randomScene
                    }

                    // Get the player from the current view controller
                    if let player = getCurrentPlayer() {
                        print("üéØ PERFORMER BUTTON: Got player reference, preparing to play new content")

                        // Create a new player item for the random scene using HLS streaming
                        let directURL = URL(string: randomScene.paths.stream)!
                        let hlsURL = VideoPlayerUtility.getHLSStreamURL(from: directURL) ?? directURL
                        print("üéØ PERFORMER BUTTON: Created HLS URL: \(hlsURL.absoluteString)")
                        let playerItem = AVPlayerItem(url: hlsURL)

                        print("üéØ PERFORMER BUTTON: Creating new player item with URL: \(hlsURL.absoluteString)")

                        // Replace the current item in the player
                        player.replaceCurrentItem(with: playerItem)
                        player.play()

                        print("üéØ PERFORMER BUTTON: Started playing random scene with performer: \(selectedPerformer.name)")

                        // Generate a random position to seek to (between 20% and 80% of video)
                        // Use a longer delay to make sure the video loads properly
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                            print("üéØ PERFORMER BUTTON: First delayed seek timer fired")

                            guard let player = getCurrentPlayer(),
                                  let currentItem = player.currentItem else {
                                print("‚ö†Ô∏è PERFORMER BUTTON: Player or item is nil in delayed seek")
                                return
                            }

                            print("üéØ PERFORMER BUTTON: Current item status: \(currentItem.status.rawValue)")

                            // Helper function to handle the actual seek
                            func attemptSeek(with player: AVPlayer, item: AVPlayerItem, isRetry: Bool = false) {
                                // Use VideoPlayerUtility to handle the seek with full fallback logic
                                // This will work even if the player isn't fully loaded
                                let success = VideoPlayerUtility.jumpToRandomPosition(in: player)
                                if success {
                                    print("‚úÖ PERFORMER BUTTON: Successfully jumped to random position using utility")
                                } else if !isRetry {
                                    print("‚ö†Ô∏è PERFORMER BUTTON: Failed to jump, will retry in 2 seconds")

                                    // Last resort retry
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                        guard let player = getCurrentPlayer(),
                                              let currentItem = player.currentItem else { return }

                                        print("üéØ PERFORMER BUTTON: Final retry for seeking")
                                        attemptSeek(with: player, item: currentItem, isRetry: true)
                                    }
                                }
                            }

                            // If the player is ready, use its duration
                            if currentItem.status == .readyToPlay {
                                let duration = currentItem.duration.seconds
                                if !duration.isNaN && duration.isFinite && duration > 0 {
                                    print("üéØ PERFORMER BUTTON: Player ready with duration: \(duration) seconds")
                                    attemptSeek(with: player, item: currentItem)
                                } else {
                                    print("‚ö†Ô∏è PERFORMER BUTTON: Player ready but duration not valid: \(duration), will still attempt seek")
                                    attemptSeek(with: player, item: currentItem)
                                }
                            } else {
                                print("‚ö†Ô∏è PERFORMER BUTTON: Player not ready for seeking, status: \(currentItem.status.rawValue)")
                                print("üéØ PERFORMER BUTTON: Will retry after additional delay")

                                // Try again after a slightly longer delay
                                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                                    print("üéØ PERFORMER BUTTON: Retry delayed seek timer fired")
                                    guard let player = getCurrentPlayer(),
                                          let currentItem = player.currentItem else { return }

                                    print("üéØ PERFORMER BUTTON: Retry - current item status: \(currentItem.status.rawValue)")
                                    attemptSeek(with: player, item: currentItem)
                                }
                            }
                        }

                        // Add observer for playback progress
                        let interval = CMTime(seconds: 5, preferredTimescale: 1)
                        player.addPeriodicTimeObserver(forInterval: interval, queue: .main) { time in
                            let seconds = CMTimeGetSeconds(time)
                            if seconds > 0 {
                                UserDefaults.standard.setVideoProgress(seconds, for: randomScene.id)
                            }
                        }

                        // Provide haptic feedback
                        let generator = UIImpactFeedbackGenerator(style: .medium)
                        generator.impactOccurred()

                        // Reset the controls visibility
                        await MainActor.run {
                            showControls = true
                            Task {
                                await scheduleControlsHide()
                            }
                        }
                    } else {
                        print("‚ö†Ô∏è PERFORMER BUTTON: Failed to get player reference")
                    }
                } else {
                    print("‚ö†Ô∏è PERFORMER BUTTON: No other scenes available with this performer, falling back to shuffle")
                    playPureRandomVideo()
                }
            } catch {
                print("‚ö†Ô∏è PERFORMER BUTTON: Error fetching performer scenes: \(error)")
                print("‚ö†Ô∏è PERFORMER BUTTON: Falling back to regular API method")

                // Fall back to regular API method
                await appModel.api.fetchPerformerScenes(performerId: selectedPerformer.id)

                // Continue with the same flow as before - filter out current scene and VR scenes
                let otherScenes = appModel.api.scenes.filter { scene in
                    // Filter out the current scene
                    if scene.id == currentScene.id {
                        return false
                    }

                    // Double-check for VR tag filtering (API should already filter it)
                    if scene.tags.contains(where: { $0.name.lowercased() == "vr" }) {
                        print("‚ö†Ô∏è PERFORMER BUTTON: Found VR scene despite API filtering: \(scene.id)")
                        return false
                    }

                    return true
                }
                print("üéØ PERFORMER BUTTON: Found \(otherScenes.count) scenes with performer using fallback method")

                if let randomScene = otherScenes.randomElement() ?? appModel.api.scenes.first {
                    // Update scene and play it (same implementation as above)
                    await MainActor.run {
                        currentScene = randomScene
                        appModel.currentScene = randomScene
                    }

                    if let player = getCurrentPlayer() {
                        let directURL = URL(string: randomScene.paths.stream)!
                        let hlsURL = VideoPlayerUtility.getHLSStreamURL(from: directURL) ?? directURL
                        print("üéØ PERFORMER BUTTON (FALLBACK): Created HLS URL: \(hlsURL.absoluteString)")
                        let playerItem = AVPlayerItem(url: hlsURL)
                        player.replaceCurrentItem(with: playerItem)
                        player.play()

                        // Add delayed seek to random position
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                            print("üéØ PERFORMER BUTTON (FALLBACK): Attempting to seek to random position")
                            if let player = getCurrentPlayer() {
                                // Use the improved utility method which handles all edge cases
                                let success = VideoPlayerUtility.jumpToRandomPosition(in: player)
                                if success {
                                    print("‚úÖ PERFORMER BUTTON (FALLBACK): Jumped to random position using utility")
                                } else {
                                    print("‚ö†Ô∏è PERFORMER BUTTON (FALLBACK): Failed initial jump, will retry")

                                    // One more try after a delay
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                                        if let player = getCurrentPlayer() {
                                            VideoPlayerUtility.jumpToRandomPosition(in: player)
                                        }
                                    }
                                }
                            }
                        }

                        // Provide haptic feedback
                        let generator = UIImpactFeedbackGenerator(style: .medium)
                        generator.impactOccurred()

                        // Reset controls visibility
                        Task {
                            await MainActor.run {
                                showControls = true
                                Task {
                                    await scheduleControlsHide()
                                }
                            }
                        }
                    }
                } else {
                    playPureRandomVideo()
                }
            }
        }
    }
    
    /// Jumps to a random position in the current video
    private func playNextScene() {
        // Get the current player
        guard let player = getCurrentPlayer() else {
            print("‚ö†Ô∏è Cannot jump to random position - player not found")
            return
        }

        // Check if we have a valid duration to work with
        guard let currentItem = player.currentItem,
              currentItem.status == .readyToPlay,
              currentItem.duration.isValid,
              !currentItem.duration.seconds.isNaN,
              currentItem.duration.seconds > 0 else {
            print("‚ö†Ô∏è Cannot jump to random position - invalid duration")
            return
        }

        let duration = currentItem.duration.seconds
        print("üé≤ Current video duration: \(duration) seconds")

        // Current time for logging
        let currentSeconds = currentItem.currentTime().seconds
        print("üé≤ Current position: \(currentSeconds) seconds")

        // Calculate a random position between 5 minutes and 90% of the duration
        // Ensure we don't go too close to the beginning or end
        let minPosition = max(300, duration * 0.1) // At least 5 minutes (300 seconds) or 10% in
        let maxPosition = min(duration - 10, duration * 0.9) // At most 90% through the video

        if minPosition >= maxPosition {
            print("‚ö†Ô∏è Video too short for meaningful random jump")
            return
        }

        // Generate random position
        let randomPosition = Double.random(in: minPosition...maxPosition)
        let minutes = Int(randomPosition / 60)
        let seconds = Int(randomPosition) % 60

        print("üé≤ Jumping to random position: \(randomPosition) seconds (\(minutes):\(String(format: "%02d", seconds)))")

        // Create time with higher precision timescale
        let time = CMTime(seconds: randomPosition, preferredTimescale: 1000)

        // Set tolerances for more precise seeking
        let toleranceBefore = CMTime(seconds: 0.5, preferredTimescale: 1000)
        let toleranceAfter = CMTime(seconds: 0.5, preferredTimescale: 1000)

        // Perform the seek operation
        print("üé≤ Seeking to new position...")
        player.seek(to: time, toleranceBefore: toleranceBefore, toleranceAfter: toleranceAfter) { success in
            if success {
                print("‚úÖ Successfully jumped to \(minutes):\(String(format: "%02d", seconds))")

                // Provide haptic feedback
                let generator = UIImpactFeedbackGenerator(style: .medium)
                generator.impactOccurred()

                // Make sure playback continues
                if player.timeControlStatus != .playing {
                    player.play()
                }
            } else {
                print("‚ùå Seek operation failed")
            }
        }
    }
    
    /// Helper method to get the current player
    private func getCurrentPlayer() -> AVPlayer? {
        // First try to get the player from our registry
        if let player = VideoPlayerRegistry.shared.currentPlayer {
            print("‚ñ∂Ô∏è Retrieved player from registry")
            return player
        }

        // Fallback to searching for player in view hierarchy
        if let playerVC = UIApplication.shared.windows.first?.rootViewController?.presentedViewController as? AVPlayerViewController {
            // Register this player for future use
            VideoPlayerRegistry.shared.currentPlayer = playerVC.player
            VideoPlayerRegistry.shared.playerViewController = playerVC
            print("‚ñ∂Ô∏è Retrieved player from presented view controller")
            return playerVC.player
        }

        // Alternative approach if the above doesn't work
        if let playerVC = findPlayerViewController() {
            // Register this player for future use
            VideoPlayerRegistry.shared.currentPlayer = playerVC.player
            VideoPlayerRegistry.shared.playerViewController = playerVC
            print("‚ñ∂Ô∏è Retrieved player using findPlayerViewController")
            return playerVC.player
        }

        print("‚ö†Ô∏è Failed to find player")
        return nil
    }

    /// Helper method to find the AVPlayerViewController in the view hierarchy
    private func findPlayerViewController() -> AVPlayerViewController? {
        // Try to find the player view controller in the parent hierarchy
        var parentController = UIApplication.shared.windows.first?.rootViewController
        while parentController != nil {
            if let playerVC = parentController as? AVPlayerViewController {
                return playerVC
            }
            if let presentedVC = parentController?.presentedViewController as? AVPlayerViewController {
                return presentedVC
            }
            parentController = parentController?.presentedViewController
        }
        return nil
    }
}

struct FullScreenVideoPlayer: UIViewControllerRepresentable {
    typealias UIViewControllerType = AVPlayerViewController

    let url: URL
    let startTime: Double?
    let scenes: [StashScene]
    let currentIndex: Int
    let appModel: AppModel

    // Add coordinator to store persistent reference to player
    class Coordinator: NSObject {
        var player: AVPlayer?
        var observationToken: NSKeyValueObservation?

        deinit {
            // Clean up resources
            observationToken?.invalidate()
            player?.pause()
            player = nil
        }
    }

    func makeCoordinator() -> Coordinator {
        return Coordinator()
    }

    func makeUIViewController(context: Context) -> AVPlayerViewController {
        print("üé¨ Creating video player for URL: \(url.absoluteString)")
        
        // Create player and view controller
        let player = AVPlayer(url: url)
        let playerVC = AVPlayerViewController()
        playerVC.player = player
        
        // Configure player options
        playerVC.allowsPictureInPicturePlayback = true
        playerVC.showsPlaybackControls = true
        
        // Add observer for readyToPlay status
        let token = player.currentItem?.observe(\.status, options: [.new, .old]) { item, change in
            if item.status == .readyToPlay {
                print("üé¨ Player item is ready to play")
                // Inside your AVPlayer setup‚Äîafter status==.readyToPlay but before play():
                if let t = startTime {
                    print("‚è± Player ready, seeking to \(t) seconds")
                    let cmTime = CMTime(seconds: t, preferredTimescale: 600)
                    player.seek(to: cmTime, toleranceBefore: .zero, toleranceAfter: .zero) { success in
                        print("‚úÖ Seek completed with success: \(success)")
                        if player.timeControlStatus != .playing {
                            player.play()
                        }
                    }
                } else {
                    player.play()
                }
            }
        }
        
        // Store token in context for memory management
        context.coordinator.observationToken = token
        
        // Register with VideoPlayerRegistry for consistent access
        VideoPlayerRegistry.shared.currentPlayer = player
        VideoPlayerRegistry.shared.playerViewController = playerVC
        
        // Store reference to the player
        context.coordinator.player = player
        
        return playerVC
    }

    func updateUIViewController(_ uiViewController: AVPlayerViewController, context: Context) {
        // Check if we need to update player reference
        if VideoPlayerRegistry.shared.playerViewController !== uiViewController {
            print("üîÑ Updating registry with current player reference")
            VideoPlayerRegistry.shared.playerViewController = uiViewController
            VideoPlayerRegistry.shared.currentPlayer = uiViewController.player
        }
    }
}

// Add a global singleton to store the current player
class VideoPlayerRegistry {
    static let shared = VideoPlayerRegistry()

    var currentPlayer: AVPlayer?
    var playerViewController: AVPlayerViewController?

    private init() {}
}

================
File: stash/AppDelegate.swift
================
import SwiftUI
import UIKit

class AppDelegate: NSObject, UIApplicationDelegate {
    var appModel: AppModel = AppModel()
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        print("üì± App launched - loading application state")

        // Configure URLSession for better performance
        configureNetworking()

        // Ensure AppModel is properly initialized and authenticates
        initializeAppModel()

        return true
    }

    private func initializeAppModel() {
        print("üì± Initializing AppModel")

        // Ensure app model has valid connection information
        if !appModel.isConnected && !appModel.serverAddress.isEmpty {
            print("üì± Server address is set but not connected, attempting connection")
            Task {
                appModel.attemptConnection()
            }
        } else if appModel.isConnected {
            print("üì± AppModel already connected to \(appModel.serverAddress)")

            // Pre-fetch markers for faster loading
            Task {
                print("üì± Pre-fetching markers data")
                await appModel.api.fetchMarkers(page: 1, appendResults: false)
                print("üì± Pre-fetched \(appModel.api.markers.count) markers")
            }
        } else {
            print("üì± AppModel not connected and no server address set")
        }
    }
    
    private func configureNetworking() {
        // Configure a better URLCache
        let cacheSize = 50 * 1024 * 1024 // 50 MB
        let cache = URLCache(memoryCapacity: cacheSize, diskCapacity: cacheSize * 5, directory: nil)
        URLCache.shared = cache
        
        // Configure default configuration
        let defaultConfig = URLSessionConfiguration.default
        defaultConfig.timeoutIntervalForRequest = 60.0
        defaultConfig.timeoutIntervalForResource = 120.0
        defaultConfig.requestCachePolicy = .useProtocolCachePolicy
        defaultConfig.httpMaximumConnectionsPerHost = 5
        defaultConfig.httpShouldUsePipelining = true
        defaultConfig.tlsMinimumSupportedProtocolVersion = .TLSv12
        defaultConfig.urlCache = cache
        
        // Apply the configuration to shared session connections
        URLSession.shared.configuration.timeoutIntervalForRequest = 60.0
        URLSession.shared.configuration.timeoutIntervalForResource = 120.0
        
        print("üì± Configured URLSession for increased reliability")
    }
}

================
File: stash/ContentView.swift
================
import SwiftUI
import os.log
import Combine

struct ContentView: View {
    @EnvironmentObject var appModel: AppModel
    @State private var isLoadingContent = false
    @State private var showingConnectionRetry = false
    
    var body: some View {
        if appModel.isConnected {
            ZStack {
                NavigationStack(path: $appModel.navigationPath) {
                    TabView(selection: $appModel.activeTab) {
                        // Group the views without extra hierarchical layer
                        MediaLibraryView()
                            .tabItem {
                                Label(AppModel.Tab.scenes.rawValue,
                                      systemImage: AppModel.Tab.scenes.icon)
                            }
                            .tag(AppModel.Tab.scenes)

                        PerformersView()
                            .tabItem {
                                Label(AppModel.Tab.performers.rawValue,
                                      systemImage: AppModel.Tab.performers.icon)
                            }
                            .tag(AppModel.Tab.performers)

                        MarkersView()
                            .tabItem {
                                Label(AppModel.Tab.markers.rawValue,
                                      systemImage: AppModel.Tab.markers.icon)
                            }
                            .tag(AppModel.Tab.markers)
                    }
                    .navigationTitle(appModel.activeTab.rawValue)
                    .navigationBarTitleDisplayMode(.inline)
                    .sheet(isPresented: $appModel.showingFilterOptions) {
                        NavigationStack {
                            FilterMenuSheet()
                                .environmentObject(appModel)
                                .navigationTitle("Filter Options")
                                .navigationBarTitleDisplayMode(.inline)
                        }
                        .presentationDetents([.medium, .large])
                    }
                    .navigationDestination(for: StashScene.self) { scene in
                        VideoPlayerView(scene: scene)
                            .environmentObject(appModel)
                    }
                    .navigationDestination(for: StashScene.Performer.self) { performer in
                        PerformerDetailView(performer: performer)
                            .environmentObject(appModel)
                    }
                    .navigationDestination(for: SceneMarker.self) { marker in
                        VideoPlayerView(scene: StashScene(
                            id: marker.scene.id,
                            title: nil,
                            details: nil,
                            paths: StashScene.ScenePaths(
                                screenshot: marker.screenshot,
                                preview: marker.preview,
                                stream: marker.stream
                            ),
                            files: [],
                            performers: [],
                            tags: [],
                            rating100: nil,
                            o_counter: nil
                        ), startTime: Double(marker.seconds))
                        .environmentObject(appModel)
                    }
                }
                
                // Settings button overlay - hide when in video player
                if appModel.currentScene == nil {
                    VStack {
                        HStack {
                            Spacer()

                            // Filter button (only show for Scenes tab)
                            if appModel.activeTab == .scenes {
                                Button(action: {
                                    appModel.showingFilterOptions = true
                                }) {
                                    Image(systemName: "line.3.horizontal.decrease.circle")
                                        .font(.title2)
                                        .foregroundColor(.white)
                                        .padding(12)
                                        .background(Circle().fill(Color.purple.opacity(0.8)))
                                        .shadow(radius: 3)
                                }
                                .padding(.horizontal, 4)
                            }

                            // Settings button
                            NavigationLink(destination: SettingsView().environmentObject(appModel)) {
                                Image(systemName: "gear")
                                    .font(.title2)
                                    .foregroundColor(.white)
                                    .padding(12)
                                    .background(Circle().fill(Color.blue.opacity(0.8)))
                                    .shadow(radius: 3)
                            }
                            .padding(.horizontal)
                        }
                        Spacer()
                    }
                    .padding(.top, 8)
                }
            }
            .onAppear {
                print("üì± ContentView appeared")
                ensureContentLoaded()
            }
            .onChange(of: appModel.activeTab) { _, newTab in
                print("üì± Tab changed to: \(newTab)")
                ensureContentLoaded()
            }
        } else {
            VStack(spacing: 20) {
                EnhancedConnectionView()
                    .environmentObject(appModel)
                
                // Only show the retry button if we attempted connection but failed
                if false {
                    VStack(spacing: 15) {
                        Text("Connection to server failed")
                            .font(.headline)
                        
                        if case .failed = appModel.api.connectionStatus {
                            Text("Server error")
                                .foregroundColor(.secondary)
                        } else {
                            Text("Check your server and try again")
                                .foregroundColor(.secondary)
                        }
                        
                        Button("Retry Connection") {
                            Task {
                                do {
                                    try await appModel.api.checkServerConnection()
                                } catch {
                                    print("Connection error: \(error)")
                                }
                            }
                        }
                        .buttonStyle(.borderedProminent)
                        .padding(.top, 10)
                    }
                    .padding(.horizontal)
                    .padding(.top, 30)
                }
            }
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppModel())
}

#Preview {
    ContentView()
}

// MARK: - Content Loading Logic
extension ContentView {
    func ensureContentLoaded() {
        guard !isLoadingContent, appModel.isConnected else { return }
        
        isLoadingContent = true
        
        Task {
            do {
                switch appModel.activeTab {
                case .scenes:
                    print("üì± Loading scenes for tab")
                    await appModel.api.fetchScenes(page: 1, sort: "random", direction: "DESC", appendResults: false)
                    
                case .performers:
                    print("üì± Loading performers for tab")
                    appModel.api.fetchPerformers(filter: .twoOrMore, page: 1, appendResults: false, search: "") { result in
                        switch result {
                        case .success(let performers):
                            print("‚úÖ Loaded \(performers.count) performers")
                        case .failure(let error):
                            print("‚ùå Error loading performers: \(error)")
                        }
                    }
                    
                case .markers:
                    print("üì± Loading markers for tab")
                    await appModel.api.fetchMarkers(page: 1, appendResults: false)
                }
            } catch {
                print("‚ùå Error loading content for tab \(appModel.activeTab): \(error)")
            }
            
            await MainActor.run {
                isLoadingContent = false
            }
        }
    }
}

================
File: stash/Models.swift
================
import Foundation

// Move all model structs here (StashScene, SceneMarker, etc.)

================
File: stash/stashApp.swift
================
//
//  stashApp.swift
//  stash
//
//  Created by Charles Krivan on 11/14/24.
//

import SwiftUI
import AVKit
import UIKit
import Foundation

// Import our central types file
@_exported import struct Foundation.URL

@main
struct stashApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @State private var isReady = false
    
    var body: some SwiftUI.Scene {
        WindowGroup {
            SplashScreen()
                .preferredColorScheme(.dark)
                .environmentObject(appDelegate.appModel)
                .onAppear {
                    // Short delay to ensure the AppDelegate has completed its initialization
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        isReady = true
                    }
                }
                .task {
                    // Wait for app to be ready before making network requests
                    while !isReady {
                        try? await Task.sleep(for: .milliseconds(50))
                    }
                }
        }
    }
}

================
File: stash/StashImports.swift
================
import Foundation
import SwiftUI
import Combine
import AVKit
import UIKit

// This file serves as a central location for importing models
// and defining type aliases to avoid compilation errors.

// Re-export all model types for use throughout the app
@_exported import struct Foundation.URL

// Type aliases for commonly used types
typealias Scene = StashScene
typealias Performer = StashScene.Performer
typealias Marker = SceneMarker

================
File: stash/ViewModels.swift
================
import Foundation
import AVKit
import SwiftUI
import Combine

// Move VideoPlayerViewModel and StashAPI here

================
File: stash/Views.swift
================
import SwiftUI
import AVKit

// Move supporting views here (MarkerRow, SceneRow, etc.)

================
File: stash.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

================
File: stash.xcodeproj/xcshareddata/xcschemes/stash.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1640"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "928C09C92CE6641A00C7B4B1"
               BuildableName = "stash.app"
               BlueprintName = "stash"
               ReferencedContainer = "container:stash.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "928C09C92CE6641A00C7B4B1"
            BuildableName = "stash.app"
            BlueprintName = "stash"
            ReferencedContainer = "container:stash.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "928C09C92CE6641A00C7B4B1"
            BuildableName = "stash.app"
            BlueprintName = "stash"
            ReferencedContainer = "container:stash.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: stash.xcodeproj/xcuserdata/charleskrivan.xcuserdatad/xcschemes/xcschememanagement.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>stash.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>928C09C92CE6641A00C7B4B1</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>

================
File: stash.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXFileReference section */
		928C09CA2CE6641A00C7B4B1 /* stash.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = stash.app; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		928C09CC2CE6641A00C7B4B1 /* stash */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = stash;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		928C09C72CE6641A00C7B4B1 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		928C09C12CE6641A00C7B4B1 = {
			isa = PBXGroup;
			children = (
				928C09CC2CE6641A00C7B4B1 /* stash */,
				928C09CB2CE6641A00C7B4B1 /* Products */,
			);
			sourceTree = "<group>";
		};
		928C09CB2CE6641A00C7B4B1 /* Products */ = {
			isa = PBXGroup;
			children = (
				928C09CA2CE6641A00C7B4B1 /* stash.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		928C09C92CE6641A00C7B4B1 /* stash */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 928C09EE2CE6641C00C7B4B1 /* Build configuration list for PBXNativeTarget "stash" */;
			buildPhases = (
				928C09C62CE6641A00C7B4B1 /* Sources */,
				928C09C72CE6641A00C7B4B1 /* Frameworks */,
				928C09C82CE6641A00C7B4B1 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				928C09CC2CE6641A00C7B4B1 /* stash */,
			);
			name = stash;
			packageProductDependencies = (
			);
			productName = stash;
			productReference = 928C09CA2CE6641A00C7B4B1 /* stash.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		928C09C22CE6641A00C7B4B1 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1610;
				LastUpgradeCheck = 1610;
				TargetAttributes = {
					928C09C92CE6641A00C7B4B1 = {
						CreatedOnToolsVersion = 16.1;
					};
				};
			};
			buildConfigurationList = 928C09C52CE6641A00C7B4B1 /* Build configuration list for PBXProject "stash" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 928C09C12CE6641A00C7B4B1;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = 928C09CB2CE6641A00C7B4B1 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				928C09C92CE6641A00C7B4B1 /* stash */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		928C09C82CE6641A00C7B4B1 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		928C09C62CE6641A00C7B4B1 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		928C09EC2CE6641C00C7B4B1 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		928C09ED2CE6641C00C7B4B1 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		928C09EF2CE6641C00C7B4B1 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"stash/Preview Content\"";
				DEVELOPMENT_TEAM = RLHAQ44Q53;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.ck.test.stash;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		928C09F02CE6641C00C7B4B1 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"stash/Preview Content\"";
				DEVELOPMENT_TEAM = RLHAQ44Q53;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.ck.test.stash;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		928C09C52CE6641A00C7B4B1 /* Build configuration list for PBXProject "stash" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				928C09EC2CE6641C00C7B4B1 /* Debug */,
				928C09ED2CE6641C00C7B4B1 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		928C09EE2CE6641C00C7B4B1 /* Build configuration list for PBXNativeTarget "stash" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				928C09EF2CE6641C00C7B4B1 /* Debug */,
				928C09F02CE6641C00C7B4B1 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 928C09C22CE6641A00C7B4B1 /* Project object */;
}

================
File: temp_icons/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "filename" : "AppIcon-1024.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "filename" : "AppIcon-1024-dark.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "filename" : "AppIcon-1024-tinted.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: temp_icons/new_icon.svg
================
<svg width="1024" height="1024" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
  <rect width="1024" height="1024" fill="black"/>
  <path d="M542.47 178.28C429.21 178.28 370.48 265.12 370.48 359.6C370.48 454.09 429.21 540.93 542.47 540.93C607.97 540.93 650.32 509.53 676.96 465.07C679.29 467.24 681.85 469.18 684.59 470.8C705.62 485.74 736.76 481.51 752.85 461.47C768.94 441.42 765.62 411.25 745.66 396.02C750.33 386.42 754.25 376.11 757.33 365.14C753.68 321.81 736.73 281.36 710.29 249.83C683.85 218.3 648.27 196.9 609.16 187.6C587.16 181.05 564.45 178.28 542.47 178.28ZM670.09 423.35C661.92 435.09 653.07 445.22 643.18 453.63C606.83 481.75 564.68 476.69 550.49 476.69C470.35 476.69 437.85 423.94 437.85 359.6C437.85 295.27 470.35 242.52 550.49 242.52C564.68 242.52 606.83 237.46 643.18 265.58C694.38 306.34 699.64 391.34 670.09 423.35Z" fill="#E61410"/>
  <path d="M520.72 171.56C481.41 171.56 444.07 182.33 411.54 202.94C378.37 223.95 343.33 251.76 318.66 286.64C294 321.52 284.78 357.13 284.78 392.75C284.78 471.44 325.72 547.67 400.2 594.64C424.45 610.32 453.21 620.87 483.64 625.27C453.21 629.67 424.45 640.22 400.2 655.9C325.72 702.87 284.78 779.11 284.78 857.79C284.78 893.41 294 929.02 318.66 963.9C343.33 998.78 378.37 1026.59 411.54 1047.6C444.07 1068.21 481.41 1078.98 520.72 1078.98C560.03 1078.98 599.33 1068.21 633.6 1047.6C667.87 1026.99 704.13 998.8 730.92 963.9C757.7 929 769 893.41 769 857.79C769 779.11 726.02 702.87 649.2 655.9C624.95 640.22 596.19 629.67 565.76 625.27C596.19 620.87 624.95 610.32 649.2 594.64C726.02 547.67 769 471.44 769 392.75C769 357.13 757.7 321.52 730.92 286.64C704.13 251.76 667.87 223.56 633.6 202.94C599.33 182.33 560.03 171.56 520.72 171.56ZM653.36 323.58C686.42 370.35 693.25 428.9 674.94 478.85C667.97 497.84 657.09 514.5 643.31 528.06C659.25 538.9 673.64 551.42 685.76 565.67C720.64 606.92 738.7 659.14 738.7 712.19C738.7 765.25 720.64 817.56 685.76 858.71C650.89 899.96 601.52 924.85 551.02 924.85C500.52 924.85 451.15 899.96 416.38 858.71C381.5 817.46 363.44 765.25 363.44 712.19C363.44 659.14 381.5 606.82 416.38 565.67C428.5 551.42 442.9 538.9 458.84 528.06C445.07 514.5 434.18 497.84 427.32 478.85C409.01 428.9 415.84 370.35 448.9 323.58C481.96 276.81 530.48 252.35 580.17 252.35C629.85 252.35 678.38 276.81 711.43 323.58H653.36Z" fill="#E61410"/>
  <path d="M622.56 788.27C622.56 810.24 604.54 828.26 582.57 828.26C560.61 828.26 542.58 810.24 542.58 788.27V741.51H513.25V788.27C513.25 810.24 495.23 828.26 473.26 828.26C451.29 828.26 433.27 810.24 433.27 788.27V736.27C433.27 719.14 447.13 706.18 465.77 706.18H590.06C608.7 706.18 622.56 720.03 622.56 738.67V788.27Z" fill="#E61410"/>
  <path d="M610.59 257.61C582.64 240.18 551.65 242.77 537.61 244.59H530.9C516.86 242.77 485.88 240.18 457.93 257.61C430.33 274.86 409.74 304.98 406.45 346.06C403.16 387.14 421.3 428.22 451.7 444.15C484.33 461.4 512.01 459.15 527.85 454.43C529.78 459.03 532.09 463.5 534.75 467.76C545.83 485.14 562.58 499.97 584.8 509.31C606.8 518.56 633.03 522.11 660.71 517.36C691.11 512.44 716.62 497.97 733.77 481.75C750.93 465.53 760.29 447.14 761.64 435.2C763.83 418.37 778.4 402.74 785.72 385.82C804.62 345.47 794.79 313.79 788.43 300.53C782.07 287.28 771.2 279.78 761.64 278.55C761.64 278.55 761.64 278.55 761.64 279.78C761.64 281 761.64 282.23 760.31 283.46C760.31 284.68 758.99 285.91 758.99 287.14C758.99 288.36 757.67 289.59 757.67 290.82C756.24 293.17 754.57 295.4 752.68 297.46C751.36 298.69 750.04 299.92 748.72 301.14C747.4 302.37 746.08 304.82 744.76 306.05C743.44 307.27 742.12 308.5 740.79 310.95C739.47 313.4 738.15 314.63 736.83 315.86C736.83 317.09 735.51 319.54 735.51 319.54C734.19 320.77 734.19 322 732.87 323.22C731.55 325.68 730.22 327.13 728.9 328.36C728.9 329.59 727.58 330.82 727.58 332.04C726.26 334.5 724.94 335.72 724.94 336.95C723.62 338.18 723.62 339.41 722.3 340.63C720.98 341.86 720.98 344.32 719.65 345.54C718.33 346.77 718.33 348 717.01 349.22C715.69 350.45 715.69 351.68 714.37 352.9C713.05 354.13 713.05 355.36 711.73 357.82C710.41 359.04 710.41 360.27 709.08 361.5C707.76 362.72 707.76 363.95 706.44 365.18C705.12 366.4 705.12 368.86 703.8 368.86C702.48 370.09 702.48 371.31 701.16 372.54C699.84 373.77 699.84 375 698.51 375C698.51 376.22 697.19 377.45 697.19 377.45C695.87 378.68 694.55 379.91 694.55 381.13C693.23 382.36 693.23 382.36 691.91 383.59C691.91 383.59 690.59 384.81 690.59 386.04C689.26 387.27 687.94 387.27 687.94 388.5C686.62 389.72 686.62 389.72 685.3 389.72C683.98 390.95 683.98 392.18 682.65 392.18C682.65 392.18 681.33 393.4 681.33 394.63C680.01 394.63 680.01 395.86 678.69 395.86C677.37 397.09 677.37 397.09 676.04 397.09C674.72 398.31 674.72 398.31 673.4 398.31C672.08 399.54 670.76 399.54 670.76 399.54C669.44 400.77 669.44 400.77 668.11 400.77C666.79 401.99 665.47 401.99 665.47 401.99C664.15 403.22 662.83 403.22 662.83 403.22C661.51 403.22 660.18 404.45 660.18 404.45C658.86 404.45 657.54 405.68 657.54 405.68C656.22 405.68 656.22 406.9 654.9 406.9C653.58 406.9 652.25 408.13 652.25 408.13C650.93 408.13 649.61 409.36 649.61 409.36C648.29 409.36 646.97 409.36 646.97 410.59C645.64 410.59 644.32 410.59 644.32 410.59C643 411.81 641.68 411.81 641.68 411.81C640.36 411.81 639.04 413.04 639.04 413.04C637.71 413.04 636.39 413.04 636.39 413.04C635.07 414.27 633.75 414.27 632.43 414.27C631.1 414.27 629.78 414.27 629.78 414.27C628.46 414.27 627.14 415.5 627.14 415.5C625.82 415.5 624.5 415.5 623.17 415.5C621.85 415.5 620.53 415.5 619.21 415.5C617.89 415.5 616.57 415.5 615.24 415.5C613.92 415.5 612.6 415.5 611.28 415.5C611.28 415.5 608.64 415.5 608.64 415.5C607.32 415.5 605.99 415.5 604.67 415.5C603.35 415.5 602.03 415.5 602.03 415.5C599.39 415.5 598.07 415.5 596.74 415.5C595.42 415.5 594.1 415.5 594.1 414.27C592.78 414.27 591.46 414.27 590.14 414.27C588.81 414.27 587.49 413.04 586.17 413.04C584.85 413.04 583.53 413.04 582.21 411.81C580.88 411.81 579.56 411.81 578.24 410.59C576.92 410.59 575.6 410.59 574.28 409.36C572.95 409.36 572.95 408.13 571.63 408.13C570.31 408.13 568.99 406.9 568.99 406.9C567.67 406.9 566.34 405.68 566.34 405.68C565.02 405.68 563.7 404.45 563.7 404.45C562.38 404.45 561.06 403.22 561.06 403.22C559.73 403.22 558.41 401.99 558.41 401.99C557.09 401.99 555.77 400.77 555.77 400.77C554.45 400.77 553.12 399.54 553.12 399.54C551.8 398.31 550.48 398.31 550.48 398.31C549.16 398.31 547.84 397.09 547.84 397.09C546.51 397.09 545.19 395.86 545.19 395.86C543.87 395.86 543.87 394.63 542.55 394.63C542.55 394.63 541.22 393.4 539.9 392.18C538.58 392.18 538.58 390.95 537.26 389.72C535.94 389.72 535.94 389.72 534.61 387.27C533.29 387.27 533.29 386.04 531.97 384.81C531.97 384.81 530.65 383.59 529.33 382.36C528 381.13 528 379.91 526.68 378.68C525.36 377.45 525.36 376.22 524.04 375C523.51 373.75 522.88 372.56 522.16 371.45C520.41 368.77 518.14 365.18 514.48 363.95C487.33 352.9 478.52 337.68 473.49 318.31C468.69 300.35 469.57 278.41 480.2 262.09C504.36 225.11 547.8 247.83 552.25 250.72C568.63 241.46 586.17 243.91 590.14 244.45L602.03 245.83C616.57 246.64 642.77 252.27 664.78 263.46C688.11 275.04 706.32 293.04 713.11 316.18C720.21 340.39 717.64 351.49 714.37 361.5C713.88 362.95 713.36 364.22 712.83 365.19L714.34 365.18C717.42 365.18 720.14 364.95 722.3 364.5C729.8 363.04 733.77 362.05 752.05 366.15C764.71 368.74 773.85 390.5 750.55 423.76C727.25 457.02 690.58 483.07 655.67 485.34C620.77 487.61 593.74 482.11 578.45 473.9C570.45 469.4 566.34 465.02 566.34 465.02C566.34 465.02 561.06 468.11 550.48 471.45C539.9 474.79 525.36 477.54 510.82 473.9C487.19 468.11 469.72 452.88 457.93 437.66C442.05 417.16 434.58 397.09 436.66 370.09C439.01 325.66 468.33 276.86 534.61 264.09C600.89 251.32 610.53 257.61 610.59 257.61Z" fill="#E61410"/>
</svg>

================
File: .gitignore
================
**/.claude/settings.local.json

================
File: build_error_log.txt
================
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -project stash.xcodeproj -scheme stash -destination "platform=iOS Simulator,name=iPad (10th generation),OS=18.1" build

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:iOS Simulator, arch:arm64, id:4F8D20B6-9418-414A-9058-99A8227B60AC, OS:18.1, name:iPad (10th generation) }
{ platform:iOS Simulator, arch:x86_64, id:4F8D20B6-9418-414A-9058-99A8227B60AC, OS:18.1, name:iPad (10th generation) }
ComputePackagePrebuildTargetDependencyGraph

Prepare packages

CreateBuildRequest

SendProjectDescription

CreateBuildOperation

ComputeTargetDependencyGraph
note: Building targets in dependency order
note: Target dependency graph (1 target)
    Target 'stash' in project 'stash' (no dependencies)

GatherProvisioningInputs

CreateBuildDescription

ExecuteExternalTool /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -v -E -dM -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -x c -c /dev/null

ExecuteExternalTool /Applications/Xcode.app/Contents/Developer/usr/bin/actool --print-asset-tag-combinations --output-format xml1 /Users/charleskrivan/Desktop/stash/stash/Preview Content/Preview Assets.xcassets /Users/charleskrivan/Desktop/stash/stash/Assets.xcassets

ExecuteExternalTool /Applications/Xcode.app/Contents/Developer/usr/bin/actool --version --output-format xml1

ExecuteExternalTool /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc --version

ExecuteExternalTool /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld -version_details

Build description signature: 2f016ed9d07b2646a9529eac4877f2dc
Build description path: /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/XCBuildData/2f016ed9d07b2646a9529eac4877f2dc.xcbuilddata
ClangStatCache /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang-stat-cache /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk /Users/charleskrivan/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphonesimulator18.4-22E235-71825a6d136aa4733edcbe86ece5525b.sdkstatcache
    cd /Users/charleskrivan/Desktop/stash/stash.xcodeproj
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang-stat-cache /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -o /Users/charleskrivan/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphonesimulator18.4-22E235-71825a6d136aa4733edcbe86ece5525b.sdkstatcache

WriteAuxiliaryFile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftFileList (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    write-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftFileList

WriteAuxiliaryFile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftConstValuesFileList (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    write-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftConstValuesFileList

GenerateAssetSymbols /Users/charleskrivan/Desktop/stash/stash/Preview\ Content/Preview\ Assets.xcassets /Users/charleskrivan/Desktop/stash/stash/Assets.xcassets (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    /Applications/Xcode.app/Contents/Developer/usr/bin/actool /Users/charleskrivan/Desktop/stash/stash/Preview\ Content/Preview\ Assets.xcassets /Users/charleskrivan/Desktop/stash/stash/Assets.xcassets --compile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app --output-format human-readable-text --notices --warnings --export-dependency-info /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_dependencies --output-partial-info-plist /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist --app-icon AppIcon --accent-color AccentColor --compress-pngs --enable-on-demand-resources YES --development-region en --target-device iphone --target-device ipad --minimum-deployment-target 18.1 --platform iphonesimulator --bundle-identifier com.ck.test.stash --generate-swift-asset-symbols /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols.swift --generate-objc-asset-symbols /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols.h --generate-asset-symbol-index /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols-Index.plist
/* com.apple.actool.compilation-results */
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols-Index.plist
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols.h
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols.swift


CompileAssetCatalogVariant thinned /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app /Users/charleskrivan/Desktop/stash/stash/Preview\ Content/Preview\ Assets.xcassets /Users/charleskrivan/Desktop/stash/stash/Assets.xcassets (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    /Applications/Xcode.app/Contents/Developer/usr/bin/actool /Users/charleskrivan/Desktop/stash/stash/Preview\ Content/Preview\ Assets.xcassets /Users/charleskrivan/Desktop/stash/stash/Assets.xcassets --compile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_output/thinned --output-format human-readable-text --notices --warnings --export-dependency-info /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_dependencies_thinned --output-partial-info-plist /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist_thinned --app-icon AppIcon --accent-color AccentColor --compress-pngs --enable-on-demand-resources YES --filter-for-thinning-device-configuration iPad13,18 --filter-for-device-os-version 18.1 --development-region en --target-device iphone --target-device ipad --minimum-deployment-target 18.1 --platform iphonesimulator
/* com.apple.actool.compilation-results */
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist_thinned
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_output/thinned/AppIcon60x60@2x.png
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_output/thinned/AppIcon76x76@2x~ipad.png
/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_output/thinned/Assets.car


WriteAuxiliaryFile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.LinkFileList (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    write-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.LinkFileList

SwiftDriver stash normal arm64 com.apple.xcode.tools.swift.compiler (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-SwiftDriver -- /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -module-name stash -Onone -enforce-exclusivity\=checked @/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftFileList -DDEBUG -enable-bare-slash-regex -enable-experimental-feature DebugDescriptionMacro -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -target arm64-apple-ios18.1-simulator -g -module-cache-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -Xfrontend -serialize-debugging-options -enable-testing -index-store-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Index.noindex/DataStore -swift-version 5 -I /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -F /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -emit-localized-strings -emit-localized-strings-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64 -c -j10 -enable-batch-mode -incremental -Xcc -ivfsstatcache -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphonesimulator18.4-22E235-71825a6d136aa4733edcbe86ece5525b.sdkstatcache -output-file-map /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash-OutputFileMap.json -use-frontend-parseable-output -save-temps -no-color-diagnostics -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftmodule -validate-clang-modules-once -clang-build-session-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/swift-overrides.hmap -emit-const-values -Xfrontend -const-gather-protocols-file -Xfrontend /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash_const_extract_protocols.json -Xcc -iquote -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-generated-files.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-own-target-headers.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-all-target-headers.hmap -Xcc -iquote -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-project-headers.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/include -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources-normal/arm64 -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/arm64 -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources -Xcc -DDEBUG\=1 -emit-objc-header -emit-objc-header-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash-Swift.h -working-directory /Users/charleskrivan/Desktop/stash -experimental-emit-module-separately -disable-cmo

SwiftEmitModule normal arm64 Emitting\ module\ for\ stash (in target 'stash' from project 'stash')

EmitSwiftModule normal arm64 (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    
/Users/charleskrivan/Desktop/stash/stash/Networking/StashAPI.swift:830:17: warning: initialization of immutable value 'sortField' was never used; consider replacing with assignment to '_' or removing it
            let sortField = sort == "random" ? "random_\(randomSeed)" : sort
            ~~~~^~~~~~~~~
            _
/Users/charleskrivan/Desktop/stash/stash/Networking/StashAPI.swift:1953:13: warning: immutable value 'sceneCountValue' was never used; consider removing it
        let sceneCountValue: String
            ^
/Users/charleskrivan/Desktop/stash/stash/Networking/StashAPI.swift:1965:13: warning: initialization of immutable value 'sceneCountModifier' was never used; consider replacing with assignment to '_' or removing it
        let sceneCountModifier = filter == .lessThanTwo ? "LESS_THAN" : "GREATER_THAN"
        ~~~~^~~~~~~~~~~~~~~~~~
        _
/Users/charleskrivan/Desktop/stash/stash/Views/Performers/PerformerDetailView.swift:122:32: warning: result of call to 'getMarkerCount()' is unused
                    await self.getMarkerCount()
                               ^             ~~
/Users/charleskrivan/Desktop/stash/stash/Views/Performers/PerformerDetailView.swift:240:31: warning: result of call to 'getMarkerCount()' is unused
                        await getMarkerCount() // Load marker count in background
                              ^             ~~

SwiftCompile normal arm64 Compiling\ GeneratedAssetSymbols.swift /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols.swift (in target 'stash' from project 'stash')

SwiftCompile normal arm64 /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/GeneratedAssetSymbols.swift (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    

SwiftDriverJobDiscovery normal arm64 Compiling GeneratedAssetSymbols.swift (in target 'stash' from project 'stash')

SwiftDriverJobDiscovery normal arm64 Emitting module for stash (in target 'stash' from project 'stash')

SwiftDriver\ Compilation\ Requirements stash normal arm64 com.apple.xcode.tools.swift.compiler (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-Swift-Compilation-Requirements -- /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -module-name stash -Onone -enforce-exclusivity\=checked @/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftFileList -DDEBUG -enable-bare-slash-regex -enable-experimental-feature DebugDescriptionMacro -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -target arm64-apple-ios18.1-simulator -g -module-cache-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -Xfrontend -serialize-debugging-options -enable-testing -index-store-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Index.noindex/DataStore -swift-version 5 -I /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -F /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -emit-localized-strings -emit-localized-strings-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64 -c -j10 -enable-batch-mode -incremental -Xcc -ivfsstatcache -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphonesimulator18.4-22E235-71825a6d136aa4733edcbe86ece5525b.sdkstatcache -output-file-map /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash-OutputFileMap.json -use-frontend-parseable-output -save-temps -no-color-diagnostics -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftmodule -validate-clang-modules-once -clang-build-session-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/swift-overrides.hmap -emit-const-values -Xfrontend -const-gather-protocols-file -Xfrontend /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash_const_extract_protocols.json -Xcc -iquote -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-generated-files.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-own-target-headers.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-all-target-headers.hmap -Xcc -iquote -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-project-headers.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/include -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources-normal/arm64 -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/arm64 -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources -Xcc -DDEBUG\=1 -emit-objc-header -emit-objc-header-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash-Swift.h -working-directory /Users/charleskrivan/Desktop/stash -experimental-emit-module-separately -disable-cmo

SwiftDriver\ Compilation stash normal arm64 com.apple.xcode.tools.swift.compiler (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-Swift-Compilation -- /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -module-name stash -Onone -enforce-exclusivity\=checked @/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftFileList -DDEBUG -enable-bare-slash-regex -enable-experimental-feature DebugDescriptionMacro -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -target arm64-apple-ios18.1-simulator -g -module-cache-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -Xfrontend -serialize-debugging-options -enable-testing -index-store-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Index.noindex/DataStore -swift-version 5 -I /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -F /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -emit-localized-strings -emit-localized-strings-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64 -c -j10 -enable-batch-mode -incremental -Xcc -ivfsstatcache -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphonesimulator18.4-22E235-71825a6d136aa4733edcbe86ece5525b.sdkstatcache -output-file-map /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash-OutputFileMap.json -use-frontend-parseable-output -save-temps -no-color-diagnostics -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftmodule -validate-clang-modules-once -clang-build-session-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/swift-overrides.hmap -emit-const-values -Xfrontend -const-gather-protocols-file -Xfrontend /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash_const_extract_protocols.json -Xcc -iquote -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-generated-files.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-own-target-headers.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-all-target-headers.hmap -Xcc -iquote -Xcc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-project-headers.hmap -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/include -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources-normal/arm64 -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources/arm64 -Xcc -I/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/DerivedSources -Xcc -DDEBUG\=1 -emit-objc-header -emit-objc-header-path /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash-Swift.h -working-directory /Users/charleskrivan/Desktop/stash -experimental-emit-module-separately -disable-cmo

Copy /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/arm64-apple-ios-simulator.swiftdoc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftdoc (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -resolve-src-symlinks -rename /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftdoc /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/arm64-apple-ios-simulator.swiftdoc

Copy /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/Project/arm64-apple-ios-simulator.swiftsourceinfo /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftsourceinfo (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -resolve-src-symlinks -rename /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftsourceinfo /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/Project/arm64-apple-ios-simulator.swiftsourceinfo

Copy /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/arm64-apple-ios-simulator.swiftmodule /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftmodule (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -resolve-src-symlinks -rename /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftmodule /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/arm64-apple-ios-simulator.swiftmodule

Copy /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/arm64-apple-ios-simulator.abi.json /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.abi.json (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -resolve-src-symlinks -rename /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.abi.json /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.swiftmodule/arm64-apple-ios-simulator.abi.json

Ld /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib normal (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -Xlinker -reproducible -target arm64-apple-ios18.1-simulator -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -O0 -L/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/EagerLinkingTBDs/Debug-iphonesimulator -L/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -F/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/EagerLinkingTBDs/Debug-iphonesimulator -F/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -filelist /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.LinkFileList -install_name @rpath/stash.debug.dylib -Xlinker -rpath -Xlinker @executable_path/Frameworks -dead_strip -Xlinker -object_path_lto -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash_lto.o -rdynamic -Xlinker -no_deduplicate -Xlinker -objc_abi_version -Xlinker 2 -Xlinker -dependency_info -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash_dependency_info.dat -fobjc-link-runtime -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator -L/usr/lib/swift -Xlinker -add_ast_path -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.swiftmodule -Xlinker -alias -Xlinker _main -Xlinker ___debug_main_executable_dylib_entry_point -Xlinker -no_adhoc_codesign -o /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib

ConstructStubExecutorLinkFileList /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-ExecutorLinkFileList-normal-arm64.txt (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    construct-stub-executor-link-file-list /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/lib/libPreviewsJITStubExecutor_no_swift_entry_point.a /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/lib/libPreviewsJITStubExecutor.a --output /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-ExecutorLinkFileList-normal-arm64.txt
note: Using stub executor library with Swift entry point. (in target 'stash' from project 'stash')

Ld /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash normal (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -Xlinker -reproducible -target arm64-apple-ios18.1-simulator -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk -O0 -L/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -F/Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator -Xlinker -rpath -Xlinker @executable_path -Xlinker -rpath -Xlinker @executable_path/Frameworks -rdynamic -Xlinker -no_deduplicate -Xlinker -objc_abi_version -Xlinker 2 -e ___debug_blank_executor_main -Xlinker -sectcreate -Xlinker __TEXT -Xlinker __debug_dylib -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-DebugDylibPath-normal-arm64.txt -Xlinker -sectcreate -Xlinker __TEXT -Xlinker __debug_instlnm -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-DebugDylibInstallName-normal-arm64.txt -Xlinker -filelist -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash-ExecutorLinkFileList-normal-arm64.txt -Xlinker -sectcreate -Xlinker __TEXT -Xlinker __entitlements -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash.app-Simulated.xcent -Xlinker -sectcreate -Xlinker __TEXT -Xlinker __ents_der -Xlinker /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash.app-Simulated.xcent.der /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib -Xlinker -no_adhoc_codesign -o /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash

LinkAssetCatalog /Users/charleskrivan/Desktop/stash/stash/Preview\ Content/Preview\ Assets.xcassets /Users/charleskrivan/Desktop/stash/stash/Assets.xcassets (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-linkAssetCatalog --thinned /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_output/thinned --thinned-dependencies /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_dependencies_thinned --thinned-info-plist-content /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist_thinned --unthinned /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_output/unthinned --unthinned-dependencies /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_dependencies_unthinned --unthinned-info-plist-content /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist_unthinned --output /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app --plist-output /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist
note: Emplaced /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/AppIcon76x76@2x~ipad.png (in target 'stash' from project 'stash')
note: Emplaced /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/AppIcon60x60@2x.png (in target 'stash' from project 'stash')
note: Emplaced /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/Assets.car (in target 'stash' from project 'stash')

ProcessInfoPlistFile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/Info.plist /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/empty-stash.plist (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-infoPlistUtility /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/empty-stash.plist -producttype com.apple.product-type.application -genpkginfo /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/PkgInfo -expandbuildsettings -format binary -platform iphonesimulator -additionalcontentfile /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/assetcatalog_generated_info.plist -o /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/Info.plist

CopySwiftLibs /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-swiftStdLibTool --copy --verbose --sign - --scan-executable /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib --scan-folder /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/Frameworks --scan-folder /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/PlugIns --scan-folder /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/SystemExtensions --scan-folder /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/Extensions --platform iphonesimulator --toolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain --destination /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/Frameworks --strip-bitcode --strip-bitcode-tool /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/bitcode_strip --emit-dependency-info /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/SwiftStdLibToolInputDependencies.dep --filter-for-swift-os

ExtractAppIntentsMetadata (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/appintentsmetadataprocessor --toolchain-dir /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain --module-name stash --sdk-root /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator18.4.sdk --xcode-version 16E140 --platform-family iOS --deployment-target 18.1 --bundle-identifier com.ck.test.stash --output /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app --target-triple arm64-apple-ios18.1-simulator --binary-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash --dependency-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash_dependency_info.dat --stringsdata-file /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/ExtractedAppShortcutsMetadata.stringsdata --source-file-list /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftFileList --metadata-file-list /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash.DependencyMetadataFileList --static-metadata-file-list /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/stash.DependencyStaticMetadataFileList --swift-const-vals-list /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Intermediates.noindex/stash.build/Debug-iphonesimulator/stash.build/Objects-normal/arm64/stash.SwiftConstValuesFileList --compile-time-extraction --deployment-aware-processing --validate-assistant-intents --no-app-shortcuts-localization
2025-05-12 15:36:52.556 appintentsmetadataprocessor[58425:20975808] Starting appintentsmetadataprocessor export
2025-05-12 15:36:52.557 appintentsmetadataprocessor[58425:20975808] warning: Metadata extraction skipped. No AppIntents.framework dependency found.

CodeSign /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    
    Signing Identity:     "Sign to Run Locally"
    
    /usr/bin/codesign --force --sign - --timestamp\=none --generate-entitlement-der /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app/stash.debug.dylib

CodeSign /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    
    Signing Identity:     "Sign to Run Locally"
    
    /usr/bin/codesign --force --sign - --timestamp\=none --generate-entitlement-der /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app

Validate /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app (in target 'stash' from project 'stash')
    cd /Users/charleskrivan/Desktop/stash
    builtin-validationUtility /Users/charleskrivan/Library/Developer/Xcode/DerivedData/stash-euwkblhctvojokcckqrltedyvpyt/Build/Products/Debug-iphonesimulator/stash.app -infoplist-subpath Info.plist

** BUILD SUCCEEDED **

================
File: claude.md
================
# Stash App Development Context
* Always read entire files. Otherwise, you don't know what you don't know, and will end up making mistakes, duplicating code that already exists, or misunderstanding the architecture.  
* Commit early and often. When working on large tasks, your task could be broken down into multiple logical milestones. After a certain milestone is completed and confirmed to be ok by the user, you should commit it. If you do not, if something goes wrong in further steps, we would need to end up throwing away all the code, which is expensive and time consuming.  
* Your internal knowledgebase of libraries might not be up to date. When working with any external library, unless you are 100% sure that the library has a super stable interface, you will look up the latest syntax and usage via either Perplexity (first preference) or web search (less preferred, only use if Perplexity is not available)  
* Do not say things like: "x library isn't working so I will skip it". Generally, it isn't working because you are using the incorrect syntax or patterns. This applies doubly when the user has explicitly asked you to use a specific library, if the user wanted to use another library they wouldn't have asked you to use a specific one in the first place.  
* Always run linting after making major changes. Otherwise, you won't know if you've corrupted a file or made syntax errors, or are using the wrong methods, or using methods in the wrong way.   
* Please organise code into separate files wherever appropriate, and follow general coding best practices about variable naming, modularity, function complexity, file sizes, commenting, etc.  
* Code is read more often than it is written, make sure your code is always optimised for readability  
* Unless explicitly asked otherwise, the user never wants you to do a "dummy" implementation of any given task. Never do an implementation where you tell the user: "This is how it *would* look like". Just implement the thing.  
* Whenever you are starting a new task, it is of utmost importance that you have clarity about the task. You should ask the user follow up questions if you do not, rather than making incorrect assumptions.  
* Do not carry out large refactors unless explicitly instructed to do so.  
* When starting on a new task, you should first understand the current architecture, identify the files you will need to modify, and come up with a Plan. In the Plan, you will think through architectural aspects related to the changes you will be making, consider edge cases, and identify the best approach for the given task. Get your Plan approved by the user before writing a single line of code.   
* If you are running into repeated issues with a given task, figure out the root cause instead of throwing random things at the wall and seeing what sticks, or throwing in the towel by saying "I'll just use another library / do a dummy implementation".   
* You are an incredibly talented and experienced polyglot with decades of experience in diverse areas such as software architecture, system design, development, UI & UX, copywriting, and more.  
* When doing UI & UX work, make sure your designs are both aesthetically pleasing, easy to use, and follow UI / UX best practices. You pay attention to interaction patterns, micro-interactions, and are proactive about creating smooth, engaging user interfaces that delight users.   
* When you receive a task that is very large in scope or too vague, you will first try to break it down into smaller subtasks. If that feels difficult or still leaves you with too many open questions, push back to the user and ask them to consider breaking down the task for you, or guide them through that process. This is important because the larger the task, the more likely it is that things go wrong, wasting time and energy for everyone involved.

## Project Overview
Stash is a multiplatform Apple app for managing video content with advanced tagging, searching, and playback features targeting:
- visionOS (Apple Vision Pro)
- iOS (iPhone)
- iPadOS (iPad)

## Architecture & Code Structure
- **MVVM architecture with SwiftUI** across all platforms
- **Centralized AppModel** manages app state on Vision Pro, being migrated to iOS/iPadOS
- **StashAPI GraphQL client** is IDENTICAL across all platforms
- **Feature-based folder organization** (Connection, Content, Markers, Performers, Player)
- **NavigationModel** for path-based navigation on Vision Pro, being migrated to iOS/iPadOS

## StashAPI Implementation - CRITICAL

### StashAPI File Integrity
- The Vision Pro StashAPI file is the DEFINITIVE implementation
- DO NOT add new GraphQL methods to StashAPI for iOS/iPadOS features
- DO NOT modify existing GraphQL queries/mutations in the StashAPI
- ONLY use the existing API methods exactly as they are in the Vision Pro version
- If a feature needs an API call, FIRST check if it already exists in StashAPI from Vision Pro
- If you're considering adding a new API call, STOP and look for an existing one to reuse

### API/Data Layer Implementation
- ALWAYS reference the Vision Pro StashAPI implementation before implementing any feature
- When implementing iOS/iPadOS features, REUSE the EXACT SAME API calls from the Vision Pro app
- DO NOT create new API implementations for iOS/iPadOS - the same GraphQL calls work across all platforms
- All data models are shared between platforms - reuse them without modification
- NEVER duplicate API logic - if a similar function exists, use it instead of creating a new one

### VideoPlayer Overlay Implementation
- The custom video overlay has DIFFERENT BUTTON CONFIGURATIONS across platforms
- Each button in the video overlay has specific functionality that should be preserved
- When adapting the video player for iOS/iPadOS, maintain button functionality while adapting the UI for touch
- The video overlay components in Vision Pro have advanced features that should be ported to iOS/iPadOS
- Use the SAME StashAPI calls for video-related operations (markers, playback tracking, etc.)

### Search & Filter Implementation
- A FULLY WORKING search feature exists with proper GraphQL queries already implemented
- FILTER PRESETS are already configured and working correctly with their GraphQL calls
- DO NOT modify the underlying GraphQL queries for search and filtering - reuse them exactly
- When implementing search/filter UI for iOS/iPadOS, keep the same data flow and query execution
- Look for existing filter preset implementations in the Vision Pro code and port them directly

## Development Workflow

### Build & Compile Checks
- Before submitting any PR, build the project to verify changes:
```bash
xcodebuild -project stash.xcodeproj -scheme stash -destination 'platform=iOS Simulator,name=iPhone 15' build
```
- For more detailed error reporting:
```bash
xcodebuild -project stash.xcodeproj -scheme stash -destination 'platform=iOS Simulator,name=iPhone 15' build 2>&1 | xcbeautify
```
- To clean before building:
```bash
xcodebuild clean -project stash.xcodeproj -scheme stash
```

### API-First Approach
- FIRST identify the StashAPI methods needed for a feature by examining the Vision Pro code
- CONFIRM that all required API calls already exist in StashAPI before implementing UI
- DOCUMENT which existing StashAPI methods you're using for each feature
- REPORT if you believe a new API call is needed (this should be rare and requires verification)

### Error Handling
- Check Xcode logs PROACTIVELY to identify and fix errors without asking me to share them
- Use the AppModel.api approach consistently instead of creating separate API instances
- Ensure EnvironmentObject propagation through the view hierarchy
- Features that work in the Vision Pro app should use identical API calls in iOS/iPadOS with UI adaptations

### Common Issues to Avoid
- Adding new methods to StashAPI when existing ones should be reused
- Missing EnvironmentObject propagation (.environmentObject(appModel) must be added to sheets and navigations)
- Direct API instances (@ObservedObject var api: StashAPI) vs. using appModel.api
- NavigationPath type issues (ensure Hashable conformance)
- Inconsistent initializers between platforms
- Reimplementing search/filter GraphQL queries that already exist
- Using incorrect closure syntax with executeGraphQLQuery (always use named parameters)
- Forgetting to specify generic types in executeGraphQLQuery calls

### Callback vs Async/Await Patterns
- StashAPI supports both callback-based and async/await patterns
- For newer code, prefer using async/await patterns where applicable
- When using executeGraphQLQuery with callbacks, always use named parameters:
  ```swift
  // CORRECT:
  executeGraphQLQuery<ResponseType>(query: myQuery, variables: myVars, completion: { result in
      // Handle result
  })

  // INCORRECT - will cause compilation errors:
  executeGraphQLQuery<ResponseType>(myQuery) { result in
      // Handle result
  }
  ```
- Always specify the generic type parameter when calling executeGraphQLQuery
- For methods with both patterns, use the appropriate one based on your context

## Implementation Examples

### Proper StashAPI Usage
```swift
// ALWAYS examine what's already in StashAPI first
// This is the API file that should NOT be modified with new methods

class StashAPI: ObservableObject {
    // Existing methods from Vision Pro implementation
    func fetchScenes(filter: SceneFilter?, completion: @escaping (Result<[StashScene], Error>) -> Void) {
        // Implementation
    }
    
    func fetchPerformer(id: String, completion: @escaping (Result<Performer, Error>) -> Void) {
        // Implementation
    }
    
    // Many other methods...
}

// CORRECT APPROACH - When implementing a feature, check StashAPI first
// Then use the existing method without modification
func loadSceneData() {
    let filter = SceneFilter(tags: selectedTags)
    appModel.api.fetchScenes(filter: filter) { result in
        // Handle result
    }
}

// INCORRECT APPROACH - DO NOT DO THIS
// Don't add a new method to StashAPI for a slightly different use case
func loadFilteredScenes() {
    // WRONG: Don't add a new method like this to StashAPI
    appModel.api.fetchScenesWithTags(tags: selectedTags) { result in
        // Handle result
    }
    
    // CORRECT: Use the existing method with appropriate parameters
    let filter = SceneFilter(tags: selectedTags)
    appModel.api.fetchScenes(filter: filter) { result in
        // Handle result
    }
}
```

## Recent Bug Fixes

### 1. Performer Markers Issue
Problem: The performer-specific marker list never fired because it checked for an optional selectedPerformer that wasn't properly initialized.

Solution:
- Refactored PerformerMarkersView to accept a direct performer parameter in its initializer
- Modified the task lifecycle to load performer markers immediately when provided 
- Added connection from PerformerDetailView's tab to PerformerMarkersView with proper performer passed in
- Fixed INCLUDES_ALL modifier in GraphQL query for more accurate marker filtering

### 2. Marker Timestamp Seeking Issue
Problem: When tapping a marker, the video player didn't seek to the marker's timestamp.

Solution:
- Created robust VideoPlayerUtility.seekToTime method for consistent seeking
- Changed VideoPlayerView to use UserDefaults for storing/retrieving start times
- Removed condition that prevented seeking to timestamp 0
- Enhanced error handling and recovery for seeking operations
- Added extensive logging to trace timestamp flow

#### Implementation Changes
1. Marker loading now works by either:
   - Direct initialization: `PerformerMarkersView(performer: performer)`
   - Selection from list: clicking performer in PerformerMarkersView list

2. Video seeking uses a new method that handles retries:
```swift
static func seekToTime(player: AVPlayer, time: Double) -> Bool {
    print("‚è± Seeking to time: \(time) seconds")
    
    let cmTime = CMTime(seconds: time, preferredTimescale: 1000)
    
    player.seek(to: cmTime, toleranceBefore: .zero, toleranceAfter: .zero) { success in
        if success {
            print("‚úÖ Successfully sought to \(time) seconds")
            if player.timeControlStatus != .playing {
                player.play()
            }
        } else {
            // Fallback handling for failed seeks
            player.seek(to: cmTime)
        }
    }
    
    return true
}
```

================
File: fetchMarkers.txt
================
func fetchMarkers(page: Int = 1, appendResults: Bool = false, performerId: String? = nil) async {
        isLoading = true
        
        // Generate a random seed for consistent random sorting
        let randomSeed = Int.random(in: 0...999999)
        
        let graphQLQuery = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 100,
                    "sort": "random_\(randomSeed)",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    \(performerId != nil ? "\"performers\": {\"value\": [\"\(performerId!)\"], \"modifier\": \"INCLUDES_ALL\"}" : "")
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { ...SceneMarkerData __typename } __typename } } fragment SceneMarkerData on SceneMarker { id title seconds end_seconds stream preview screenshot scene { ...SceneMarkerSceneData __typename } primary_tag { id name __typename } tags { id name __typename } __typename } fragment SceneMarkerSceneData on Scene { id title files { width height path __typename } performers { id name image_path __typename } __typename }"
        }
        """
        
        print("üîç Fetching markers (page \(page)) from \(serverAddress)")
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for markers")
            isLoading = false
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("u=3, i", forHTTPHeaderField: "Priority")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.setValue("\(serverAddress)/scenes/markers", forHTTPHeaderField: "Referer")
        request.httpBody = graphQLQuery.data(using: .utf8)
        
        // Add API Key header which wasn't in the original but might be needed according to documentation
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            // Debug: Print the response data
            if let jsonString = String(data: data, encoding: .utf8)?.prefix(500) {
                print("üîç Response data preview: \(jsonString)...")
            }
            
            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)
            
            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let newMarkers = response.data.findSceneMarkers.scene_markers.filter { newMarker in
                        !self.markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: newMarkers)
                    print("‚úÖ Added \(newMarkers.count) new markers")
                    
                    // Debug log for first marker
                    if let firstMarker = self.markers.first {
                        print("üìä First marker details:")
                        print("  ID: \(firstMarker.id)")
                        print("  Title: \(firstMarker.title)")
                        print("  Scene ID: \(firstMarker.scene.id)")
                    }
                } else {
                    self.markers = response.data.findSceneMarkers.scene_markers
                    print("‚úÖ Set \(response.data.findSceneMarkers.scene_markers.count) markers")
                    
                    // Debug log for first marker
                    if let firstMarker = self.markers.first {
                        print("üìä First marker details:")
                        print("  ID: \(firstMarker.id)")
                        print("  Title: \(firstMarker.title)")
                        print("  Scene ID: \(firstMarker.scene.id)")
                    }
                }
                
                self.isLoading = false
            }
        } catch {
            print("‚ùå Error loading markers: \(error)")
            self.error = error
            isLoading = false
        }
    }

================
File: new_contents.txt
================
// BEGIN NEW FETCHMARKERS
import Foundation
import SwiftUI
import Combine

enum PerformerFilter {
    case all
    case lessThanTwo
    case twoOrMore
    case tenOrMore
}

struct ScenesResponseData: Decodable {
    let findScenes: FindScenesResult

    struct FindScenesResult: Decodable {
        let scenes: [StashScene]
        let count: Int
    }
}

struct GraphQLResponse<T: Decodable>: Decodable {
    let data: T
    let errors: [GraphQLError]?
}

struct GraphQLError: Decodable, Identifiable, CustomStringConvertible {
    let message: String
    let path: [String]?
    let extensions: [String: String]?

    // For Identifiable conformance
    var id: String { message }

    // For easier debugging
    var description: String {
        if let path = path {
            return "GraphQL Error: \(message) (path: \(path.joined(separator: ".")))"
        }
        return "GraphQL Error: \(message)"
    }

    // Custom coding keys for flexible decoding
    enum CodingKeys: String, CodingKey {
        case message
        case path
        case extensions
    }

    // Custom init to handle optional fields
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        message = try container.decode(String.self, forKey: .message)
        path = try container.decodeIfPresent([String].self, forKey: .path)
        extensions = try container.decodeIfPresent([String: String].self, forKey: .extensions)
    }
}

struct PerformersResponse: Decodable {
    let findPerformers: FindPerformersResult

    struct FindPerformersResult: Decodable {
        let count: Int
        let performers: [StashScene.Performer]
    }
}

struct ScenesResponse: Decodable {
    let data: ScenesData

    struct ScenesData: Decodable {
        let findScenes: FindScenesResult

        struct FindScenesResult: Decodable {
            let count: Int
            let scenes: [StashScene]
        }
    }
}

struct SceneResponse: Decodable {
    let findScene: StashScene
}

struct SystemStatus: Decodable {
    let databaseSchema: Int?
    let databasePath: String?
    let configPath: String?
    let appSchema: Int?
    let status: String?
    let appName: String?
    let appVersion: String?
    let logFile: String?
    let maxSessionAge: Int?
}

struct TagSearchResponse: Decodable {
    let data: TagData

    struct TagData: Decodable {
        let findTags: TagResults

        struct TagResults: Decodable {
            let count: Int
            let tags: [StashScene.Tag]
        }
    }
}

/// Stats data response from the Stash API
struct StatsDataResponse: Decodable {
    let stats: StashStats
}

class StashAPI: ObservableObject {
    // MARK: - Published Properties
    @Published var scenes: [StashScene] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var performers: [StashScene.Performer] = []
    @Published var markers: [SceneMarker] = []
    @Published var totalSceneCount: Int = 0
    @Published var totalPerformerCount: Int = 0
    @Published var connectionStatus: ConnectionStatus = .unknown
    @Published var sceneID: String?
    @Published var isAuthenticated = false
    @Published var isConnected = false
    @Published var systemStatus: SystemStatus?
    @Published var serverAddressPublic = ""
    @Published var preview: Bool = false
    
    // Add the StashAPI singleton reference
    static var shared: StashAPI? {
        get {
            return StashAPIManager.shared.api
        }
    }

    // MARK: - Properties
    let serverAddress: String
    private var currentTask: Task<Void, Never>?
    private var cancellables = Set<AnyCancellable>()

    // API Authentication
    private let apiKey: String
    
    // Public getter for apiKey to be used by VideoPlayerUtility
    var apiKeyForURLs: String {
        return apiKey
    }

    let decoder = JSONDecoder()
    let encoder = JSONEncoder()

    // MARK: - Connection Status
    enum ConnectionStatus: Equatable {
        case connected
        case disconnected
        case authenticationFailed
        case unknown
        case failed(Error)

        static func == (lhs: ConnectionStatus, rhs: ConnectionStatus) -> Bool {
            switch (lhs, rhs) {
            case (.connected, .connected),
                 (.disconnected, .disconnected),
                 (.authenticationFailed, .authenticationFailed),
                 (.unknown, .unknown):
                return true
            case (.failed(let lhsError), .failed(let rhsError)):
                return lhsError.localizedDescription == rhsError.localizedDescription
            default:
                return false
            }
        }
    }

    // MARK: - Initialization
    init(serverAddress: String, apiKey: String) {
        self.serverAddress = serverAddress
        self.apiKey = apiKey
        print("üîÑ StashAPI initializing with server: \(serverAddress)")
        print("üîë Using API key: \(apiKey.prefix(10))...")

        self.decoder.keyDecodingStrategy = .convertFromSnakeCase

        // Check if we have an API key
        if !apiKey.isEmpty {
            self.isAuthenticated = true
        }

        // Configure session
        URLSession.shared.configuration.timeoutIntervalForRequest = 30.0
        URLSession.shared.configuration.timeoutIntervalForResource = 60.0

        // Trigger a connection check asynchronously
        Task {
            try? await checkAndUpdateConnectionStatus()
        }
    }

    // Check server connection and update the connectionStatus property
    private func checkAndUpdateConnectionStatus() async {
        print("üîÑ Checking connection status...")
        do {
            // Try to connect to the server
            try await checkServerConnection()
            await MainActor.run {
                self.connectionStatus = .connected
                self.isConnected = true
                self.error = nil
                print("‚úÖ Connection successful")
            }
        } catch let error as StashAPIError {
            await MainActor.run {
                switch error {
                case .authenticationFailed:
                    print("üîí Authentication failed - check API key")
                    self.connectionStatus = .authenticationFailed
                case .connectionFailed(let reason):
                    print("‚ùå Connection failed: \(reason)")
                    self.connectionStatus = .disconnected
                case .invalidURL:
                    print("‚ùå Invalid server URL configured")
                    self.connectionStatus = .failed(error)
                default:
                    print("‚ùå Connection error: \(error.localizedDescription)")
                    self.connectionStatus = .failed(error)
                }
                self.error = error
                self.isConnected = false
            }

            // Try to determine if server is reachable without authentication
            do {
                guard let url = URL(string: serverAddress) else {
                    return
                }

                var request = URLRequest(url: url)
                request.timeoutInterval = 5

                let (_, response) = try await URLSession.shared.data(for: request)

                if let httpResponse = response as? HTTPURLResponse {
                    print("üì° Basic server check response: \(httpResponse.statusCode)")

                    await MainActor.run {
                        if (200...299).contains(httpResponse.statusCode) {
                            // Server is reachable but we had auth issues
                            if self.connectionStatus != .authenticationFailed {
                                self.connectionStatus = .authenticationFailed
                            }
                        } else if (500...599).contains(httpResponse.statusCode) {
                            self.connectionStatus = .failed(StashAPIError.serverError(httpResponse.statusCode))
                        }
                    }
                }
            } catch {
                print("‚ùå Server completely unreachable: \(error.localizedDescription)")
                await MainActor.run {
                    self.connectionStatus = .disconnected
                }
            }
        } catch {
            print("‚ùå Unexpected error during connection check: \(error.localizedDescription)")
            await MainActor.run {
                self.connectionStatus = .failed(error)
                self.error = error
                self.isConnected = false
            }
        }
    }

    // Helper method to retry connection
    func retryConnection() async {
        print("üîÑ Retrying connection...")
        await checkAndUpdateConnectionStatus()
    }

    // Helper to get a user-friendly connection status message
    var connectionStatusMessage: String {
        switch connectionStatus {
        case .connected:
            return "Connected to server"
        case .disconnected:
            return "Unable to connect to server"
        case .authenticationFailed:
            return "Authentication failed - check API key"
        case .unknown:
            return "Checking connection..."
        case .failed(let error):
            if let stashError = error as? StashAPIError {
                return stashError.localizedDescription
            } else {
                return "Connection failed: \(error.localizedDescription)"
            }
        }
    }
    
    // MARK: - Authentication Methods
    private func configureRequestWithAuth(_ request: inout URLRequest, referer: String? = nil) {
        // Updated to use BOTH authentication methods
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        // IMPORTANT: Using BOTH auth methods for maximum compatibility
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        if let referer = referer {
            request.setValue(referer, forHTTPHeaderField: "Referer")
        }
        request.timeoutInterval = 30.0
    }

    // MARK: - Modern Async/Await GraphQL Methods

    /// Public method to execute GraphQL queries directly with async/await
    func executeGraphQLQueryAsync(_ query: String) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = query.data(using: .utf8)

        let (data, response) = try await URLSession.shared.data(for: request)

        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
            throw StashAPIError.serverError(httpResponse.statusCode)
        }

        return data
    }

    /// Performs a GraphQL request using async/await
    private func performGraphQLRequest<T: Decodable>(query: String, variables: [String: Any]? = nil) async throws -> T {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        // Create the request body
        var requestBody: [String: Any] = [
            "query": query
        ]
        if let variables = variables {
            requestBody["variables"] = variables
        }

        // Convert request body to JSON data
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        // Create and configure the request with both authentication methods
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = jsonData

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                print("üì° GraphQL Response Status: \(httpResponse.statusCode)")

                // Show response preview for debugging
                if let responseStr = String(data: data, encoding: .utf8)?.prefix(100) {
                    print("üì• Response preview: \(responseStr)...")
                }

                if httpResponse.statusCode == 401 {
                    throw StashAPIError.authenticationFailed
                }

                if !(200...299).contains(httpResponse.statusCode) {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            print("‚ùå GraphQL Error: \(error)")
            throw error
        }
    }

    // Add a version of performGraphQLRequest that returns raw Data
    private func performGraphQLRequest(query: String, variables: [String: Any]? = nil) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        // Create the request body
        var requestBody: [String: Any] = [
            "query": query
        ]
        if let variables = variables {
            requestBody["variables"] = variables
        }

        // Convert request body to JSON data
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        // Create and configure the request with both auth methods
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = jsonData

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                print("üì° GraphQL Response Status: \(httpResponse.statusCode)")

                // Show response preview for debugging
                if let responseStr = String(data: data, encoding: .utf8)?.prefix(100) {
                    print("üì• Response preview: \(responseStr)...")
                }

                if httpResponse.statusCode == 401 {
                    throw StashAPIError.authenticationFailed
                }

                if !(200...299).contains(httpResponse.statusCode) {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            return data
        } catch {
            print("‚ùå GraphQL Error: \(error)")
            throw error
        }
    }

    // Public method to execute GraphQL queries directly
    public func executeGraphQLQuery(_ query: String) async throws -> Data {
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.graphQLError("Invalid URL")
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        // IMPORTANT: Using BOTH authentication methods
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = query.data(using: .utf8)

        print("üì§ Executing GraphQL query with BOTH ApiKey and Bearer auth headers")
        let (data, response) = try await URLSession.shared.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("üì• HTTP response: \(httpResponse.statusCode)")

            // Show response preview for debugging
            if let responseStr = String(data: data, encoding: .utf8)?.prefix(100) {
                print("üì• Response preview: \(responseStr)...")
            }

            if !(200...299).contains(httpResponse.statusCode) {
                print("‚ùå Error status: \(httpResponse.statusCode)")
                throw StashAPIError.serverError(httpResponse.statusCode)
            }
        }

        return data
    }
    
    // MARK: - Scenes Methods
    
    /// Fetch a specific scene by its ID
    /// - Parameter id: The scene ID to fetch
    /// - Returns: The scene if found, nil otherwise
    func fetchScene(byID id: String) async throws -> StashScene? {
        let query = """
        query FindScene($id: ID!) {
            findScene(id: $id) {
                id
                title
                details
                url
                date
                rating100
                organized
                o_counter
                paths {
                    screenshot
                    preview
                    stream
                    webp
                    vtt
                    sprite
                    funscript
                    interactive_heatmap
                }
                files {
                    size
                    duration
                    video_codec
                    width
                    height
                }
                performers {
                    id
                    name
                    gender
                    image_path
                }
                tags {
                    id
                    name
                }
                studio {
                    id
                    name
                }
                stash_ids {
                    endpoint
                    stash_id
                }
                created_at
                updated_at
            }
        }
        """
        
        let variables = ["id": id]
        
        do {
            let response: GraphQLResponse<SceneResponse> = try await performGraphQLRequest(query: query, variables: variables)
            if let errors = response.errors, !errors.isEmpty {
                print("‚ùå GraphQL Errors: \(errors)")
                throw StashAPIError.graphQLError(errors.map { $0.message }.joined(separator: ", "))
            }
            return response.data.findScene
        } catch {
            print("‚ùå Error fetching scene: \(error)")
            throw error
        }
    }
    
    /// Get available sprite image URL (for thumbnails in the video scrubber)
    func getSpriteURLForScene(sceneID: String) -> URL? {
        // Use the static helper method to avoid duplicate code
        return VideoPlayerUtility.getSpriteURL(forSceneID: sceneID)
    }
    
    /// Get VTT file URL for a scene (for video chapters/thumbnails)
    func getVTTURLForScene(sceneID: String) -> URL? {
        // Use the static helper method to avoid duplicate code
        return VideoPlayerUtility.getVTTURL(forSceneID: sceneID)
    }
    func fetchScenes(page: Int = 1, sort: String = "file_mod_time", direction: String = "DESC", appendResults: Bool = false, filterOptions: FilterOptions? = nil) async {
        do {
            // Generate random seed for random sorting
            let randomSeed = Int.random(in: 0...999999)
            let sortField = sort == "random" ? "random_\(randomSeed)" : sort
            
            // Prepare variables
            var queryVars: [String: Any] = [
                "filter": [
                    "page": page,
                    "per_page": 100,
                    "sort": sortField,
                    "direction": direction
                ]
            ]
            
            // Create scene filter
            var sceneFilter: [String: Any] = [:]

            // Refine the approach to tag exclusion - the error suggests there's an issue with the tag filtering
            // Instead of doing tag filtering here, we'll do it in memory after fetching the scenes
            // This is a workaround for the SQL error we're seeing with the EXCLUDES modifier

            // Add additional filters if provided
            if let filterOptions = filterOptions {
                let additionalFilters = filterOptions.generateSceneFilter()
                for (key, value) in additionalFilters {
                    // Don't overwrite the tags filter with INCLUDES modifier
                    if key != "tags" {
                        sceneFilter[key] = value
                    } else if let tagsFilter = value as? [String: Any],
                              let modifier = tagsFilter["modifier"] as? String,
                              modifier == "EXCLUDES" {
                        // If it's also an EXCLUDES filter, merge the values
                        if var existingTagsFilter = sceneFilter["tags"] as? [String: Any],
                           let existingValues = existingTagsFilter["value"] as? [String],
                           let newValues = tagsFilter["value"] as? [String] {
                            var combinedValues = existingValues
                            for newValue in newValues {
                                if !combinedValues.contains(newValue) {
                                    combinedValues.append(newValue)
                                }
                            }
                            existingTagsFilter["value"] = combinedValues
                            sceneFilter["tags"] = existingTagsFilter
                        }
                    }
                }
            }

            // Add scene filter to query variables
            if !sceneFilter.isEmpty {
                queryVars["scene_filter"] = sceneFilter
            }
            
            // Prepare GraphQL query
            let graphQLRequest: [String: Any] = [
                "operationName": "FindScenes",
                "variables": queryVars,
                "query": """
                query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) {
                    findScenes(filter: $filter, scene_filter: $scene_filter) {
                        count
                        scenes {
                            id
                            title
                            details
                            url
                            date
                            rating100
                            organized
                            o_counter
                            paths {
                                screenshot
                                preview
                                stream
                                webp
                                vtt
                                sprite
                                funscript
                                interactive_heatmap
                            }
                            files {
                                size
                                duration
                                video_codec
                                width
                                height
                            }
                            performers {
                                id
                                name
                                gender
                                image_path
                                scene_count
                            }
                            tags {
                                id
                                name
                            }
                            studio {
                                id
                                name
                            }
                            stash_ids {
                                endpoint
                                stash_id
                            }
                            created_at
                            updated_at
                        }
                    }
                }
                """
            ]
            
            // Convert to JSON data
            let jsonData = try JSONSerialization.data(withJSONObject: graphQLRequest)
            
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            configureRequestWithAuth(&request)
            request.httpBody = jsonData

            print("üì§ Fetching scenes page \(page) (sort: \(sort), direction: \(direction))")
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            // Check for task cancellation
            if Task.isCancelled {
                print("‚ö†Ô∏è Scene fetch task was cancelled")
                throw StashAPIError.taskCancelled
            }
            
            // Log HTTP response code for debugging
            if let httpResponse = response as? HTTPURLResponse {
                print("üì• HTTP response: \(httpResponse.statusCode)")
                
                // Check for server errors
                if httpResponse.statusCode >= 400 {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }
            
            // Debug output for investigating the issue
            print("üì• Response data length: \(data.count) bytes")
            if let jsonStr = String(data: data, encoding: .utf8) {
                print("üì• First 500 characters of response: \(jsonStr.prefix(500))")
            }

            // Try to decode first as ScenesResponse (direct wrapper)
            do {
                let decoder = JSONDecoder()
                let scenesResponse = try decoder.decode(ScenesResponse.self, from: data)

                // Update our data on the main thread
                await MainActor.run {
                    // Update total count
                    self.totalSceneCount = scenesResponse.data.findScenes.count

                    // Update scenes array
                    if appendResults {
                        // Filter out duplicates before appending
                        let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                            !self.scenes.contains { $0.id == newScene.id }
                        }
                        self.scenes.append(contentsOf: newScenes)
                        print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                    } else {
                        // Filter out VR scenes in memory
                        let allScenes = scenesResponse.data.findScenes.scenes
                        self.scenes = allScenes.filter { scene in
                            // Filter out scenes with VR tag
                            !scene.tags.contains { tag in
                                tag.name.lowercased() == "vr"
                            }
                        }
                        print("‚úÖ Loaded \(self.scenes.count) scenes (filtered from \(allScenes.count) total)")
                    }

                    // Update loading state
                    self.isLoading = false
                    self.error = nil
                }
            } catch let error as DecodingError {
                // If ScenesResponse direct decoding fails, try with GraphQLResponse wrapper
                print("üì¶ Direct decoding failed, trying with GraphQLResponse wrapper: \(error.localizedDescription)")

                // Try to decode with GraphQLResponse wrapper
                let scenesResponse = try JSONDecoder().decode(GraphQLResponse<ScenesResponseData>.self, from: data)

                // Check for GraphQL errors
                if let errors = scenesResponse.errors, !errors.isEmpty {
                    let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                    throw StashAPIError.graphQLError(errorMessages)
                }

                // Update our data on the main thread
                await MainActor.run {
                    // Update total count
                    self.totalSceneCount = scenesResponse.data.findScenes.count

                    // Update scenes array
                    if appendResults {
                        // Filter out duplicates before appending
                        let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                            !self.scenes.contains { $0.id == newScene.id }
                        }
                        self.scenes.append(contentsOf: newScenes)
                        print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                    } else {
                        // Filter out VR scenes in memory
                        let allScenes = scenesResponse.data.findScenes.scenes
                        self.scenes = allScenes.filter { scene in
                            // Filter out scenes with VR tag
                            !scene.tags.contains { tag in
                                tag.name.lowercased() == "vr"
                            }
                        }
                        print("‚úÖ Loaded \(self.scenes.count) scenes (filtered from \(allScenes.count) total)")
                    }
                    // Update loading state and error
                    self.isLoading = false
                    self.error = nil
                }
            }
        } catch {
            // Only update UI state if task wasn't cancelled
            if !Task.isCancelled {
                // Detailed error logging to help diagnose issues
                print("‚ùå Error fetching scenes: \(error.localizedDescription)")

                if let decodingError = error as? DecodingError {
                    switch decodingError {
                    case .keyNotFound(let key, let context):
                        print("‚ùå JSON key not found: \(key.stringValue), context: \(context.debugDescription)")
                    case .typeMismatch(let type, let context):
                        print("‚ùå JSON type mismatch: expected \(type), context: \(context.debugDescription)")
                    case .valueNotFound(let type, let context):
                        print("‚ùå JSON value not found: \(type), context: \(context.debugDescription)")
                    case .dataCorrupted(let context):
                        print("‚ùå JSON data corrupted: \(context.debugDescription)")
                    @unknown default:
                        print("‚ùå Unknown JSON decoding error")
                    }
                }

                await MainActor.run {
                    self.error = error
                    self.isLoading = false

                    // Try to recover by loading with a fallback method
                    Task {
                        // Try a direct GraphQL query without the complex response structure
                        print("üîÑ Attempting fallback scene loading...")
                        await tryFallbackSceneLoading(page: page, sort: sort, direction: direction)
                    }
                }
            }
        }
    }

    // MARK: - Fallback Scene Loading

    /// Fallback method for loading scenes when the standard fetching fails
    private func tryFallbackSceneLoading(page: Int, sort: String, direction: String) async {
        do {
            // Simpler query structure using GraphQL query
            let randomSeed = Int.random(in: 0...999999)
            let sortField = sort == "random" ? "random_\(randomSeed)" : sort

            // Create a simpler query with minimal fields to test the API
            // Also include tags for VR filtering
            let query = """
            {
                "query": "{ findScenes(filter: {page: \(page), per_page: 40, sort: \\"date\\", direction: \\"DESC\\"}) { count scenes { id title paths { screenshot stream } tags { id name } } } }"
            }
            """

            let data = try await performGraphQLRequest(query: query)

            struct SimpleScenesResponse: Decodable {
                struct Data: Decodable {
                    struct FindScenes: Decodable {
                        let count: Int
                        let scenes: [SimpleScene]

                        struct SimpleScene: Decodable {
                            let id: String
                            let title: String?
                            let paths: ScenePaths
                            let tags: [SimpleTag]

                            struct SimpleTag: Decodable {
                                let id: String
                                let name: String
                            }

                            struct ScenePaths: Decodable {
                                let screenshot: String
                                let stream: String
                            }
                        }
                    }
                    let findScenes: FindScenes
                }
                let data: Data
            }

            // Try to decode the simpler response
            if let jsonStr = String(data: data, encoding: .utf8) {
                print("üîç Fallback response: \(jsonStr.prefix(200))...")
            }

            let simpleResponse = try JSONDecoder().decode(SimpleScenesResponse.self, from: data)

            // If successful, convert simple scenes to full scenes with minimal data
            // Also filter out VR content
            let allSimpleScenes = simpleResponse.data.findScenes.scenes

            let filteredSimpleScenes = allSimpleScenes.filter { scene in
                // Filter out scenes with VR tag
                !scene.tags.contains { tag in
                    tag.name.lowercased() == "vr"
                }
            }

            print("üîç Fallback filtered out \(allSimpleScenes.count - filteredSimpleScenes.count) VR scenes")

            let simpleScenes = filteredSimpleScenes.map { simpleScene -> StashScene in
                // Convert the simplified paths to the format used by StashScene
                let scenePaths = StashScene.ScenePaths(
                    screenshot: simpleScene.paths.screenshot,
                    preview: nil,
                    stream: simpleScene.paths.stream
                )

                // Create a new StashScene with the limited data we have
                return StashScene(
                    id: simpleScene.id,
                    title: simpleScene.title,
                    details: nil,
                    paths: scenePaths,
                    files: [],
                    performers: [],
                    tags: simpleScene.tags.map { StashScene.Tag(id: $0.id, name: $0.name) },
                    rating100: nil,
                    o_counter: nil
                )
            }

            // Update UI with the simple scenes
            await MainActor.run {
                self.scenes = simpleScenes
                self.totalSceneCount = simpleResponse.data.findScenes.count
                print("‚úÖ Loaded \(simpleScenes.count) scenes using fallback method")
                self.isLoading = false
                self.error = nil
            }
        } catch {
            print("‚ùå Fallback loading also failed: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Execute GraphQL Query Methods

    // Add the missing executeGraphQLQuery method with generic type and completion handler
    func executeGraphQLQuery<T: Decodable>(_ query: String, variables: [String: Any]? = nil, completion: @escaping (Result<T, Error>) -> Void) {
        Task {
            do {
                let response: T = try await performGraphQLRequest(query: query, variables: variables)
                DispatchQueue.main.async {
                    completion(.success(response))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }

    // Add overload that takes named parameters for better clarity
    func executeGraphQLQuery<T: Decodable>(query: String, variables: [String: Any]? = nil, completion: @escaping (Result<T, Error>) -> Void) {
        Task {
            do {
                let response: T = try await performGraphQLRequest(query: query, variables: variables)
                DispatchQueue.main.async {
                    completion(.success(response))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }
    
    // MARK: - Performer Scenes Method
    func fetchPerformerScenes(performerId: String, page: Int = 1, perPage: Int = 100, sort: String = "date", direction: String = "DESC", appendResults: Bool = false) async {
        isLoading = true

        // Using proper JSON format like Vision Pro implementation
        let query = """
        {
            "operationName": "FindScenes",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": \(perPage),
                    "sort": "\(sort)",
                    "direction": "\(direction)"
                },
                "scene_filter": {
                    "performers": {
                        "modifier": "INCLUDES",
                        "value": ["\(performerId)"]
                    },
                    "tags": {
                        "modifier": "EXCLUDES",
                        "value": ["vr"]
                    }
                }
            },
            "query": "query FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details paths { screenshot preview stream } files { size duration video_codec width height } performers { id name gender image_path scene_count } tags { id name } studio { id name } rating100 stash_ids { endpoint stash_id } created_at updated_at } } }"
        }
        """

        print("üîç Fetching performer scenes (ID: \(performerId), page: \(page), sort: \(sort), direction: \(direction))")

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for performer scenes")
            isLoading = false
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("\(serverAddress)/performers/\(performerId)/scenes?sortby=date", forHTTPHeaderField: "Referer")
        request.httpBody = query.data(using: .utf8)

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            // Check for task cancellation
            if Task.isCancelled {
                print("‚ö†Ô∏è Performer scenes fetch task was cancelled")
                throw StashAPIError.taskCancelled
            }

            // Log HTTP response code for debugging
            if let httpResponse = response as? HTTPURLResponse {
                print("üì• HTTP response: \(httpResponse.statusCode)")

                // Show response preview for troubleshooting
                if let jsonStr = String(data: data, encoding: .utf8) {
                    print("üì• Response preview: \(jsonStr.prefix(200))...")
                }

                // Check for server errors
                if httpResponse.statusCode >= 400 {
                    throw StashAPIError.serverError(httpResponse.statusCode)
                }
            }

            // Define response structure matching exactly the API format
            struct SceneResponse: Decodable {
                struct Data: Decodable {
                    let findScenes: FindScenesResult

                    struct FindScenesResult: Decodable {
                        let count: Int
                        let scenes: [StashScene]
                    }
                }
                let data: Data
                let errors: [GraphQLError]?
            }

            // Decode the response
            let scenesResponse = try JSONDecoder().decode(SceneResponse.self, from: data)

            // Check for GraphQL errors
            if let errors = scenesResponse.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            // Update our data on the main thread
            await MainActor.run {
                // Update total count
                self.totalSceneCount = scenesResponse.data.findScenes.count

                // Update scenes array
                if appendResults {
                    // Filter out duplicates before appending
                    let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                        !self.scenes.contains { $0.id == newScene.id }
                    }
                    self.scenes.append(contentsOf: newScenes)
                    print("‚úÖ Added \(newScenes.count) new performer scenes (total: \(self.scenes.count))")
                } else {
                    // Filter out VR scenes in memory
                    let allScenes = scenesResponse.data.findScenes.scenes
                    self.scenes = allScenes.filter { scene in
                        // Filter out scenes with VR tag
                        !scene.tags.contains { tag in
                            tag.name.lowercased() == "vr"
                        }
                    }
                    print("‚úÖ Loaded \(self.scenes.count) performer scenes (filtered from \(allScenes.count) total)")

                    // Update loading state
                    self.isLoading = false
                    self.error = nil
                }
            }
        } catch {
            // Only update UI state if task wasn't cancelled
            if !Task.isCancelled {
                await MainActor.run {
                    print("‚ùå Error fetching performer scenes: \(error.localizedDescription)")
                    // Try to get more detailed error info
                    if let decodingError = error as? DecodingError {
                        switch decodingError {
                        case .keyNotFound(let key, let context):
                            print("Missing key: \(key) - \(context.debugDescription)")
                        case .typeMismatch(let type, let context):
                            print("Type mismatch: \(type) - \(context.debugDescription)")
                        case .valueNotFound(let type, let context):
                            print("Value not found: \(type) - \(context.debugDescription)")
                        case .dataCorrupted(let context):
                            print("Data corrupted: \(context.debugDescription)")
                        @unknown default:
                            print("Unknown decoding error")
                        }
                    }
                    self.error = error
                    self.isLoading = false
                }
            }
        }
    }

    // MARK: - System Methods

    // Method to get system status with completion handler
    func getSystemStatus(completion: @escaping (Result<SystemStatus, Error>) -> Void) {
        let query = """
        query SystemStatus {
          systemStatus {
            databaseSchema
            databasePath
            configPath
            appSchema
            status
            appName
            appVersion
            logFile
            maxSessionAge
          }
        }
        """

        struct SystemStatusResponse: Decodable {
            let systemStatus: SystemStatus
        }

        // Added named parameter to fix trailing closure issue
        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<SystemStatusResponse, Error>) in
            switch result {
            case .success(let response):
                self.systemStatus = response.systemStatus
                self.isConnected = true
                completion(.success(response.systemStatus))
            case .failure(let error):
                self.isConnected = false
                completion(.failure(error))
            }
        })
    }

    /// Checks if the Stash server is reachable and if the API key is valid
    func checkServerConnection() async throws {
        print("üîÑ Checking server connection to \(serverAddress)")

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid server URL")
            throw StashAPIError.invalidURL
        }

        // Create a simple query to check server status
        let query = """
        {
            "operationName": "FindPerformers",
            "variables": {
                "filter": {
                    "page": 1,
                    "per_page": 1,
                    "sort": "name",
                    "direction": "ASC"
                }
            },
            "query": "query FindPerformers($filter: FindFilterType) { findPerformers(filter: $filter) { count performers { id name } } }"
        }
        """

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Add both authentication methods to ensure compatibility
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        request.httpBody = query.data(using: .utf8)

        do {
            print("üì§ Sending connection check request...")
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ùå Invalid response type")
                throw StashAPIError.invalidResponse
            }

            print("üì° Server responded with status code: \(httpResponse.statusCode)")

            switch httpResponse.statusCode {
            case 200:
                guard !data.isEmpty else {
                    print("‚ùå Empty response data")
                    throw StashAPIError.emptyResponse
                }

                // Try to decode the response
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("üì• Response: \(jsonString.prefix(200))...")
                }

                do {
                    let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]

                    // Check if we got a data field
                    guard let dataField = json?["data"] as? [String: Any] else {
                        print("‚ùå Response missing data field")
                        throw StashAPIError.invalidData("Response missing data field")
                    }

                    // Check if we have performers data
                    guard let findPerformers = dataField["findPerformers"] as? [String: Any] else {
                        print("‚ùå Response missing performers data")
                        throw StashAPIError.invalidData("Response missing performers data")
                    }

                    print("‚úÖ Server connection successful")
                    print("üìä Performers data: \(findPerformers)")

                } catch {
                    print("‚ùå Failed to parse response: \(error)")
                    throw StashAPIError.decodingError(error)
                }

            case 401, 403:
                print("üîí Authentication failed")
                throw StashAPIError.authenticationFailed

            case 404:
                print("‚ùå Server endpoint not found")
                throw StashAPIError.connectionFailed("Server endpoint not found")

            case 500...599:
                print("‚ùå Server error: \(httpResponse.statusCode)")
                throw StashAPIError.serverError(httpResponse.statusCode)

            default:
                print("‚ùå Unexpected status code: \(httpResponse.statusCode)")
                throw StashAPIError.invalidResponse
            }

        } catch let error as StashAPIError {
            print("‚ùå StashAPI Error: \(error.localizedDescription)")
            throw error
        } catch {
            print("‚ùå Network Error: \(error.localizedDescription)")
            throw StashAPIError.networkError(error)
        }
    }

    /// Fetches statistics from Stash server
    func fetchStats() async throws -> StashStats {
        do {
            let query = """
            query {
              stats {
                scene_count
                scenes_size
                scene_duration
                image_count
                images_size
                gallery_count
                performer_count
                studio_count
                movie_count
                tag_count
              }
            }
            """

            let response: GraphQLResponse<StatsDataResponse> = try await performGraphQLRequest(query: query)

            // Check for errors in the response
            if let errors = response.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            DispatchQueue.main.async {
                self.connectionStatus = .connected
            }

            return response.data.stats
        } catch {
            DispatchQueue.main.async {
                self.connectionStatus = .failed(error)
            }

            NSLog("Error fetching stats: \(error)")
            throw error
        }
    }

    // MARK: - Random Scene/Performer Methods

    func fetchRandomScene(completion: @escaping (Result<StashScene, Error>) -> Void) {
        let query = """
        query FindRandomScene {
          findRandomScene {
            id
            title
            details
            url
            date
            rating100
            o_counter
            organized
            interactive
            files {
              id
              path
              size
              duration
              video_codec
              audio_codec
              width
              height
              frame_rate
              bit_rate
            }
            paths {
              screenshot
              preview
              stream
              webp
              vtt
              chapters_vtt
              sprite
              funscript
            }
            scene_markers {
              id
              scene {
                id
              }
              title
              seconds
              primary_tag {
                id
                name
              }
              tags {
                id
                name
              }
              stream
              preview
              screenshot
            }
            galleries {
              id
              title
              files {
                path
              }
              folder {
                path
              }
            }
            studio {
              id
              name
              image_path
            }
            movies {
              movie {
                id
                name
                front_image_path
              }
              scene_index
            }
            tags {
              id
              name
            }
            performers {
              id
              name
              gender
              favorite
              image_path
            }
            stash_ids {
              endpoint
              stash_id
            }
          }
        }
        """

        struct SceneResponse: Decodable {
            let findRandomScene: StashScene
        }

        // Added named parameter to fix trailing closure issue
        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<SceneResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findRandomScene))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    func fetchRandomPerformer(completion: @escaping (Result<StashScene.Performer, Error>) -> Void) {
        let query = """
        query FindRandomPerformer {
          findRandomPerformer {
            id
            name
            gender
            url
            twitter
            instagram
            birthdate
            death_date
            ethnicity
            country
            eye_color
            height_cm
            measurements
            fake_tits
            penis_length
            circumcised
            hair_color
            weight
            created_at
            updated_at
            favorite
            ignore_auto_tag
            image_path
            scene_count
            image_count
            gallery_count
            movie_count
            tags {
              id
              name
            }
            stash_ids {
              stash_id
              endpoint
            }
            rating100
            details
            aliases
          }
        }
        """

        struct PerformerResponse: Decodable {
            let findRandomPerformer: StashScene.Performer
        }

        // Added named parameter to fix trailing closure issue
        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<PerformerResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findRandomPerformer))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // MARK: - Tag Methods
    
    /// Fetch all tags from the server
    /// - Returns: Array of tags
    func fetchTags() async throws -> [StashScene.Tag] {
        isLoading = true
        defer { isLoading = false }
        
        let graphQLQuery = """
        {
            "operationName": "FindTags",
            "variables": {
                "filter": {
                    "per_page": 1000,
                    "sort": "name",
                    "direction": "ASC"
                }
            },
            "query": "query FindTags($filter: FindFilterType) { findTags(filter: $filter) { count tags { id name scene_count } } }"
        }
        """
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.httpBody = graphQLQuery.data(using: .utf8)
        
        let (data, _) = try await URLSession.shared.data(for: request)
        
        struct TagsResponse: Decodable {
            let data: TagData
            
            struct TagData: Decodable {
                let findTags: TagResults
                
                struct TagResults: Decodable {
                    let count: Int
                    let tags: [StashScene.Tag]
                }
            }
        }
        
        let response = try JSONDecoder().decode(TagsResponse.self, from: data)
        return response.data.findTags.tags
    }
    
    /// Create a new tag
    /// - Parameter name: Tag name
    /// - Returns: The created tag
    func createTag(name: String) async throws -> StashScene.Tag {
        let query = """
        mutation TagCreate($input: TagCreateInput!) {
            tagCreate(input: $input) {
                id
                name
                aliases
                image_path
                scene_count
            }
        }
        """

        let input: [String: Any] = [
            "name": name
        ]

        let variables: [String: Any] = ["input": input]

        struct TagCreateResponse: Decodable {
            let tagCreate: StashScene.Tag
        }

        let response: TagCreateResponse = try await performGraphQLRequest(query: query, variables: variables)
        return response.tagCreate
    }


    func findTags(filter: TagFilter? = nil, completion: @escaping (Result<[StashScene.Tag], Error>) -> Void) {
        let query = """
        query FindTags($filter: TagFilterType) {
          findTags(tag_filter: $filter) {
            count
            tags {
              id
              name
              aliases
              image_path
              scene_count
            }
          }
        }
        """

        var variables: [String: Any] = [:]
        if let filter = filter {
            variables["filter"] = filter.toDictionary()
        }

        struct TagsResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        executeGraphQLQuery(query: query, variables: variables, completion: { (result: Result<TagsResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findTags.tags))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    /// Fetches a specific tag by its ID
    /// - Parameters:
    ///   - id: The tag ID to fetch
    ///   - completion: Callback with result
    func findTag(id: String, completion: @escaping (Result<StashScene.Tag, Error>) -> Void) {
        let query = """
        query FindTag($id: ID!) {
          findTag(id: $id) {
            id
            name
            aliases
            image_path
            scene_count
          }
        }
        """

        let variables: [String: Any] = ["id": id]

        struct TagResponse: Decodable {
            let findTag: StashScene.Tag
        }

        executeGraphQLQuery(query: query, variables: variables, completion: { (result: Result<TagResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findTag))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // MARK: - Filtering Methods
    
    /// Fetch scenes using a filter preset
    /// - Parameters:
    ///   - preset: The filter preset to use
    ///   - page: Page number (1-based)
    ///   - perPage: Number of results per page
    ///   - appendResults: Whether to append to existing results
    func filterScenesByPreset(preset: FilterPreset, page: Int = 1, perPage: Int = 40, appendResults: Bool = false) async {
        isLoading = true
        
        // Get the GraphQL query for this preset
        let query = preset.getGraphQLQuery(page: page, perPage: perPage)
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for filter preset")
            isLoading = false
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.httpBody = query.data(using: .utf8)
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            let scenesResponse = try JSONDecoder().decode(ScenesResponse.self, from: data)
            
            await MainActor.run {
                totalSceneCount = scenesResponse.data.findScenes.count
                
                if appendResults {
                    // Filter out duplicates before appending
                    let newScenes = scenesResponse.data.findScenes.scenes.filter { newScene in
                        !self.scenes.contains { $0.id == newScene.id }
                    }
                    self.scenes.append(contentsOf: newScenes)
                    print("‚úÖ Added \(newScenes.count) new scenes (total: \(self.scenes.count))")
                } else {
                    // Filter out VR scenes in memory
                    let allScenes = scenesResponse.data.findScenes.scenes
                    self.scenes = allScenes.filter { scene in
                        // Filter out scenes with VR tag
                        !scene.tags.contains { tag in
                            tag.name.lowercased() == "vr"
                        }
                    }
                    print("‚úÖ Loaded \(self.scenes.count) scenes for preset \(preset.rawValue) (filtered from \(allScenes.count) total)")
                }
                
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                print("‚ùå Error loading scenes for preset: \(error)")
                self.error = error
                self.isLoading = false
            }
        }
    }
    
    // Extension to send method for GraphQL queries when using async/await
    func send<T: Decodable>(query: String) async throws -> GraphQLResponse<T> {
        // Use the existing performGraphQLRequest method
        return try await performGraphQLRequest(query: query)
    }

    // MARK: - Scene Tag Methods
    
    /// Delete a scene by its ID (also deletes the file and generated assets)
    /// - Parameter id: The scene ID to delete
    /// - Throws: StashAPIError on failure
    func deleteScene(id: String) async throws -> Bool {
        isLoading = true
        defer { isLoading = false }
        
        // Build GraphQL mutation for ScenesDestroy
        let deleteFile = true
        let deleteGenerated = true
        let variables: [String: Any] = [
            "ids": [id],
            "delete_file": deleteFile,
            "delete_generated": deleteGenerated
        ]
        
        // Construct JSON body
        let payload: [String: Any] = [
            "operationName": "ScenesDestroy",
            "variables": variables,
            "query": "mutation ScenesDestroy($ids: [ID!]!, $delete_file: Boolean, $delete_generated: Boolean) { scenesDestroy(input: {ids: $ids, delete_file: $delete_file, delete_generated: $delete_generated}) }"
        ]
        
        let bodyData = try JSONSerialization.data(withJSONObject: payload, options: [])
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw URLError(.badURL)
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.httpBody = bodyData
        
        let (data, response) = try await URLSession.shared.data(for: request)
        if let http = response as? HTTPURLResponse, !(200...299).contains(http.statusCode) {
            throw StashAPIError.networkError(URLError(.badServerResponse))
        }
        
        // Decode GraphQL response
        struct ScenesDestroyResponse: Decodable {
            struct Data: Decodable {
                let scenesDestroy: Bool
            }
            let data: Data
            let errors: [GraphQLError]?
        }
        
        let resp = try JSONDecoder().decode(ScenesDestroyResponse.self, from: data)
        if let errors = resp.errors, !errors.isEmpty {
            let msgs = errors.map { $0.message }.joined(separator: "\n")
            throw StashAPIError.graphQLError(msgs)
        }
        
        return resp.data.scenesDestroy
    }

    func updateSceneTags(sceneID: String, tagIDs: [String]) async throws -> StashScene {
        let query = """
        mutation UpdateSceneTags($input: SceneUpdateInput!) {
            sceneUpdate(input: $input) {
                id
                title
                details
                url
                date
                rating100
                organized
                o_counter
                paths {
                    screenshot
                    preview
                    stream
                    webp
                    vtt
                    sprite
                    funscript
                    interactive_heatmap
                }
                files {
                    size
                    duration
                    video_codec
                    width
                    height
                }
                performers {
                    id
                    name
                    gender
                    image_path
                    scene_count
                }
                tags {
                    id
                    name
                }
                studio {
                    id
                    name
                }
                stash_ids {
                    endpoint
                    stash_id
                }
                created_at
                updated_at
            }
        }
        """

        let input: [String: Any] = [
            "id": sceneID,
            "tag_ids": tagIDs
        ]

        let variables: [String: Any] = ["input": input]

        struct SceneUpdateResponse: Decodable {
            let sceneUpdate: StashScene
        }

        let response: SceneUpdateResponse = try await performGraphQLRequest(query: query, variables: variables)
        return response.sceneUpdate
    }

    // Async version of searchTags
    func searchTags(query: String) async throws -> [StashScene.Tag] {
        let graphQLQuery = """
        query FindTags($filter: FindFilterType) {
          findTags(filter: $filter) {
            count
            tags {
              id
              name
              scene_count
              image_count
            }
          }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "per_page": 20,
                "sort": "name",
                "direction": "ASC"
            ]
        ]

        struct TagSearchAsyncResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        let response: TagSearchAsyncResponse = try await performGraphQLRequest(query: graphQLQuery, variables: variables)
        return response.findTags.tags
    }

    // MARK: - Additional Missing Methods

    func searchTags(query: String, completion: @escaping (Result<[StashScene.Tag], Error>) -> Void) {
        let graphQLQuery = """
        query FindTags($filter: FindFilterType) {
          findTags(filter: $filter) {
            count
            tags {
              id
              name
              scene_count
              image_count
            }
          }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "per_page": 10,
                "sort": "name",
                "direction": "ASC"
            ]
        ]

        struct TagSearchResponse: Decodable {
            let findTags: TagsData

            struct TagsData: Decodable {
                let count: Int
                let tags: [StashScene.Tag]
            }
        }

        executeGraphQLQuery(query: graphQLQuery, variables: variables, completion: { (result: Result<TagSearchResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findTags.tags))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // MARK: - DLNA Configuration
    
    /// Update DLNA settings in Stash
    /// - Parameter enabled: Whether DLNA should be enabled
    /// - Returns: The new state of DLNA (enabled/disabled)
    func updateDLNASettings(enabled: Bool) async throws -> Bool {
        let query = """
        mutation {
          configureDLNA(input: {
            enabled: \(enabled)
          }) {
            enabled
          }
        }
        """
        
        struct DLNAUpdateResponse: Decodable {
            struct Data: Decodable {
                struct ConfigureDLNA: Decodable {
                    let enabled: Bool
                }
                let configureDLNA: ConfigureDLNA
            }
            let data: Data
        }
        
        do {
            let data = try await performGraphQLRequest(query: query)
            let decoder = JSONDecoder()
            let response = try decoder.decode(DLNAUpdateResponse.self, from: data)
            return response.data.configureDLNA.enabled
        } catch {
            print("‚ùå Error updating DLNA settings: \(error)")
            throw error
        }
    }

    func fetchPerformers(filter: PerformerFilter = .all, page: Int = 1, appendResults: Bool = false, search: String = "", completion: @escaping (Result<[StashScene.Performer], Error>) -> Void) {
        isLoading = true

        let sceneCountValue: String
        switch filter {
        case .all:
            sceneCountValue = "0"
        case .lessThanTwo:
            sceneCountValue = "2"
        case .twoOrMore:
            sceneCountValue = "2"
        case .tenOrMore:
            sceneCountValue = "10"
        }

        let sceneCountModifier = filter == .lessThanTwo ? "LESS_THAN" : "GREATER_THAN"

        let escapedQuery = search.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\"")

        // Use full JSON-formatted query for females with >2 scenes and all results (no pagination)
        let query = """
        {
            "operationName": "FindPerformers",
            "variables": {
                "filter": {
                    "q": "\(escapedQuery)",
                    "page": 1,
                    "per_page": 10000,
                    "sort": "name",
                    "direction": "ASC"
                },
                "performer_filter": {
                    "gender": {
                        "value": "FEMALE",
                        "modifier": "EQUALS"
                    },
                    "scene_count": {
                        "modifier": "GREATER_THAN",
                        "value": "2"
                    }
                }
            },
            "query": "query FindPerformers($filter: FindFilterType, $performer_filter: PerformerFilterType) { findPerformers(filter: $filter, performer_filter: $performer_filter) { count performers { id name gender image_path scene_count favorite } } }"
        }
        """

        print("üì° Fetching performers with query: \(query)")

        Task {
            do {
                let data = try await executeGraphQLQuery(query)

                struct PerformersResponseData: Decodable {
                    struct Data: Decodable {
                        let findPerformers: FindPerformersResult
                    }

                    struct FindPerformersResult: Decodable {
                        let count: Int
                        let performers: [StashScene.Performer]
                    }

                    let data: Data
                }

                let decoder = JSONDecoder()
                do {
                    let response = try decoder.decode(PerformersResponseData.self, from: data)

                    await MainActor.run {
                        if appendResults {
                            // Filter out duplicates before appending
                            let newPerformers = response.data.findPerformers.performers.filter { newPerformer in
                                !self.performers.contains { $0.id == newPerformer.id }
                            }
                            self.performers.append(contentsOf: newPerformers)
                            self.totalPerformerCount = response.data.findPerformers.count
                            completion(.success(self.performers))
                        } else {
                            // Clear logging to understand what's happening
                            print("üìä PerformersAPI: Setting performers array with \(response.data.findPerformers.performers.count) performers")
                            self.performers = response.data.findPerformers.performers
                            self.totalPerformerCount = response.data.findPerformers.count
                            print("üìä PerformersAPI: After setting, self.performers has \(self.performers.count) items")
                            completion(.success(response.data.findPerformers.performers))
                        }
                        self.isLoading = false
                    }
                } catch {
                    print("‚ùå Error decoding performers: \(error)")
                    await MainActor.run {
                        self.isLoading = false
                        completion(.failure(error))
                    }
                }
            } catch {
                print("‚ùå Error loading performers: \(error)")
                await MainActor.run {
                    self.isLoading = false
                    completion(.failure(error))
                }
            }
        }
    }

    func searchScenes(query: String, completion: @escaping (Result<[StashScene], Error>) -> Void) {
        // Escape special characters in the search term
        let escaped = query
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")

        // Use filter.q for full-text search across scenes
        let graphQLQuery = """
        query FindScenes($filter: FindFilterType) {
            findScenes(filter: $filter) {
                count
                scenes {
                    id
                    title
                    details
                    url
                    date
                    rating100
                    organized
                    o_counter
                    paths {
                        screenshot
                        preview
                        stream
                    }
                    files {
                        size
                        duration
                        video_codec
                        width
                        height
                    }
                    performers {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                    studio {
                        id
                        name
                    }
                    stash_ids {
                        endpoint
                        stash_id
                    }
                    created_at
                    updated_at
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": escaped,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        executeGraphQLQuery(query: graphQLQuery, variables: variables, completion: { (result: Result<ScenesResponseData, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.findScenes.scenes))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    // Async version of searchScenes
    func searchScenes(query: String) async throws -> [StashScene] {
        // Escape special characters in the search term
        let escaped = query
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")

        // Use filter.q for full-text search across scenes
        let graphQLQuery = """
        query FindScenes($filter: FindFilterType) {
            findScenes(filter: $filter) {
                count
                scenes {
                    id
                    title
                    details
                    url
                    date
                    rating100
                    organized
                    o_counter
                    paths {
                        screenshot
                        preview
                        stream
                    }
                    files {
                        size
                        duration
                        video_codec
                        width
                        height
                    }
                    performers {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                    studio {
                        id
                        name
                    }
                    stash_ids {
                        endpoint
                        stash_id
                    }
                    created_at
                    updated_at
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": escaped,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        let response: ScenesResponseData = try await performGraphQLRequest(query: graphQLQuery, variables: variables)
        return response.findScenes.scenes
    }
    
    /// Find scenes with specified filters (tags, performers, etc.)
    /// - Parameters:
    ///   - filter: Scene filter options
    ///   - page: Page number
    ///   - perPage: Results per page
    /// - Returns: Tuple with scenes array and total count
    func findScenes(filter: SceneFilterType, page: Int = 1, perPage: Int = 20) async throws -> (scenes: [StashScene], count: Int) {
        // Create tag IDs filter if tags are provided
        var tagIDs: String? = nil
        if let tags = filter.tags, !tags.isEmpty {
            tagIDs = "[" + tags.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
            print("üè∑Ô∏è Including tags with IDs: \(tagIDs!)")
        }

        // Create excluded tag IDs filter - always exclude VR tag
        var excludedTagIDs = "[\"vr\"]"
        if let excludedTags = filter.excludedTags, !excludedTags.isEmpty {
            // Include additional excluded tags if present
            if !excludedTags.contains("vr") {
                excludedTagIDs = "[\"vr\", " + excludedTags.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
            } else {
                excludedTagIDs = "[" + excludedTags.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
            }
            print("üè∑Ô∏è Excluding tags with IDs/names: \(excludedTagIDs)")
        } else {
            print("üè∑Ô∏è Excluding VR tag by default")
        }

        // Create performer IDs filter if performers are provided
        var performerIDs: String? = nil
        if let performers = filter.performers, !performers.isEmpty {
            performerIDs = "[" + performers.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
        }

        // Create studio IDs filter if studios are provided
        var studioIDs: String? = nil
        if let studios = filter.studios, !studios.isEmpty {
            studioIDs = "[" + studios.map { "\"\($0)\"" }.joined(separator: ", ") + "]"
        }
        
        let query = """
        {
          "operationName": "FindTaggedScenes",
          "variables": {
            "filter": {
              "page": \(page),
              "per_page": \(perPage)
              \(filter.searchTerm != nil ? ", \"q\": \"\(filter.searchTerm!)\"" : "")
            },
            "scene_filter": {
              \(tagIDs != nil ? "\"tags\": {\"value\": \(tagIDs!), \"modifier\": \"INCLUDES\"}," : "")
              "tags_v2": {
                "value": \(excludedTagIDs),
                "modifier": "EXCLUDES"
              }
              \(performerIDs != nil ? ", \"performers\": {\"value\": \(performerIDs!), \"modifier\": \"INCLUDES\"}" : "")
              \(studioIDs != nil ? ", \"studios\": {\"value\": \(studioIDs!), \"modifier\": \"INCLUDES\"}" : "")
              \(filter.minRating != nil ? ", \"rating100\": {\"value\": \(filter.minRating!), \"modifier\": \"GREATER_THAN\"}" : "")
              \(filter.favoritesOnly == true ? ", \"favorite\": {\"value\": true}" : "")
              \(filter.minDuration != nil ? ", \"duration\": {\"value\": \(filter.minDuration!), \"modifier\": \"GREATER_THAN\"}" : "")
              \(filter.maxDuration != nil ? ", \"duration\": {\"value\": \(filter.maxDuration!), \"modifier\": \"LESS_THAN\"}" : "")
            }
          },
          "query": "query FindTaggedScenes($filter: FindFilterType, $scene_filter: SceneFilterType) { findScenes(filter: $filter, scene_filter: $scene_filter) { count scenes { id title details date rating100 o_counter paths { screenshot stream preview } tags { id name } performers { id name image_path } studio { id name } files { width height video_codec } } } }"
        }
        """
        
        struct FindScenesResponse: Decodable {
            struct Data: Decodable {
                struct FindScenes: Decodable {
                    let count: Int
                    let scenes: [StashScene]
                }
                let findScenes: FindScenes
            }
            let data: Data
        }
        
        do {
            print("üì§ Sending GraphQL query for tag filter: \(query)")
            let data = try await performGraphQLRequest(query: query)
            
            // Debug the response data
            if let jsonString = String(data: data, encoding: .utf8) {
                print("üì• Received GraphQL response: \(jsonString.prefix(500))...")
            }
            
            let decoder = JSONDecoder()
            do {
                let response = try decoder.decode(FindScenesResponse.self, from: data)
                print("‚úÖ Successfully decoded response with \(response.data.findScenes.scenes.count) scenes")
                return (scenes: response.data.findScenes.scenes, count: response.data.findScenes.count)
            } catch let decodingError {
                print("‚ùå Decoding error: \(decodingError)")
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("üì• Failed to decode: \(jsonString)")
                }
                throw decodingError
            }
        } catch {
            print("‚ùå Error fetching scenes: \(error)")
            throw error
        }
    }

    /// Fetch markers for a specific performer with completion handler
    /// - Parameters:
    ///   - performerId: The performer's ID
    ///   - page: Page number
    ///   - completion: Callback with result
    func fetchPerformerMarkers(performerId: String, page: Int = 1, completion: @escaping (Result<[SceneMarker], Error>) -> Void) {
        // Use Task to call the core implementation and return result via completion handler
        Task {
            do {
                let markers = try await fetchPerformerMarkersCore(performerId: performerId, page: page)
                DispatchQueue.main.async {
                    completion(.success(markers))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }

    /// Search for markers by query string with completion handler
    /// - Parameters:
    ///   - query: Search term
    ///   - completion: Callback with result
    func searchMarkers(query: String, completion: @escaping (Result<[SceneMarker], Error>) -> Void) {
        // Use Task to call the core implementation and return result via completion handler
        Task {
            do {
                let markers = try await searchMarkersCore(query: query)
                DispatchQueue.main.async {
                    completion(.success(markers))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }

    // Core implementation for searching markers
    private func searchMarkersCore(query: String) async throws -> [SceneMarker] {
        let graphQLQuery = """
        query FindSceneMarkers($filter: FindFilterType) {
            findSceneMarkers(filter: $filter) {
                count
                scene_markers {
                    id
                    title
                    seconds
                    stream
                    preview
                    screenshot
                    scene {
                        id
                        title
                        paths {
                            screenshot
                            preview
                            stream
                        }
                        performers {
                            id
                            name
                            image_path
                        }
                        studio {
                            id
                            name
                        }
                    }
                    primary_tag {
                        id
                        name
                    }
                    tags {
                        id
                        name
                    }
                }
            }
        }
        """

        let variables: [String: Any] = [
            "filter": [
                "q": query,
                "page": 1,
                "per_page": 40,
                "sort": "title",
                "direction": "ASC"
            ]
        ]

        struct SceneMarkersResponse: Decodable {
            let findSceneMarkers: SceneMarkersData

            struct SceneMarkersData: Decodable {
                let count: Int
                let scene_markers: [SceneMarker]
            }
        }

        // Use executeGraphQLQuery instead of performGraphQLRequest
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        let requestBody: [String: Any] = [
            "query": graphQLQuery,
            "variables": variables
        ]

        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            throw StashAPIError.invalidData("Cannot serialize request body")
        }

        request.httpBody = jsonData

        let (data, _) = try await URLSession.shared.data(for: request)

        struct GraphQLResponse<T: Decodable>: Decodable {
            let data: T
            let errors: [GraphQLError]?
        }

        let response = try JSONDecoder().decode(GraphQLResponse<SceneMarkersResponse>.self, from: data)

        if let errors = response.errors, !errors.isEmpty {
            let errorMessages = errors.map { $0.message }.joined(separator: ", ")
            throw StashAPIError.graphQLError(errorMessages)
        }

        return response.data.findSceneMarkers.scene_markers
    }

    // Public async version of searchMarkers
    func searchMarkers(query: String) async throws -> [SceneMarker] {
        return try await searchMarkersCore(query: query)
    }

    /// Helper method that updates the internal markers array with search results
    /// - Parameter query: Search term
    func updateMarkersFromSearch(query: String) async {
        isLoading = true

        let graphQLQuery = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "q": "\(query)",
                    "page": 1,
                    "per_page": 40,
                    "sort": "title",
                    "direction": "ASC"
                },
                "scene_marker_filter": {}
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title paths { screenshot preview stream } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
        }
        """

        print("üîç Searching markers with query: '\(query)'")

        do {
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("*/*", forHTTPHeaderField: "Accept")
            request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
            request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
            request.setValue("keep-alive", forHTTPHeaderField: "Connection")
            request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.setValue(serverAddress, forHTTPHeaderField: "Origin")
            request.httpBody = graphQLQuery.data(using: .utf8)

            let (data, _) = try await URLSession.shared.data(for: request)

            struct SceneMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data
            }

            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)

            await MainActor.run {
                self.markers = response.data.findSceneMarkers.scene_markers
                print("‚úÖ Found \(response.data.findSceneMarkers.scene_markers.count) markers matching '\(query)'")
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                print("‚ùå Error searching markers: \(error)")
                self.markers = []
                self.error = error
                self.isLoading = false
            }
        }
    }

    func createSceneMarker(sceneId: String, title: String, seconds: Float, primaryTagId: String, tagIds: [String], completion: @escaping (Result<SceneMarker, Error>) -> Void) {
        let query = """
        mutation SceneMarkerCreate($input: SceneMarkerCreateInput!) {
            sceneMarkerCreate(input: $input) {
                id
                title
                seconds
                stream
                preview
                screenshot
                primary_tag {
                    id
                    name
                }
                tags {
                    id
                    name
                }
                scene {
                    id
                    title
                }
            }
        }
        """

        let input: [String: Any] = [
            "scene_id": sceneId,
            "title": title,
            "seconds": seconds,
            "primary_tag_id": primaryTagId,
            "tag_ids": tagIds
        ]

        let variables: [String: Any] = ["input": input]

        struct CreateMarkerResponse: Decodable {
            let sceneMarkerCreate: SceneMarker
        }

        executeGraphQLQuery(query: query, variables: variables, completion: { (result: Result<CreateMarkerResponse, Error>) in
            switch result {
            case .success(let response):
                completion(.success(response.sceneMarkerCreate))
            case .failure(let error):
                completion(.failure(error))
            }
        })
    }

    func testConnection(completion: @escaping (Bool) -> Void) {
        let query = """
        query SystemStatus {
          systemStatus {
            status
          }
        }
        """

        struct SystemStatusResponse: Decodable {
            let systemStatus: SystemStatus
        }

        executeGraphQLQuery(query: query, variables: nil, completion: { (result: Result<SystemStatusResponse, Error>) in
            switch result {
            case .success(_):
                completion(true)
            case .failure(_):
                completion(false)
            }
        })
    }

    // Helper method to encode dictionary to JSON string
    private func encodeJSON(_ dict: [String: Any]) -> String {
        guard let data = try? JSONSerialization.data(withJSONObject: dict) else {
            return "{}"
        }
        return String(data: data, encoding: .utf8) ?? "{}"
    }

    // Method for async/await calls and to support MarkersView
    func fetchMarkers(page: Int = 1, appendResults: Bool = false, performerId: String? = nil) async {
        isLoading = true
        
        // Generate a random seed for consistent random sorting
        let randomSeed = Int.random(in: 0...999999)
        
        let graphQLQuery = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 100,
                    "sort": "random_\(randomSeed)",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    \(performerId != nil ? "\"performers\": {\"value\": [\"\(performerId!)\"], \"modifier\": \"INCLUDES_ALL\"}" : "")
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { ...SceneMarkerData __typename } __typename } } fragment SceneMarkerData on SceneMarker { id title seconds end_seconds stream preview screenshot scene { ...SceneMarkerSceneData __typename } primary_tag { id name __typename } tags { id name __typename } __typename } fragment SceneMarkerSceneData on Scene { id title files { width height path __typename } performers { id name image_path __typename } __typename }"
        }
        """
        
        print("üîç Fetching markers (page \(page)) from \(serverAddress)")
        
        guard let url = URL(string: "\(serverAddress)/graphql") else {
            print("‚ùå Invalid URL for markers")
            isLoading = false
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("u=3, i", forHTTPHeaderField: "Priority")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
        request.setValue("\(serverAddress)/scenes/markers", forHTTPHeaderField: "Referer")
        request.httpBody = graphQLQuery.data(using: .utf8)
        
        // Add API Key header which wasn't in the original but might be needed according to documentation
        request.setValue(apiKey, forHTTPHeaderField: "ApiKey")
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            // Debug: Print the response data
            if let jsonString = String(data: data, encoding: .utf8)?.prefix(500) {
                print("üîç Response data preview: \(jsonString)...")
            }
            
            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)
            
            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let newMarkers = response.data.findSceneMarkers.scene_markers.filter { newMarker in
                        !self.markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: newMarkers)
                    print("‚úÖ Added \(newMarkers.count) new markers")
                    
                    // Debug log for first marker
                    if let firstMarker = self.markers.first {
                        print("üìä First marker details:")
                        print("  ID: \(firstMarker.id)")
                        print("  Title: \(firstMarker.title)")
                        print("  Scene ID: \(firstMarker.scene.id)")
                    }
                } else {
                    self.markers = response.data.findSceneMarkers.scene_markers
                    print("‚úÖ Set \(response.data.findSceneMarkers.scene_markers.count) markers")
                    
                    // Debug log for first marker
                    if let firstMarker = self.markers.first {
                        print("üìä First marker details:")
                        print("  ID: \(firstMarker.id)")
                        print("  Title: \(firstMarker.title)")
                        print("  Scene ID: \(firstMarker.scene.id)")
                    }
                }
                
                self.isLoading = false
            }
        } catch {
            print("‚ùå Error loading markers: \(error)")
            self.error = error
            isLoading = false
        }
    }// END NEW FETCHMARKERS
    func fetchMarkersByTag(tagId: String, page: Int = 1, appendResults: Bool = false) async {
        isLoading = true

        let query = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 40,
                    "sort": "title",
                    "direction": "ASC"
                },
                "scene_marker_filter": {
                    "tags": {
                        "value": ["\(tagId)"],
                        "modifier": "INCLUDES_ALL"
                    }
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title paths { screenshot preview stream } performers { id name image_path } } primary_tag { id name } tags { id name } } } }"
        }
        """

        print("üîç Fetching markers for tag \(tagId) (page \(page))")

        do {
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                throw StashAPIError.invalidURL
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("*/*", forHTTPHeaderField: "Accept")
            request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.setValue(serverAddress, forHTTPHeaderField: "Origin")
            request.httpBody = query.data(using: .utf8)

            let (data, _) = try await URLSession.shared.data(for: request)

            struct SceneMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data
            }

            let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)

            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let newMarkers = response.data.findSceneMarkers.scene_markers.filter { newMarker in
                        !self.markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: newMarkers)
                    print("‚úÖ Added \(newMarkers.count) new markers for tag \(tagId)")
                } else {
                    self.markers = response.data.findSceneMarkers.scene_markers
                    print("‚úÖ Set \(response.data.findSceneMarkers.scene_markers.count) markers for tag \(tagId)")
                }

                self.isLoading = false
            }
        } catch {
            print("‚ùå Error loading markers by tag: \(error)")
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }

    // Core implementation for fetching performer markers
    private func fetchPerformerMarkersCore(performerId: String, page: Int = 1) async throws -> [SceneMarker] {
        // Using raw JSON format like in Vision Pro implementation
        let graphQLQuery = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": {
                    "page": \(page),
                    "per_page": 50,
                    "sort": "date",
                    "direction": "DESC"
                },
                "scene_marker_filter": {
                    "performers": {
                        "value": ["\(performerId)"],
                        "modifier": "INCLUDES"
                    }
                }
            },
            "query": "query FindSceneMarkers($filter: FindFilterType, $scene_marker_filter: SceneMarkerFilterType) { findSceneMarkers(filter: $filter, scene_marker_filter: $scene_marker_filter) { count scene_markers { id title seconds stream preview screenshot scene { id title paths { screenshot preview stream } performers { id name image_path } studio { id name } } primary_tag { id name } tags { id name } } } }"
        }
        """

        guard let url = URL(string: "\(serverAddress)/graphql") else {
            throw StashAPIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
        request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("ApiKey \(apiKey)", forHTTPHeaderField: "ApiKey")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue(serverAddress, forHTTPHeaderField: "Origin")
        request.httpBody = graphQLQuery.data(using: .utf8)

        print("üì§ Fetching performer markers for ID: \(performerId), page: \(page)")
        let (data, response) = try await URLSession.shared.data(for: request)

        // Log HTTP response code for debugging
        if let httpResponse = response as? HTTPURLResponse {
            print("üì• HTTP response: \(httpResponse.statusCode)")

            // Show response for troubleshooting
            if let jsonStr = String(data: data, encoding: .utf8) {
                print("üì• Response preview: \(jsonStr.prefix(300))...")
            }

            // Check for server errors
            if httpResponse.statusCode >= 400 {
                throw StashAPIError.serverError(httpResponse.statusCode)
            }
        }

        // Define response structure matching the API format
        struct MarkerResponse: Decodable {
            struct Data: Decodable {
                let findSceneMarkers: FindSceneMarkersResult

                struct FindSceneMarkersResult: Decodable {
                    let count: Int
                    let scene_markers: [SceneMarker]
                }
            }
            let data: Data
            let errors: [GraphQLError]?
        }

        // Decode the response with more detailed error handling
        do {
            let response = try JSONDecoder().decode(MarkerResponse.self, from: data)

            // Check for GraphQL errors
            if let errors = response.errors, !errors.isEmpty {
                let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                throw StashAPIError.graphQLError(errorMessages)
            }

            print("‚úÖ Successfully loaded \(response.data.findSceneMarkers.scene_markers.count) markers")
            return response.data.findSceneMarkers.scene_markers
        } catch {
            print("‚ùå JSON decoding error: \(error)")

            // Try to identify structure issues
            if let decodingError = error as? DecodingError {
                switch decodingError {
                case .keyNotFound(let key, let context):
                    print("Missing key: \(key) - \(context.debugDescription)")
                case .typeMismatch(let type, let context):
                    print("Type mismatch: \(type) - \(context.debugDescription)")
                case .valueNotFound(let type, let context):
                    print("Value not found: \(type) - \(context.debugDescription)")
                case .dataCorrupted(let context):
                    print("Data corrupted: \(context.debugDescription)")
                @unknown default:
                    print("Unknown decoding error")
                }
            }

            throw error
        }
    }

    /// Public async method for fetching performer markers
    /// - Parameters:
    ///   - performerId: The performer ID
    ///   - page: Page number
    /// - Returns: Array of scene markers
    func fetchPerformerMarkers(performerId: String, page: Int = 1) async throws -> [SceneMarker] {
        return try await fetchPerformerMarkersCore(performerId: performerId, page: page)
    }

    /// Helper method that updates the internal markers array and handles state
    /// - Parameters:
    ///   - performerId: The performer ID
    ///   - page: Page number
    ///   - appendResults: Whether to append results or replace existing ones
    func fetchPerformerMarkers(performerId: String, page: Int = 1, appendResults: Bool = false) async {
        isLoading = true
        do {
            let newMarkers = try await fetchPerformerMarkersCore(performerId: performerId, page: page)
            await MainActor.run {
                if appendResults {
                    // Filter out duplicates before appending
                    let uniqueNewMarkers = newMarkers.filter { newMarker in
                        !markers.contains { $0.id == newMarker.id }
                    }
                    self.markers.append(contentsOf: uniqueNewMarkers)
                } else {
                    self.markers = newMarkers
                }
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                print("Error loading performer markers: \(error)")
                self.error = error
                self.isLoading = false
            }
        }
    }
}

// MARK: - Additional Data Models

// StashStats model for stats endpoint
struct StashStats: Codable {
    let scene_count: Int
    let scenes_size: Int64
    let scene_duration: Double
    let image_count: Int
    let images_size: Int64
    let gallery_count: Int
    let performer_count: Int
    let studio_count: Int
    let movie_count: Int
    let tag_count: Int
}

// Additional filter models
struct TagFilter {
    var name: String?
    var sceneCount: Int?

    func toDictionary() -> [String: Any] {
        var result: [String: Any] = [:]
        if let name = name {
            result["name"] = ["modifier": "INCLUDES", "value": name]
        }
        if let sceneCount = sceneCount {
            result["scene_count"] = ["modifier": "GREATER_THAN", "value": sceneCount]
        }
        return result
    }
}

================
File: original_fetchMarkers.txt
================
func fetchMarkers(page: Int = 1, appendResults: Bool = false, performerId: String? = nil) async {
        isLoading = true

        // Define GraphQL error structure (ensure it exists and is correctly defined)
        struct GraphQLError: Decodable {
            let message: String
            let path: [String]?
        }

        // Use the absolute simplest query possible to get any markers
        var filterDict: [String: Any] = [
            "page": page,
            "per_page": 40
        ]

        // Create the query string with proper JSON formatting
        let query = """
        {
            "operationName": "FindSceneMarkers",
            "variables": {
                "filter": \(encodeJSON(filterDict))
            },
            "query": "query FindSceneMarkers($filter: FindFilterType) { findSceneMarkers(filter: $filter) { count scene_markers { id title seconds stream preview screenshot scene { id title } primary_tag { id name } tags { id name } } } }"
        }
        """

        print("üîç Fetching markers (page \(page)) from \(serverAddress)")
        print("üîç Query excerpt: \(query.prefix(200))...")

        do {
            // Looking at the curl command more closely, the apikey isn't in the URL
            guard let url = URL(string: "\(serverAddress)/graphql") else {
                print("‚ùå Invalid URL for fetching markers: \(serverAddress)/graphql")
                throw StashAPIError.invalidURL
            }
            print("üîç Using standard graphql URL without apikey parameter")

            // Create and configure the request with headers matching the working curl command
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("*/*", forHTTPHeaderField: "Accept")
            request.setValue("gzip, deflate", forHTTPHeaderField: "Accept-Encoding")
            request.setValue("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15", forHTTPHeaderField: "User-Agent")
            request.setValue("keep-alive", forHTTPHeaderField: "Connection")
            request.setValue("nc_sameSiteCookielax=true; nc_sameSiteCookiestrict=true", forHTTPHeaderField: "Cookie")
            request.setValue("en-US,en;q=0.9", forHTTPHeaderField: "Accept-Language")
            request.setValue("u=3, i", forHTTPHeaderField: "Priority")

            // Set the origin to match exactly
            request.setValue(serverAddress, forHTTPHeaderField: "Origin")
            // Set a referer that matches the server's expectation exactly as in the curl command
            request.setValue("\(serverAddress)/scenes/markers?q=cowgirl%20-reverse&sortby=random_60376890&perPage=20&disp=2", forHTTPHeaderField: "Referer")

            // Analyze the request headers in the curl command more carefully
            print("üîç Using exact headers from the curl command")

            // Since we're still getting errors, let's try a hybrid approach - using both the Cookie and the ApiKey
            // Some Stash instances might use cookies for frontend auth but still need ApiKey for API calls
            print("üîç Using hybrid auth approach with both Cookie and ApiKey")
            request.setValue(apiKey, forHTTPHeaderField: "ApiKey")

            // Set the request body
            let jsonData = query.data(using: .utf8)!
            request.setValue("\(jsonData.count)", forHTTPHeaderField: "Content-Length")
            request.httpBody = jsonData

            // Execute the request
            let (data, urlResponse) = try await URLSession.shared.data(for: request)

            // Log the HTTP response status
            if let httpResp = urlResponse as? HTTPURLResponse {
                print("üîç HTTP response status: \(httpResp.statusCode)")

                // Check for HTTP errors
                if httpResp.statusCode >= 400 {
                    print("‚ùå HTTP error: \(httpResp.statusCode)")
                    throw StashAPIError.serverError(httpResp.statusCode)
                }
            }

            // Debug the raw response in more detail
            if let jsonString = String(data: data, encoding: .utf8) {
                // Always show FULL response for debugging
                print("üîç FULL Response data (\(data.count) bytes):\n\(jsonString)")

                // Try extracting error information if data doesn't match our expected format
                do {
                    if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                        if let message = json["message"] as? String {
                            print("‚ùå API Error Message: \(message)")
                        }
                        if let status = json["status"] as? Int {
                            print("‚ùå API Status Code: \(status)")
                        }
                    }
                } catch {
                    print("‚ùå Failed to parse response as JSON: \(error)")
                }
            }

            // Define the response structure to match exactly what the server returns
            // Simplified response structure that matches our simpler query
            struct SceneMarkersResponse: Decodable {
                struct Data: Decodable {
                    struct FindSceneMarkers: Decodable {
                        let count: Int
                        let scene_markers: [SceneMarker]
                    }
                    let findSceneMarkers: FindSceneMarkers
                }
                let data: Data?
                let errors: [GraphQLError]?

                    // Convert to our standard SceneMarker model
                    func toSceneMarker() -> SceneMarker {
                        let scenePerformers = scene.performers?.map { performer in
                            StashScene.Performer(id: performer.id,
                                                 name: performer.name,
                                                 gender: nil,
                                                 image_path: performer.image_path,
                                                 scene_count: nil,
                                                 favorite: nil,
                                                 rating100: nil)
                        } ?? []

                        // Construct paths object if files are available
                        let scenePaths = SceneMarker.MarkerScene.ScenePaths(
                            screenshot: screenshot,
                            preview: preview,
                            stream: stream
                        )

                        // Create a scene with performers
                        let markerScene = SceneMarker.MarkerScene(
                            id: scene.id,
                            title: scene.title,
                            paths: scenePaths,
                            performers: scenePerformers
                        )

                        // Create the primary tag
                        let primaryTag = SceneMarker.Tag(id: primary_tag.id, name: primary_tag.name)

                        // Map the tags
                        let mappedTags = tags.map { SceneMarker.Tag(id: $0.id, name: $0.name) }

                        return SceneMarker(
                            id: id,
                            title: title,
                            seconds: seconds,
                            stream: stream,
                            preview: preview,
                            screenshot: screenshot,
                            scene: markerScene,
                            primary_tag: primaryTag,
                            tags: mappedTags
                        )
                    }
                }
            }

            do {
                // Attempt to decode the response
                let response = try JSONDecoder().decode(SceneMarkersResponse.self, from: data)

                // Check for GraphQL errors
                if let errors = response.errors, !errors.isEmpty {
                    let errorMessages = errors.map { $0.message }.joined(separator: ", ")
                    print("‚ùå GraphQL errors: \(errorMessages)")
                    throw StashAPIError.graphQLError(errorMessages)
                }

                // Check for missing data field
                guard let responseData = response.data else {
                    print("‚ùå Missing data field in response")
                    throw StashAPIError.dataNotFound("No data field in response")
                }

                print("‚úÖ Successfully decoded \(responseData.findSceneMarkers.scene_markers.count) markers")

                // Log details of first marker for debugging
                if let firstMarker = responseData.findSceneMarkers.scene_markers.first {
                    print("üìä First marker details:")
                    print("  ID: \(firstMarker.id)")
                    print("  Title: \(firstMarker.title)")
                    print("  Scene ID: \(firstMarker.scene.id)")
                    print("  Has performers: \(firstMarker.scene.performers != nil && !(firstMarker.scene.performers?.isEmpty ?? true))")
                    if let performers = firstMarker.scene.performers, !performers.isEmpty {
                        print("  First performer: \(performers[0].name) (ID: \(performers[0].id))")
                    }
                }

                // Convert the typed response to our model
                // The markers are already in the right format - no conversion needed
                let sceneMarkers = responseData.findSceneMarkers.scene_markers
                print("‚úÖ Decoded \(sceneMarkers.count) markers directly")

                await MainActor.run {
                    if appendResults {
                        // Filter out duplicates before appending
                        let newMarkers = sceneMarkers.filter { newMarker in
                            !self.markers.contains { $0.id == newMarker.id }
                        }
                        self.markers.append(contentsOf: newMarkers)
                        print("‚úÖ Added \(newMarkers.count) new markers (total: \(self.markers.count))")
                    } else {
                        self.markers = sceneMarkers
                        print("‚úÖ Set \(sceneMarkers.count) markers")
                    }

                    self.isLoading = false
                }
            } catch let decodingError {
                print("‚ùå JSON decoding error: \(decodingError)")

                // Try to provide more detailed error information
                if let decodingError = decodingError as? DecodingError {
                    switch decodingError {
                    case .keyNotFound(let key, let context):
                        print("‚ùå Missing key: \(key.stringValue) in \(context.codingPath)")
                    case .typeMismatch(let type, let context):
                        print("‚ùå Type mismatch: expected \(type) in \(context.codingPath)")
                    case .valueNotFound(let type, let context):
                        print("‚ùå Value not found: \(type) in \(context.codingPath)")
                    case .dataCorrupted(let context):
                        print("‚ùå Data corrupted: \(context)")
                    @unknown default:
                        print("‚ùå Unknown decoding error")
                    }
                }

                // Manual fallback: extract markers directly from JSON if possible
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let dataObject = json["data"] as? [String: Any],
                   let findSceneMarkers = dataObject["findSceneMarkers"] as? [String: Any],
                   let sceneMarkersArray = findSceneMarkers["scene_markers"] as? [[String: Any]] {

                    print("üîç Direct JSON extraction found \(sceneMarkersArray.count) markers")

                    // Try to manually construct markers (enhanced version)
                    var manualMarkers: [SceneMarker] = []

                    for markerData in sceneMarkersArray {
                        // Use NSNumber for better number handling
                        if let id = markerData["id"] as? String,
                           let title = markerData["title"] as? String,
                           let seconds = (markerData["seconds"] as? NSNumber)?.floatValue ?? (markerData["seconds"] as? Double).flatMap({ Float($0) }),
                           let stream = markerData["stream"] as? String,
                           let preview = markerData["preview"] as? String,
                           let screenshot = markerData["screenshot"] as? String,
                           let sceneData = markerData["scene"] as? [String: Any],
                           let sceneId = sceneData["id"] as? String,
                           let primaryTagData = markerData["primary_tag"] as? [String: Any],
                           let primaryTagId = primaryTagData["id"] as? String,
                           let primaryTagName = primaryTagData["name"] as? String,
                           seconds != nil { // Ensure seconds is not nil

                            // Get performers if available
                            var scenePerformers: [StashScene.Performer] = []
                            if let performersArray = sceneData["performers"] as? [[String: Any]] {
                                for performerData in performersArray {
                                    if let performerId = performerData["id"] as? String,
                                       let performerName = performerData["name"] as? String {
                                        let performer = StashScene.Performer(
                                            id: performerId,
                                            name: performerName,
                                            gender: nil,
                                            image_path: performerData["image_path"] as? String,
                                            scene_count: nil,
                                            favorite: nil,
                                            rating100: nil
                                        )
                                        scenePerformers.append(performer)
                                    }
                                }
                            }

                            // Get tags if available
                            var markerTags: [SceneMarker.Tag] = []
                            if let tagsArray = markerData["tags"] as? [[String: Any]] {
                                for tagData in tagsArray {
                                    if let tagId = tagData["id"] as? String,
                                       let tagName = tagData["name"] as? String {
                                        let tag = SceneMarker.Tag(id: tagId, name: tagName)
                                        markerTags.append(tag)
                                    }
                                }
                            }

                            // Create scene paths
                            let scenePaths = SceneMarker.MarkerScene.ScenePaths(
                                screenshot: screenshot,
                                preview: preview,
                                stream: stream
                            )

                            // Create scene with performers
                            let sceneTitle = sceneData["title"] as? String
                            let markerScene = SceneMarker.MarkerScene(
                                id: sceneId,
                                title: sceneTitle,
                                paths: scenePaths,
                                performers: scenePerformers.isEmpty ? nil : scenePerformers
                            )

                            // Create a complete marker with all available data
                            let marker = SceneMarker(
                                id: id,
                                title: title,
                                seconds: seconds,
                                stream: stream,
                                preview: preview,
                                screenshot: screenshot,
                                scene: markerScene,
                                primary_tag: SceneMarker.Tag(id: primaryTagId, name: primaryTagName),
                                tags: markerTags
                            )

                            manualMarkers.append(marker)
                        }
                    }

                    if !manualMarkers.isEmpty {
                        print("‚úÖ Successfully created \(manualMarkers.count) markers manually")

                        // Log details of first marker for debugging
                        if let firstMarker = manualMarkers.first {
                            print("üìä First manual marker details:")
                            print("  ID: \(firstMarker.id)")
                            print("  Title: \(firstMarker.title)")
                            print("  Scene ID: \(firstMarker.scene.id)")
                            print("  Has performers: \(firstMarker.scene.performers != nil && !(firstMarker.scene.performers?.isEmpty ?? true))")
                            if let performers = firstMarker.scene.performers, !performers.isEmpty {
                                print("  First performer: \(performers[0].name) (ID: \(performers[0].id))")
                            }
                            print("  Screenshot URL: \(firstMarker.screenshot)")
                            print("  Stream URL: \(firstMarker.stream)")
                        }

                        // Update markers on main thread
                        Task { @MainActor in
                            if appendResults {
                                // Filter out duplicates before appending
                                let newMarkers = manualMarkers.filter { newMarker in
                                    !self.markers.contains { $0.id == newMarker.id }
                                }
                                self.markers.append(contentsOf: newMarkers)
                                print("‚úÖ Added \(newMarkers.count) new markers manually (total: \(self.markers.count))")
                            } else {
                                self.markers = manualMarkers
                                print("‚úÖ Set \(manualMarkers.count) markers manually")
                            }

                            self.isLoading = false
                        }
                        return // Exit without throwing error since we recovered
                    } else {
                        print("‚ö†Ô∏è Failed to extract any valid markers manually")
                    }
                }

                // If all else fails, throw the original error
                throw StashAPIError.decodingError(decodingError)
            }
        } catch {
            print("‚ùå Error fetching markers: \(error)")
            if let apiError = error as? StashAPIError {
                print("‚ùå StashAPI Error: \(apiError)")
            } else {
                print("‚ùå Other Error: \(error.localizedDescription)")
            }

            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }

    // Fetches markers by tag ID

================
File: prompt.md
================
I‚Äôm providing a detailed specification for implementing the MarkerView and the Markers section within PerformerView for our Stash VisionPro app, targeting iOS/iPadOS 18, with a requirement to enforce strict HLS playback for all video content. These components are essential for navigating marked moments in scenes and enhancing performer-related interactions. Below are the requirements and guidelines, aligned with our SwiftUI-based architecture and Stash API, without including code.

1. MarkerView Implementation
Purpose: A reusable view to display a list of markers (specific timestamps in a scene) for a given scene, allowing users to navigate to these points in the video player.

Requirements:

Data Source: Retrieve marker data from the StashScene model, including marker ID, title, timestamp (in seconds), and primary tag.
UI Components:
Present markers in a user-configurable scrollable list or grid.
Each marker item should display a thumbnail (from scene‚Äôs VTT/sprite endpoints), title, primary tag, and timestamp (MM:SS format).
Include a filter bar to sort by tag or timestamp.
Provide a context menu per marker for editing (title, tag) or deleting (with confirmation).
Interaction:
Tapping a marker seeks the video player to the marker‚Äôs timestamp using HLS playback.
Support drag-and-drop to reorder markers if editable.
Accessibility:
Ensure VoiceOver compatibility with descriptive labels (e.g., ‚ÄúMarker: Action Scene at 1:30‚Äù).
Support Dynamic Type and high contrast ratios.
Performance:
Lazy-load thumbnails and cache marker data/thumbnails using existing mechanisms.
Integration:
Embed in SceneFileInfoView and PerformerScenesView.
Coordinate with the video player for seamless seek actions.
Technical Guidelines:

File Location: Store in Stash/Features/Markers/MarkerView.swift.
Architecture: Use MVVM with a view model to manage data fetching, filtering/sorting, and player coordination.
Dependencies: Rely on AVKit for HLS playback, Combine for reactive updates, and StashAPI for GraphQL queries.
API Integration: Extend FindScene GraphQL query to include markers (ID, title, seconds, primary_tag). Fetch VTT/sprite thumbnails via URLSession.
Error Handling: Show user-friendly errors for failed API calls and log issues using the existing logger utility.
Styling: Use a minimal, visionOS-inspired design with semi-transparent backgrounds, rounded corners, and system icons for actions.
2. PerformerView > Markers Implementation
Purpose: A section within PerformerView to display all markers associated with a performer‚Äôs scenes, enabling quick access to key moments.

Requirements:

Data Source: Aggregate markers from all scenes linked to a performer via the FindPerformers GraphQL query, cross-referencing with FindScene for marker data.
UI Components:
Display markers in a scrollable list or grid, similar to MarkerView, with thumbnails, titles, tags, timestamps, and scene titles for context.
Include a filter bar to sort by tag, timestamp, or scene.
Provide a context menu for editing/deleting markers (if permitted).
Interaction:
Tapping a marker loads the corresponding scene in the video player (using HLS) and seeks to the timestamp.
Allow navigation to the full scene details view.
Accessibility: Same as MarkerView (VoiceOver, Dynamic Type, high contrast).
Performance: Use lazy loading and caching for thumbnails and data.
Integration: Embed within PerformerDetailView or PerformerScenesView, ensuring seamless navigation to the video player.
Technical Guidelines:

File Location: Extend PerformerScenesView.swift or create a new PerformerMarkersView.swift in Stash/Features/Performers/.
Architecture: Use MVVM, with a view model to handle performer-specific marker aggregation and filtering.
Dependencies: Same as MarkerView, with additional logic to query performer-related scenes.
API Integration: Use FindPerformers to get scene IDs, then FindScene for marker data. Fetch thumbnails via VTT/sprite endpoints.
Error Handling: Display errors for failed queries and log them.
Styling: Match MarkerView styling for consistency, with added context (e.g., scene title) for performer-specific markers.
3. Strict HLS Playback Requirement
Purpose: Enforce HLS streaming for all video playback in the iOS/iPadOS 18 app to ensure smooth performance, especially for HEVC/H.265 and VR content.

Requirements:

Playback Mode: Disable direct streaming; use only HLS streaming ({serverURL}/scene/{id}/stream.m3u8?apikey={key}&resolution={res}).
UI Adjustment: Remove the HLS/Direct toggle button from VideoPlayerView and related views, as only HLS will be supported.
Resolution Handling: Support HLS resolutions (240p, 480p, 720p, 1080p, 4k, original), with user-selectable options in player settings.
Fallback: Implement automatic fallback to lower resolutions if buffering occurs, prioritizing smooth playback.
Player Integration:
Configure AVPlayer in VideoPlayerView to use HLS playlists exclusively.
Ensure marker seek actions use HLS segment alignment for accurate navigation.
Performance:
Optimize HLS streaming with efficient buffering and caching.
Handle VR content (detected via tags like ‚Äúvr‚Äù, ‚Äú180‚Äù, ‚Äú360‚Äù) with HLS to ensure compatibility.
Error Handling: Display user-friendly errors for HLS stream failures (e.g., ‚ÄúUnable to load video‚Äù) and log details.
Technical Guidelines:

File Modifications:
Update VideoPlayerView.swift to enforce HLS URLs and remove direct streaming logic.
Modify PreviewPlayerManager.swift to initialize AVPlayer with HLS playlists only.
Update VideoPlayerUtility.swift to handle HLS-specific seek and playback logic.
API Integration: Use HLS stream endpoints exclusively; ensure API key authentication is included in URL parameters.
Dependencies: Rely on AVKit for HLS playback and URLSession for stream fetching.
Settings: Store user-selected resolution preferences in UserDefaults, defaulting to ‚Äúoriginal‚Äù for optimal quality.
Logging: Log HLS-specific errors (e.g., stream timeouts, resolution fallback) using the existing logger.
